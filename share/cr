adlc/dfa.cpp:      if( debug_output ) { fprintf(fp, "// Previous rule with lower cost than: %s === %s_rule costs %s\n", arrayIdx, rule, cost->as_string()); }
adlc/dfa.cpp:    if( cost->less_than_or_equal(previous_lb) ) {
adlc/dfa.cpp:    fprintf(fp, "%sif (STATE__NOT_YET_VALID(%s) || _cost[%s] > %s) {\n",  spaces, arrayIdx, arrayIdx, cost->as_string());
adlc/dfa.cpp:      fprintf(fp, "%sif ( /* %s KNOWN_VALID || */ _cost[%s] > %s) {\n",  spaces, arrayIdx, arrayIdx, cost->as_string());
adlc/dfa.cpp:  fprintf(fp, "%s  %s(%s, %s_rule, %s)", spaces, production, arrayIdx, rule, cost->as_string() );
adlc/dfa.cpp://---------------------------child_test----------------------------------------
adlc/dfa.cpp://---------------------------calc_cost-----------------------------------------
adlc/dfa.cpp:    for(lst->reset(); (lst->iter(result,cost,rule)) == true; ) {
adlc/dfa.cpp:        Expr *total_cost = icost->clone();  // icost + cost
adlc/dfa.cpp:        total_cost->add(cost, *this);
adlc/dfa.cpp://---------------------------prune_matchlist-----------------------------------
adlc/dfa.cpp:    for( MatchList *mList = matchList; mList != NULL; mList = mList->get_next() ) {
adlc/dfa.cpp:      Predicate* predicate = mList->get_pred_obj();
adlc/dfa.cpp:      char*      pred      = mList->get_pred();
adlc/dfa.cpp:    mList = mList->get_next();
adlc/dfa.cpp:    mList = mList->get_next();
adlc/dfa.cpp:  cost->_external_name = _external_name;
adlc/dfa.cpp:  cost->_expr          = _expr;
adlc/dfa.cpp:  cost->_min_value     = _min_value;
adlc/dfa.cpp:  cost->_max_value     = _max_value;
adlc/dfa.cpp:    p->_cost_lb = cost->clone();
adlc/dfa.cpp:    p->_cost_ub = cost->clone();
adlc/dfa.cpp:    if( cost->less_than_or_equal(p->_cost_lb) ) {
adlc/dfa.cpp:      p->_cost_lb = cost->clone();
adlc/dfa.cpp:      p->_cost_ub = cost->clone();
adlc/dfa.cpp:    if( cost->less_than_or_equal(p->_cost_lb) ) {
adlc/dfa.cpp:      p->_cost_lb = cost->clone();
adlc/dfa.cpp:    if( cost->less_than_or_equal(p->_cost_ub) ) {
adlc/dfa.cpp:      p->_cost_ub = cost->clone();
adlc/dfa.cpp:    p->_cost_lb = cost->clone();
adlc/dfa.cpp:    p->_cost_ub = cost->clone();
adlc/archDesc.cpp:  if (!lst->search(result)) {
adlc/archDesc.cpp:    lst->insert(result, cost, result);
adlc/archDesc.cpp://------------------------------buildMatchList---------------------------------
adlc/output_c.cpp:  fprintf(fp_cpp, "    st->print(\"%%s\", bundle_flags[_flags]);\n");
adlc/output_c.cpp:  fprintf(fp_cpp, "    st->print(\"%%s%%d instr%%s\", needs_comma ? \", \" : \"\", instr_count(), instr_count() != 1 ? \"s\" : \"\");\n");
adlc/output_c.cpp:  fprintf(fp_cpp, "    st->print(\"%%sresource%%s:\", needs_comma ? \", \" : \"\", (r & (r-1)) != 0 ? \"s\" : \"\");\n");
adlc/output_c.cpp:  fprintf(fp_cpp, "        st->print(\" %%s\", resource_names[i]);\n");
adlc/output_c.cpp:  fprintf(fp_cpp, "  st->print(\"\\n\");\n");
adlc/output_c.cpp:        inst->index_temps( fp, globals, inst_prefix, receiver );
adlc/output_c.cpp:      if (node->is_ideal_if() && new_inst->is_ideal_if()) {
adlc/output_c.cpp:      if (node->is_ideal_fastlock() && new_inst->is_ideal_fastlock()) {
adlc/output_c.cpp:          new_inst->captures_bottom_type(_globalNames)) {
adlc/output_c.cpp:      const char *resultOper = new_inst->reduce_result();
adlc/output_c.cpp:      NameList *formal_lst = &new_inst->_parameters;
adlc/output_c.cpp:      formal_lst->reset();
adlc/output_c.cpp:      int memory_operand = new_inst->memory_operand(_globalNames);
adlc/output_c.cpp:        const char *parameter = formal_lst->iter();
adlc/output_c.cpp:                               opid, node->_ident, new_inst->_ident);
adlc/output_c.cpp:          new_pos = new_inst->operand_position(parameter,Component::USE);
adlc/output_c.cpp:                       node->_ident, new_inst->_ident);
adlc/output_c.cpp:          new_pos = new_inst->operand_position(parameter,Component::USE);
adlc/output_c.cpp:        int new_def_pos = new_inst->operand_position(parameter,Component::DEF);
adlc/output_c.cpp:        Effect *eform = (Effect *)new_inst->_effects[parameter];
adlc/output_c.cpp:      assert( !new_inst->expands(), "Do not have complete support for recursive expansion");
adlc/output_c.cpp:            fprintf(_fp, "%s(%s_enc)", reg_convert, first->_regname);
adlc/output_c.cpp:            fprintf(_fp, "%s_enc", first->_regname);
adlc/output_c.cpp:        if ( inst->ideal_only() )  continue;
adlc/output_c.cpp:        if ( ! inst->is_simple_chain_rule(_globalNames) ) continue;
adlc/output_c.cpp:        if ( inst->rematerialize(_globalNames, get_registers()) ) continue;
adlc/output_c.cpp:        if ( inst->ideal_only() )  continue;
adlc/output_c.cpp:        if ( ! inst->is_simple_chain_rule(_globalNames) ) continue;
adlc/output_c.cpp:        if ( ! inst->rematerialize(_globalNames, get_registers()) ) continue;
adlc/output_c.cpp:        if ( inst->ideal_only() )  continue;
adlc/output_c.cpp:        if ( inst->is_simple_chain_rule(_globalNames) ) continue;
adlc/output_c.cpp:        if ( ! inst->rematerialize(_globalNames, get_registers()) ) continue;
adlc/output_c.cpp:        if ( inst->ideal_only() )  continue;
adlc/output_c.cpp:        if ( inst->is_simple_chain_rule(_globalNames) ) continue;
adlc/output_c.cpp:        if ( inst->rematerialize(_globalNames, get_registers()) ) continue;
adlc/output_c.cpp:  const char *opClass = inst->_ident;
adlc/output_c.cpp:  if ( (inst->num_post_match_opnds() != 0) ) {
adlc/output_c.cpp:    // Check if the first post-match component may be an interesting def
adlc/output_c.cpp:    ComponentList &comp_list = inst->_components;
adlc/output_c.cpp:      ComponentList clist = inst->_components;
adlc/output_c.cpp:  else if ( inst->is_chain_of_constant(_globalNames, opType) ) {
adlc/output_c.cpp:            inst->oper_input_base(_globalNames));
adlc/output_c.cpp:    const char *opName = inst->_matrule->_rChild->_opType;
adlc/output_c.cpp:  if (inst->captures_bottom_type(_globalNames)) {
adlc/output_c.cpp:    if (strncmp("MachCall", inst->mach_base_class(_globalNames), strlen("MachCall"))) {
adlc/output_c.cpp:  if( inst->is_ideal_if() ) {
adlc/output_c.cpp:  if (inst->is_ideal_halt()) {
adlc/output_c.cpp:  if (inst->is_ideal_jump()) {
adlc/output_c.cpp:  if( inst->is_ideal_fastlock() ) {
adlc/output_c.cpp:    if ( inst->_matrule == NULL ) continue;
adlc/output_c.cpp:    const char *opClass = inst->_ident;
adlc/output_c.cpp:    if ( inst->ideal_only() )  continue;
adlc/output_c.cpp:    const char *inst_name = inst->_ident;
adlc/output_c.cpp:    int   operand   = inst->cisc_spill_operand();
adlc/output_c.cpp:      InstructForm *inst2 = inst->cisc_spill_alternate();
adlc/output_c.cpp:      fprintf(fp_cpp, "//  %s can cisc-spill operand %d to %s\n", inst->_ident, operand, inst2->_ident);
adlc/forms.cpp://------------------------------NameList---------------------------------------
adlc/forms.cpp://------------------------------NameAndList------------------------------------
adlc/forms.cpp://------------------------------FormList---------------------------------------
adlc/forms.hpp://------------------------------FormList---------------------------------------
adlc/forms.hpp://------------------------------NameList---------------------------------------
adlc/forms.hpp:    _iter = _list->_iter;
adlc/forms.hpp:    _justReset = _list->_justReset;
adlc/forms.hpp:    _list->_iter = _iter;
adlc/forms.hpp:    _list->_justReset = _justReset;
adlc/forms.hpp://------------------------------NameAndList------------------------------------
adlc/forms.hpp://------------------------------ComponentList---------------------------------
adlc/formsopt.cpp:    if (first == NULL || def->register_num() < first->register_num()) {
adlc/archDesc.hpp://---------------------------ChainList-----------------------------------------
adlc/archDesc.hpp://---------------------------MatchList-----------------------------------------
adlc/arena.hpp:  ~Arena()                      { _first->chop(); }
adlc/adlparse.cpp:        if (!lst->search(instr->_matrule->_lChild->_opType)) {
adlc/adlparse.cpp:            lst->insert(instr->_matrule->_lChild->_opType,cost,instr->_ident);
adlc/adlparse.cpp:        if (!lst->search(instr->_matrule->_lChild->_opType)) {
adlc/adlparse.cpp:          lst->insert(instr->_matrule->_lChild->_opType,cost,instr->_ident);
adlc/adlparse.cpp:              // if (!lst->search(instr->_matrule->_lChild->_opType)) {
adlc/adlparse.cpp:              lst->insert(instr->_matrule->_lChild->_opType,cost,instr->_ident);
adlc/adlparse.cpp://------------------------------get_oplist-------------------------------------
adlc/adlparse.cpp://------------------------------get_effectlist---------------------------------
adlc/formssel.cpp:    fprintf(fp, "    st->print(\"%%s\", reg);\n");
adlc/formssel.cpp:    fprintf(fp, "st->print(\"#%%d\", constant_offset_unchecked());\n");
adlc/formssel.cpp:    fprintf(fp, "st->print(\"constant table base + #%%d\", constant_offset_unchecked());\n");
adlc/formssel.cpp:      fprintf(fp, "    st->print_raw(\"%s\");\n", first->_regname);
adlc/formssel.cpp:    fprintf(fp,"    st->print(\"%cs\",reg_str);\n",'%');
adlc/formssel.cpp:    fprintf(fp,"    st->print(\"%cs\",reg_str);\n",'%');
adlc/formssel.cpp:    fprintf(fp,"  st->print(\"No format defined for %s\n\");\n", _ident);
adlc/formssel.cpp:    fprintf(fp,"    st->print(\"%cs\",reg_str);\n",'%');
adlc/formssel.cpp:    fprintf(fp,"    st->print(\"%cs\",reg_str);\n",'%');
adlc/formssel.cpp:    fprintf(fp,"  st->print(\"No format defined for %s\n\");\n", _ident);
adlc/formssel.cpp:  case Form::idealI: fprintf(fp,"  st->print(\"#%%d\", _c%d);\n", const_index); break;
adlc/formssel.cpp:  case Form::idealL: fprintf(fp,"  st->print(\"#\" INT64_FORMAT, (int64_t)_c%d);\n", const_index); break;
adlc/formssel.cpp:  case Form::idealF: fprintf(fp,"  st->print(\"#%%f\", _c%d);\n", const_index); break;
adlc/formssel.cpp:  case Form::idealD: fprintf(fp,"  st->print(\"#%%f\", _c%d);\n", const_index); break;
adlc/formssel.cpp://------------------------------ComponentList---------------------------------
adlc/formssel.cpp:  // In post-match components?
adlc/formssel.cpp:// post-matching.
adlc/output_h.cpp:  fprintf(fp, "       if( _c%d == BoolTest::eq ) st->print_raw(\"%s\");\n",i,cond->_equal_format);
adlc/output_h.cpp:  fprintf(fp, "  else if( _c%d == BoolTest::ne ) st->print_raw(\"%s\");\n",i,cond->_not_equal_format);
adlc/output_h.cpp:  fprintf(fp, "  else if( _c%d == BoolTest::le ) st->print_raw(\"%s\");\n",i,cond->_less_equal_format);
adlc/output_h.cpp:  fprintf(fp, "  else if( _c%d == BoolTest::ge ) st->print_raw(\"%s\");\n",i,cond->_greater_equal_format);
adlc/output_h.cpp:  fprintf(fp, "  else if( _c%d == BoolTest::lt ) st->print_raw(\"%s\");\n",i,cond->_less_format);
adlc/output_h.cpp:  fprintf(fp, "  else if( _c%d == BoolTest::gt ) st->print_raw(\"%s\");\n",i,cond->_greater_format);
adlc/output_h.cpp:  fprintf(fp, "  else if( _c%d == BoolTest::overflow ) st->print_raw(\"%s\");\n",i,cond->_overflow_format);
adlc/output_h.cpp:  fprintf(fp, "  else if( _c%d == BoolTest::no_overflow ) st->print_raw(\"%s\");\n",i,cond->_no_overflow_format);
adlc/output_h.cpp:    fprintf(fp,"   st->print(\"#%%d\", _c%d);\n", i);
adlc/output_h.cpp:    fprintf(fp,"   st->print(\"/0x%%08x\", _c%d);\n", i);
adlc/output_h.cpp:    fprintf(fp,"    st->print(\"#\" INT64_FORMAT, (int64_t)_c%d);\n", i);
adlc/output_h.cpp:    fprintf(fp,"    st->print(\"/\" PTR64_FORMAT, (uint64_t)_c%d);\n", i);
adlc/output_h.cpp:    fprintf(fp,"    st->print(\"#%%f\", _c%d);\n", i);
adlc/output_h.cpp:    fprintf(fp,"    st->print(\"/0x%%x/\", _c%di);\n", i);
adlc/output_h.cpp:    fprintf(fp,"    st->print(\"#%%f\", _c%d);\n", i);
adlc/output_h.cpp:    fprintf(fp,"    st->print(\"/\" PTR64_FORMAT, (uint64_t)_c%dl);\n", i);
adlc/output_h.cpp:          // Pass through to st->print
adlc/output_h.cpp:          fprintf(fp,"  st->print_raw(\"%s\");\n", string);
adlc/output_h.cpp:      fprintf(fp, "  st->print(\"$$univ\");\n");
adlc/output_h.cpp:          // Pass through to st->print
adlc/output_h.cpp:          fprintf(fp,"  st->print_raw(\"%s\");\n", string);
adlc/output_h.cpp:      fprintf(fp, "  st->print(\"$$univ\");\n");
adlc/output_h.cpp:        fprintf(fp,"st->print_raw(\"%s\");\n", string);
adlc/output_h.cpp:      fprintf(fp,"  else st->print(\" wrapper for: %%s\", _name);\n");
adlc/output_h.cpp:      fprintf(fp,"  st->print(\" %%s\", _name);");
adlc/output_h.cpp:    fprintf(fp,  "  st->cr();\n" );
adlc/output_h.cpp:    fprintf(fp,  "  if (_jvms) _jvms->format(ra, this, st); else st->print_cr(\"        No JVM State Info\");\n" );
adlc/output_h.cpp:    fprintf(fp,  "  st->print(\"        # \");\n" );
adlc/output_h.cpp:    fprintf(fp,  "  st->print_raw(\"\");\n" );
adlc/output_h.cpp:    fprintf(fp,  "  if (_jvms) _jvms->format(ra, this, st); else st->print_cr(\"        No JVM State Info\");\n" );
adlc/output_h.cpp:    fprintf(fp,  "  st->print(\"        # \");\n" );
adlc/output_h.cpp:    fprintf(fp,  "  st->print(\"  P=%%f C=%%f\",_prob,_fcnt);\n" );
adlc/output_h.cpp:    fprintf(fp,  "    st->print(\" %s Field: \");\n", commentSeperator);
adlc/output_h.cpp:    fprintf(fp,  "      st->print(\"volatile \");\n");
adlc/output_h.cpp:    fprintf(fp,  "    st->print(\".\");\n");
adlc/output_h.cpp:    fprintf(fp,  "      st->print(\" (constant)\");\n");
adlc/output_h.cpp:    fprintf(fp,  "      st->print(\" volatile!\");\n");
adlc/output_h.cpp:    // (2)    st->print("#%d", _c#);        // Constant != ConP
adlc/output_h.cpp:      // generate format string for st->print
aot/aotCompiledMethod.cpp:    st->print("%7d ", (int) tty->time_stamp().milliseconds());
aot/aotCompiledMethod.cpp:    st->print("%4d ", _aot_id);    // print compilation number
aot/aotCompiledMethod.cpp:    st->print("    aot[%2d]", _heap->dso_id());
aot/aotCompiledMethod.cpp:      st->print("   %s", _name);
aot/aotCompiledMethod.cpp:      st->print("   %s", _method->name_and_sig_as_C_string());
aot/aotCompiledMethod.cpp:      st->print(" entry at " INTPTR_FORMAT, p2i(_code));
aot/aotCompiledMethod.cpp:      st->print("   %s", msg);
aot/aotCompiledMethod.cpp:    st->cr();
aot/aotCompiledMethod.cpp:  st->print("AOTCompiledMethod ");
aot/compiledIC_aot.hpp:    st->verify();
aot/compiledIC_aot.hpp:    st->verify();
asm/codeBuffer.cpp:  address buf = dest->_total_start;
asm/codeBuffer.cpp:  assert(dest->_total_size >= total_content_size(), "must be big enough");
asm/codeBuffer.cpp:    assert( (dest->_total_start - _insts.start()) % alignSize == 0, "copy must preserve alignment");
asm/codeBuffer.cpp:    CodeSection* dest_cs = dest->code_section(n);
asm/codeBuffer.cpp:  dest->verify_section_allocation();
asm/codeBuffer.cpp:    buf = (address)dest->relocation_begin();
asm/codeBuffer.cpp:    buf_limit = (address)dest->relocation_end() - buf;
asm/codeBuffer.cpp:  address dest_end = dest->_total_start + dest->_total_size;
asm/codeBuffer.cpp:    CodeSection* dest_cs = dest->code_section(n);
asm/codeBuffer.cpp:    if (dest->blob() == NULL) {
asm/codeBuffer.cpp:    CodeSection* dest_cs = dest->code_section(n);
asm/codeBuffer.cpp:  if (dest->blob() == NULL && dest_filled != NULL) {
c1/c1_Optimizer.cpp:    t_value = new Constant(t_const->type());
c1/c1_Optimizer.cpp:    f_value = new Constant(f_const->type());
c1/c1_Optimizer.cpp:        Constant::CompareResult t_compare_res = x_tval_const->compare(cond, y_const);
c1/c1_Optimizer.cpp:        Constant::CompareResult f_compare_res = x_fval_const->compare(cond, y_const);
c1/c1_Optimizer.cpp:        Constant::CompareResult x_compare_res = x_const->compare(cond, y_const);
c1/c1_Optimizer.cpp:  // last-traversed NullCheck when we reach a potentially-exception-
c1/c1_LinearScan.hpp:  int              from() const                  { return _first->from(); }
c1/c1_LinearScan.hpp:  bool   intersects(Interval* i) const           { return _first->intersects(i->_first); }
c1/c1_LinearScan.hpp:  int    intersects_at(Interval* i) const        { return _first->intersects_at(i->_first); }
c1/c1_GraphBuilder.cpp:  const int n = list->length();
c1/c1_GraphBuilder.cpp:    XHandler* h = list->handler_at(i);
c1/c1_GraphBuilder.cpp:  const int n = list->length();
c1/c1_GraphBuilder.cpp:    XHandler* h = list->handler_at(i);
c1/c1_GraphBuilder.cpp:  // reverse-post-order numbering of all blocks
c1/c1_GraphBuilder.cpp:    Value object = st->obj();
c1/c1_GraphBuilder.cpp:    Value value = st->value();
c1/c1_GraphBuilder.cpp:    ciField* field = st->field();
c1/c1_GraphBuilder.cpp:            st->print_line();
c1/c1_GraphBuilder.cpp:    _work_list->push(block);
c1/c1_GraphBuilder.cpp:  assert(worklist->top() == top, "");
c1/c1_GraphBuilder.cpp:  int i = worklist->length()-2;
c1/c1_GraphBuilder.cpp:    BlockBegin* b = worklist->at(i);
c1/c1_GraphBuilder.cpp:      worklist->at_put(i+1, b);
c1/c1_GraphBuilder.cpp:  if (i >= -1) worklist->at_put(i + 1, top);
c1/c1_GraphBuilder.cpp:  return _work_list->pop();
c1/c1_GraphBuilder.cpp:  return (_work_list == NULL || _work_list->length() == 0);
c1/c1_GraphBuilder.cpp:  _last = _last->set_next(i1, canon.bci());
c1/c1_GraphBuilder.cpp:    const int n = list->length();
c1/c1_GraphBuilder.cpp:      XHandler* h = list->handler_at(i);
c1/c1_GraphBuilder.cpp:      tty->print_cr("simplified phi function %c%d to %c%d (Block B%d)", phi->type()->tchar(), phi->id(), subst->type()->tchar(), subst->id(), phi->block()->block_id());
c1/c1_GraphBuilder.cpp:    assert(_last && _last->as_BlockEnd(), "");
c1/c1_GraphBuilder.cpp:    return _last->as_BlockEnd();
c1/c1_GraphBuilder.cpp:  assert(_last && _last->as_BlockEnd(), "block must have end");
c1/c1_GraphBuilder.cpp:  assert(_last->as_MonitorEnter() != NULL, "monitor enter expected");
c1/c1_GraphBuilder.cpp:  _last->set_needs_null_check(false);
c1/c1_GraphBuilder.cpp:    assert(_last && _last->as_BlockEnd(), "");
c1/c1_GraphBuilder.cpp:      assert(_last && _last->as_BlockEnd(), "");
c1/c1_Compilation.cpp:  if (info_list->length() == 0) {
c1/c1_Compilation.cpp:  for (int i = 0; i < info_list->length(); i++) {
c1/c1_Compilation.cpp:    ExceptionInfo* info = info_list->at(i);
c1/c1_Compilation.cpp:  st->print("CompileOnly=");
c1/c1_Compilation.cpp:  st->print(".");
c1/c1_Compilation.cpp:  st->cr();
c1/c1_RangeCheckElimination.cpp:  aii->_list->append(ai);
c1/c1_RangeCheckElimination.cpp:        if (info->_list->length() > 2 && range_cond) {
c1/c1_RangeCheckElimination.cpp:          AccessIndexed *first = info->_list->at(0);
c1/c1_RangeCheckElimination.cpp:          Instruction *insert_position = first->prev();
c1/c1_RangeCheckElimination.cpp:          ValueStack *state = first->state_before();
c1/c1_RangeCheckElimination.cpp:            NOT_PRODUCT(min_constant->set_printable_bci(first->printable_bci()));
c1/c1_RangeCheckElimination.cpp:            NOT_PRODUCT(max_constant->set_printable_bci(first->printable_bci()));
c1/c1_RangeCheckElimination.cpp:          Value length_instr = first->length();
c1/c1_RangeCheckElimination.cpp:            ArrayLength *length = new ArrayLength(array, first->state_before()->copy());
c1/c1_RangeCheckElimination.cpp:          int bci = NOT_PRODUCT(first->printable_bci()) PRODUCT_ONLY(-1);
c1/c1_RangeCheckElimination.cpp:          for (int j = 0; j<info->_list->length(); j++) {
c1/c1_RangeCheckElimination.cpp:            AccessIndexed *ai = info->_list->at(j);
c1/c1_RangeCheckElimination.cpp:        Instruction *insert_position = first->prev();
c1/c1_RangeCheckElimination.cpp:        ValueStack *state = first->state_before();
c1/c1_RangeCheckElimination.cpp:        NOT_PRODUCT(constant->set_printable_bci(first->printable_bci()));
c1/c1_RangeCheckElimination.cpp:        Value length_instr = first->length();
c1/c1_LIRAssembler.cpp:  for (int m = 0; m < stub_list->length(); m++) {
c1/c1_LIRAssembler.cpp:    CodeStub* s = stub_list->at(m);
c1/c1_LIRAssembler.cpp:  for (int i = 0; i < info_list->length(); i++) {
c1/c1_LIRAssembler.cpp:    XHandlers* handlers = info_list->at(i)->exception_handlers();
c1/c1_LIRAssembler.cpp:  int n = list->length();
c1/c1_LIRAssembler.cpp:    LIR_Op* op = list->at(i);
c1/c1_LIRAssembler.cpp:      list->at(i)->print(); tty->cr();
c1/c1_LIRAssembler.cpp:  assert((src->is_single_fpu() && dest->is_single_stack()) ||
c1/c1_LIRAssembler.cpp:         (src->is_double_fpu() && dest->is_double_stack()),
c1/c1_LIRAssembler.cpp:    if (dest->is_register()) {
c1/c1_LIRAssembler.cpp:    } else if (dest->is_stack()) {
c1/c1_LIRAssembler.cpp:    } else if (dest->is_address()) {
c1/c1_LIRAssembler.cpp:    if (dest->is_register()) {
c1/c1_LIRAssembler.cpp:    } else if (dest->is_stack()) {
c1/c1_LIRAssembler.cpp:    if (dest->is_register()) {
c1/c1_LIRAssembler.cpp:    } else if (dest->is_stack()) {
c1/c1_LIRAssembler.cpp:    } else if (dest->is_address()) {
c1/c1_LIR.cpp:      assert(opArrayCopy->_dst->is_valid(), "used");          do_input(opArrayCopy->_dst);     do_temp(opArrayCopy->_dst);
c1/c1_LIRGenerator.cpp:  assert(dest->is_valid(), "");
c1/c1_LIRGenerator.cpp:  if (!dest->visited()) {
c1/c1_LIRGenerator.cpp:    dest->set_visited();
c1/c1_LIRGenerator.cpp:    for (int i = dest->no_of_destinations()-1; i >= 0; i --) {
c1/c1_LIRGenerator.cpp:      move(dest, dest->destination_at(i));
c1/c1_LIRGenerator.cpp:  } else if (!dest->start_node()) {
c1/c1_LIRGenerator.cpp:  if (!dest->assigned()) {
c1/c1_LIRGenerator.cpp:      move_temp_to(dest->operand());
c1/c1_LIRGenerator.cpp:      dest->set_assigned();
c1/c1_LIRGenerator.cpp:      emit_move(src->operand(), dest->operand());
c1/c1_LIRGenerator.cpp:      dest->set_assigned();
c1/c1_LIRGenerator.cpp:  assert(dest->is_virtual(), "");
c1/c1_LIRGenerator.cpp:  // tty->print("move "); src->print(); tty->print(" to "); dest->print(); tty->cr();
c1/c1_LIRGenerator.cpp:  assert(dest->is_valid(), "");
c1/c1_LIRGenerator.cpp:  IntConstant* c = inst->type()->as_IntConstant();
c1/c1_LIRGenerator.cpp:  IntConstant* c = inst->type()->as_IntConstant();
c1/c1_LIRGenerator.cpp:    ciArrayKlass* dst_exact_type    = as_array_klass(dst->exact_type());
c1/c1_LIRGenerator.cpp:    ciArrayKlass* dst_declared_type = as_array_klass(dst->declared_type());
c1/c1_LIRGenerator.cpp:    if (dst_declared_type == NULL && (phi = dst->as_Phi()) != NULL) {
c1/c1_LIRGenerator.cpp:    NewArray* dst_array = dst->as_NewArray();
c1/c1_LIRGenerator.cpp:    _instruction_for_operand.at_put_grow(dest->vreg_number(), local, NULL);
c1/c1_LIRGenerator.cpp:  assert(args->length() == arg_list->length(),
c1/c1_LIRGenerator.cpp:         "args=%d, arg_list=%d", args->length(), arg_list->length());
c1/c1_LIRGenerator.cpp:    LIR_Opr loc = arg_list->at(i);
c1/c1_LIRGenerator.cpp:    LIR_Opr loc = arg_list->at(0);
c1/c1_Canonicalizer.cpp:      set_constant(cnst->value()->length());
c1/c1_Canonicalizer.cpp:      if (is_inst_sux == no_inst_sux && inst->is_loaded()) {
c1/c1_Canonicalizer.cpp:        set_canonical(new IfInstanceOf(inst->klass(), inst->obj(), true, inst->state_before()->bci(), is_inst_sux, no_inst_sux));
c1/c1_IR.cpp:      worklist->push(*n);
c1/c1_IR.cpp:    while (worklist->length() > 0) {
c1/c1_IR.cpp:      Value t = worklist->pop();
c1/c1_IR.cpp:      last->set_next(n->next());
c1/c1_IR.cpp:    n = last->next();
c1/c1_Instruction.hpp:  Instruction* subst()                           { return _subst == NULL ? this : _subst->subst(); }
c1/c1_Instruction.hpp:           type()->base() == subst->type()->base() ||
c1/c1_Instruction.hpp:           subst->type()->base() == illegalType, "type can't change");
c1/c1_LIR.hpp://--------------------------------LIR_List---------------------------------------------------
c1/c1_LIR.hpp:  void insert_before(int i, LIR_List* op_list)   { _operations.insert_before(i, op_list->instructions_list()); }
c1/c1_LIR.hpp:  void unaligned_move(LIR_Address* src, LIR_Opr dst) { append(new LIR_Op1(lir_move, LIR_OprFact::address(src), dst, dst->type(), lir_patch_none, NULL, lir_move_unaligned)); }
c1/c1_LIR.hpp:  void unaligned_move(LIR_Opr src, LIR_Opr dst) { append(new LIR_Op1(lir_move, src, dst, dst->type(), lir_patch_none, NULL, lir_move_unaligned)); }
c1/c1_LIR.hpp:  void move(LIR_Opr src, LIR_Opr dst, CodeEmitInfo* info = NULL) { append(new LIR_Op1(lir_move, src, dst, dst->type(), lir_patch_none, info)); }
c1/c1_LIR.hpp:  void move(LIR_Opr src, LIR_Address* dst, CodeEmitInfo* info = NULL) { append(new LIR_Op1(lir_move, src, LIR_OprFact::address(dst), dst->type(), lir_patch_none, info)); }
c1/c1_LIR.hpp:      append(new LIR_Op1(lir_move, src, LIR_OprFact::address(dst), dst->type(), lir_patch_none, info, lir_move_wide));
c1/c1_LIR.hpp:  void move(int index, LIR_Opr src, LIR_Opr dst, CodeEmitInfo* info = NULL) { append(index, new LIR_Op1(lir_move, src, dst, dst->type(), lir_patch_none, info)); }
c1/c1_ValueMap.cpp:    assert(!subst->has_subst(), "can't have a substitution");
c1/c1_ValueMap.cpp:    TRACE_VALUE_NUMBERING(tty->print_cr("substitution for %d set to %d", instr->id(), subst->id()));
c1/c1_LinearScan.cpp:  int unsorted_len = unsorted_list->length();
c1/c1_LinearScan.cpp:    if (unsorted_list->at(unsorted_idx) != NULL) {
c1/c1_LinearScan.cpp:    Interval* cur_interval = unsorted_list->at(unsorted_idx);
c1/c1_LinearScan.cpp:        sorted_list->at_put(sorted_idx++, cur_interval);
c1/c1_LinearScan.cpp:        for (j = sorted_idx - 1; j >= 0 && cur_from < sorted_list->at(j)->from(); j--) {
c1/c1_LinearScan.cpp:          sorted_list->at_put(j + 1, sorted_list->at(j));
c1/c1_LinearScan.cpp:        sorted_list->at_put(j + 1, cur_interval);
c1/c1_LinearScan.cpp:  int old_len = old_list->length();
c1/c1_LinearScan.cpp:  int new_len = new_list == NULL ? 0 : new_list->length();
c1/c1_LinearScan.cpp:  new_list->sort(interval_cmp);
c1/c1_LinearScan.cpp:    if (new_idx >= new_len || (old_idx < old_len && old_list->at(old_idx)->from() <= new_list->at(new_idx)->from())) {
c1/c1_LinearScan.cpp:      combined_list->at_put(old_idx + new_idx, old_list->at(old_idx));
c1/c1_LinearScan.cpp:      combined_list->at_put(old_idx + new_idx, new_list->at(new_idx));
c1/c1_LinearScan.cpp:        VMReg rname_second = rname_first->next();
c1/c1_LinearScan.cpp:        VMReg rname_second = rname_first->next();
c1/c1_LinearScan.cpp:          (!dst->is_pointer() && !src->is_pointer() &&
c1/c1_LinearScan.cpp:  TRACE_LINEAR_SCAN(4, tty->print_cr("MoveResolver: resolving mappings for Block B%d, index %d", _insert_list->block() != NULL ? _insert_list->block()->block_id() : -1, _insert_idx));
c1/c1_LinearScan.cpp:  TRACE_LINEAR_SCAN(4, tty->print_cr("MoveResolver: setting insert position to Block B%d, index %d", insert_list->block() != NULL ? insert_list->block()->block_id() : -1, insert_idx));
c1/c1_LinearScan.cpp:  TRACE_LINEAR_SCAN(4, tty->print_cr("MoveResolver: moving insert position to Block B%d, index %d", insert_list->block() != NULL ? insert_list->block()->block_id() : -1, insert_idx));
c1/c1_LinearScan.cpp:  assert(split_pos > _first->from() && split_pos <= _first->to(), "can only split inside first range");
c1/c1_LinearScan.cpp:  result->add_range(_first->from(), split_pos);
c1/c1_LinearScan.cpp:  if (split_pos == _first->to()) {
c1/c1_LinearScan.cpp:    assert(_first->next() != Range::end(), "must not be at end");
c1/c1_LinearScan.cpp:    _first = _first->next();
c1/c1_LinearScan.cpp:    _first->set_from(split_pos);
c1/c1_LinearScan.cpp:    assert(list->assigned_reg() < LinearScan::nof_regs, "active interval must have a register assigned");
c1/c1_LinearScan.cpp:    list = list->next();
c1/c1_LinearScan.cpp:    list = list->next();
c1/c1_LinearScan.cpp:    if (cur->to() <= list->current_from()) {
c1/c1_LinearScan.cpp:      assert(list->current_intersects_at(cur) == -1, "must not intersect");
c1/c1_LinearScan.cpp:      set_use_pos(list, list->current_from(), true);
c1/c1_LinearScan.cpp:      set_use_pos(list, list->current_intersects_at(cur), true);
c1/c1_LinearScan.cpp:    list = list->next();
c1/c1_LinearScan.cpp:    set_use_pos(list, list->current_intersects_at(cur), true);
c1/c1_LinearScan.cpp:    list = list->next();
c1/c1_LinearScan.cpp:    list = list->next();
c1/c1_LinearScan.cpp:    if (cur->to() > list->current_from()) {
c1/c1_LinearScan.cpp:      set_block_pos(list, list->current_intersects_at(cur));
c1/c1_LinearScan.cpp:      assert(list->current_intersects_at(cur) == -1, "invalid optimization: intervals intersect");
c1/c1_LinearScan.cpp:    list = list->next();
c1/c1_LinearScan.cpp:    set_use_pos(list, MIN2(list->next_usage(loopEndMarker, _current_position), list->to()), false);
c1/c1_LinearScan.cpp:    list = list->next();
c1/c1_LinearScan.cpp:    if (list->current_intersects(cur)) {
c1/c1_LinearScan.cpp:      set_use_pos(list, MIN2(list->next_usage(loopEndMarker, _current_position), list->to()), false);
c1/c1_LinearScan.cpp:    list = list->next();
c1/c1_LinearScan.cpp:  int index = (op_id - list->at(0)->id()) / 2;
c1/c1_LinearScan.cpp:  assert(list->at(index)->id() <= op_id, "error in calculation");
c1/c1_LinearScan.cpp:  while (list->at(index)->id() != op_id) {
c1/c1_LinearScan.cpp:    assert(0 <= index && index < list->length(), "index out of bounds");
c1/c1_LinearScan.cpp:  assert(1 <= index && index < list->length(), "index out of bounds");
c1/c1_LinearScan.cpp:  assert(list->at(index)->id() == op_id, "error in calculation");
ci/ciSymbol.cpp:  st->print(" value=");
ci/ciNullObject.cpp:  st->print(" unique");
ci/ciFlags.cpp:    st->print("public");
ci/ciFlags.cpp:    st->print("DEFAULT_ACCESS");
ci/ciFlags.cpp:    st->print(",final");
ci/ciFlags.cpp:    st->print(",super");
ci/ciFlags.cpp:    st->print(",interface");
ci/ciFlags.cpp:    st->print(",abstract");
ci/ciFlags.cpp:    st->print("public");
ci/ciFlags.cpp:    st->print("private");
ci/ciFlags.cpp:    st->print("protected");
ci/ciFlags.cpp:    st->print("DEFAULT_ACCESS");
ci/ciFlags.cpp:    st->print(",static");
ci/ciFlags.cpp:    st->print(",final");
ci/ciFlags.cpp:    st->print(",synchronized");
ci/ciFlags.cpp:    st->print(",volatile");
ci/ciFlags.cpp:    st->print(",transient");
ci/ciFlags.cpp:    st->print(",native");
ci/ciFlags.cpp:    st->print(",abstract");
ci/ciFlags.cpp:    st->print(",strict");
ci/ciFlags.cpp:  st->print(" flags=%x", _flags);
ci/ciObject.cpp:  st->print("<%s", type_string());
ci/ciObject.cpp:  st->print(" ident=%d address=" INTPTR_FORMAT ">", ident(), p2i(this));
ci/ciObject.cpp:    st->print_cr("NULL");
ci/ciObject.cpp:    st->print_cr("UNLOADED");
ci/bcEscapeAnalyzer.cpp:  StateInfo *d_state = blockstates + dest->index();
ci/bcEscapeAnalyzer.cpp:  if (dest->is_handler())
ci/bcEscapeAnalyzer.cpp:  } else if (!dest->processed()) {
ci/ciMethodBlocks.cpp:  st->print_cr("--------------------------------------------------------");
ci/ciMethodBlocks.cpp:  st->print   ("ciBlock [%d - %d) control : ", start_bci(), limit_bci());
ci/ciMethodBlocks.cpp:    st->print_cr("%d:fall through", limit_bci());
ci/ciMethodBlocks.cpp:    st->print_cr("%d:%s", control_bci(),
ci/ciTypeFlow.hpp:      st->print("%d->%d", entry_address(), return_address());
ci/ciTypeFlow.hpp:    // A post-order, used to compute the reverse post order (RPO) provided to the client
ci/ciMethod.cpp:  st->print("%s %s %s",
ci/ciMethod.cpp:  st->print("ciMethod ");
ci/ciMethod.cpp:  st->print_cr(" %d %d %d %d %d",
ci/ciMethod.cpp:    st->print("::");
ci/ciMethod.cpp:  st->print(" name=");
ci/ciMethod.cpp:  st->print(" holder=");
ci/ciMethod.cpp:  st->print(" signature=");
ci/ciMethod.cpp:    st->print(" loaded=true");
ci/ciMethod.cpp:    st->print(" arg_size=%d", arg_size());
ci/ciMethod.cpp:    st->print(" flags=");
ci/ciMethod.cpp:    st->print(" loaded=false");
ci/ciInstanceKlass.cpp:  GUARDED_VM_ENTRY(st->print(" loader=" INTPTR_FORMAT, p2i(loader()));)
ci/ciInstanceKlass.cpp:    st->print(" loaded=true initialized=%s finalized=%s subklass=%s size=%d flags=",
ci/ciInstanceKlass.cpp:      st->print(" super=");
ci/ciInstanceKlass.cpp:      st->print(" mirror=PRESENT");
ci/ciInstanceKlass.cpp:    st->print(" loaded=false");
ci/ciInstance.cpp:  st->print(" type=");
ci/ciType.cpp:  st->print(" type=");
ci/ciType.cpp:  st->print("%s", name());
ci/ciType.cpp:  st->print(" bci=%d", _bci);
ci/ciArray.cpp:  st->print(" length=%d type=", length());
ci/ciTypeFlow.cpp:  st->print("{ ");
ci/ciTypeFlow.cpp:      st->print(", ");
ci/ciTypeFlow.cpp:    st->print(" ");
ci/ciTypeFlow.cpp:  st->print("}");
ci/ciTypeFlow.cpp:    st->print("top");
ci/ciTypeFlow.cpp:    st->print("bottom");
ci/ciTypeFlow.cpp:    st->print("null");
ci/ciTypeFlow.cpp:    st->print("long2");
ci/ciTypeFlow.cpp:    st->print("double2");
ci/ciTypeFlow.cpp:    st->print("int");
ci/ciTypeFlow.cpp:    st->print("long");
ci/ciTypeFlow.cpp:    st->print("float");
ci/ciTypeFlow.cpp:    st->print("double");
ci/ciTypeFlow.cpp:    st->print("address(%d)", type->as_return_address()->bci());
ci/ciTypeFlow.cpp:      st->print("UNEXPECTED TYPE");
ci/ciTypeFlow.cpp:  st->print_cr("  State : locals %d, stack %d, monitors %d", num_locals, num_stack, num_monitors);
ci/ciTypeFlow.cpp:      st->print("    local %2d : ", i);
ci/ciTypeFlow.cpp:      st->cr();
ci/ciTypeFlow.cpp:      st->print("    stack %2d : ", i);
ci/ciTypeFlow.cpp:      st->cr();
ci/ciTypeFlow.cpp:  if (has_pre_order()) st->print("#%-2d ", pre_order());
ci/ciTypeFlow.cpp:  if (has_rpo())       st->print("rpo#%-2d ", rpo());
ci/ciTypeFlow.cpp:  st->print("[%d - %d)", start(), limit());
ci/ciTypeFlow.cpp:  if (is_loop_head()) st->print(" lphd");
ci/ciTypeFlow.cpp:  if (is_irreducible_entry()) st->print(" irred");
ci/ciTypeFlow.cpp:  if (_jsrs->size() > 0) { st->print("/");  _jsrs->print_on(st); }
ci/ciTypeFlow.cpp:  if (is_backedge_copy())  st->print("/backedge_copy");
ci/ciTypeFlow.cpp:  st->print_cr("  ====================================================  ");
ci/ciTypeFlow.cpp:  st->print ("  ");
ci/ciTypeFlow.cpp:  st->print(" Stored locals: "); def_locals()->print_on(st, outer()->method()->max_locals()); tty->cr();
ci/ciTypeFlow.cpp:    st->print(" loops:");
ci/ciTypeFlow.cpp:      st->print(" %d<-%d", lp->head()->pre_order(),lp->tail()->pre_order());
ci/ciTypeFlow.cpp:      if (lp->is_irreducible()) st->print("(ir)");
ci/ciTypeFlow.cpp:  st->cr();
ci/ciTypeFlow.cpp:    st->print_cr("  No successor information");
ci/ciTypeFlow.cpp:    st->print_cr("  Successors : %d", num_successors);
ci/ciTypeFlow.cpp:      st->print("    ");
ci/ciTypeFlow.cpp:      st->cr();
ci/ciTypeFlow.cpp:    st->print_cr("  No predecessor information");
ci/ciTypeFlow.cpp:    st->print_cr("  Predecessors : %d", num_predecessors);
ci/ciTypeFlow.cpp:      st->print("    ");
ci/ciTypeFlow.cpp:      st->cr();
ci/ciTypeFlow.cpp:    st->print_cr("  No exception information");
ci/ciTypeFlow.cpp:    st->print_cr("  Exceptions : %d", num_exceptions);
ci/ciTypeFlow.cpp:      st->print("    ");
ci/ciTypeFlow.cpp:      st->print(" -- ");
ci/ciTypeFlow.cpp:      st->cr();
ci/ciTypeFlow.cpp:    st->print_cr("  Traps on %d with trap index %d", trap_bci(), trap_index());
ci/ciTypeFlow.cpp:  st->print_cr("  ====================================================  ");
ci/ciTypeFlow.cpp:  st->print("{");
ci/ciTypeFlow.cpp:    if (test(i)) st->print(" %d", i);
ci/ciTypeFlow.cpp:    st->print(" %d..%d ", max, limit);
ci/ciTypeFlow.cpp:  st->print(" }");
ci/ciTypeFlow.cpp:    // has already been post-visited, then this is another entry into the loop.
ci/ciTypeFlow.cpp:    innermost = innermost == NULL ? lp : innermost->sorted_merge(lp);
ci/ciTypeFlow.cpp:  } else if (innermost->head() == blk) {
ci/ciTypeFlow.cpp:      assert(blk->loop()->head() == innermost->head(), "same head");
ci/ciTypeFlow.cpp:    innermost->def_locals()->add(blk->def_locals());
ci/ciTypeFlow.cpp:    innermost->def_locals()->add(blk->def_locals());
ci/ciTypeFlow.cpp:  for (int i = 0; i < indent; i++) st->print(" ");
ci/ciTypeFlow.cpp:  st->print("%d<-%d %s",
ci/ciTypeFlow.cpp:  st->print(" defs: ");
ci/ciTypeFlow.cpp:  st->cr();
ci/ciTypeFlow.cpp:      stk.pop(); // Remove post-visited node from stack
ci/ciTypeFlow.cpp:// Create the block map, which indexes blocks in reverse post-order.
ci/ciTypeFlow.cpp:  st->print_cr("********************************************************");
ci/ciTypeFlow.cpp:  st->print   ("TypeFlow for ");
ci/ciTypeFlow.cpp:  st->print_cr("  %d bytes", limit_bci);
ci/ciTypeFlow.cpp:        st->print_cr("  No Blocks");
ci/ciTypeFlow.cpp:      st->print_cr("--------------------------------------------------------");
ci/ciTypeFlow.cpp:      st->cr();
ci/ciTypeFlow.cpp:  st->print_cr("********************************************************");
ci/ciTypeFlow.cpp:  st->cr();
ci/ciTypeFlow.cpp:  st->print_cr("********************************************************");
ci/ciTypeFlow.cpp:  st->print   ("TypeFlow for ");
ci/ciTypeFlow.cpp:  st->print_cr("  %d bytes", limit_bci);
ci/ciTypeFlow.cpp:    st->print_cr("--------------------------------------------------------");
ci/ciTypeFlow.cpp:    st->cr();
ci/ciTypeFlow.cpp:  st->print_cr("********************************************************");
ci/ciTypeFlow.cpp:  st->cr();
ci/ciMetadata.cpp:  st->print("<%s", type_string());
ci/ciMetadata.cpp:  st->print(" ident=%d address=" INTPTR_FORMAT ">", ident(), p2i((address)this));
ci/ciMetadata.cpp:    st->print_cr("UNLOADED");
ci/ciMethodData.cpp:    st->print("%d", dp_to_di(data->dp()));
ci/ciMethodData.cpp:    st->fill_to(6);
ci/ciMethodData.cpp:  st->print_cr("--- Extra data:");
ci/ciMethodData.cpp:    st->print("%d", dp_to_di(data->dp()));
ci/ciMethodData.cpp:    st->fill_to(6);
ci/ciMethodData.cpp:    st->print("none");
ci/ciMethodData.cpp:    st->print("unknown");
ci/ciMethodData.cpp:    st->print(" (null seen)");
ci/ciMethodData.cpp:    st->print("%d: stack (%u) ", i, stack_slot(i));
ci/ciMethodData.cpp:    st->cr();
ci/ciMethodData.cpp:  st->print("ret ");
ci/ciMethodData.cpp:  st->cr();
ci/ciMethodData.cpp:    st->print_cr("argument types");
ci/ciMethodData.cpp:    st->print_cr("return type");
ci/ciMethodData.cpp:  st->print_cr("count(%u) entries(%u)", count(), entries);
ci/ciMethodData.cpp:      st->print_cr("(%u)", receiver_count(row));
ci/ciMethodData.cpp:    st->print("argument types");
ci/ciMethodData.cpp:    st->print("return type");
ci/ciMethodData.cpp:  st->print_cr("ciParametersTypeData");
ci/ciMethodData.cpp:  st->print_cr("ciSpeculativeTrapData");
ci/ciMethodData.cpp:  st->cr();
ci/ciKlass.cpp:  st->print(" name=");
classfile/moduleEntry.cpp:  int list_length = list->length();
classfile/moduleEntry.cpp:    Klass* k = list->at(i);
classfile/moduleEntry.cpp:  st->print_cr("Module Entry Table (table_size=%d, entries=%d)",
classfile/moduleEntry.cpp:  st->print_cr("entry " PTR_FORMAT " name %s module " PTR_FORMAT " loader %s version %s location %s strict %s next " PTR_FORMAT,
classfile/classLoaderData.cpp:    _deallocate_list->append_if_missing(m);
classfile/classLoaderData.cpp:  for (int i = _deallocate_list->length() - 1; i >= 0; i--) {
classfile/classLoaderData.cpp:    Metadata* m = _deallocate_list->at(i);
classfile/classLoaderData.cpp:      _deallocate_list->remove_at(i);
classfile/classLoaderData.cpp:  for (int i = _deallocate_list->length() - 1; i >= 0; i--) {
classfile/classLoaderData.cpp:    Metadata* m = _deallocate_list->at(i);
classfile/classLoaderData.cpp:    _deallocate_list->remove_at(i);
classfile/modules.cpp:    pkg_list->append(pkg_symbol);
classfile/modules.cpp:  assert(pkg_list->length() == 0 || package_table != NULL, "Bad package_table");
classfile/modules.cpp:      for (int x = 0; x < pkg_list->length(); x++) {
classfile/modules.cpp:        package_table->locked_create_entry_if_not_exist(pkg_list->at(x),
classfile/modules.cpp:        assert(package_table->locked_lookup_only(pkg_list->at(x)) != NULL,
classfile/modules.cpp:        pkg_list->at(x)->decrement_refcount();
classfile/modules.cpp:                    pkg_list->length());
classfile/modules.cpp:    for (int x = 0; x < pkg_list->length(); x++) {
classfile/modules.cpp:                        (pkg_list->at(x))->as_C_string());
classfile/modules.cpp:    pkg_list->append(pkg_symbol);
classfile/modules.cpp:      for (int x = 0; x < pkg_list->length(); x++) {
classfile/modules.cpp:        existing_pkg = package_table->locked_lookup_only(pkg_list->at(x));
classfile/modules.cpp:        assert(pkg_list->length() == 0 || package_table != NULL, "Bad package table");
classfile/modules.cpp:        for (int y = 0; y < pkg_list->length(); y++) {
classfile/modules.cpp:          package_table->locked_create_entry(pkg_list->at(y), module_entry);
classfile/modules.cpp:          pkg_list->at(y)->decrement_refcount();
classfile/modules.cpp:    ls.print_cr(", package #: %d", pkg_list->length());
classfile/modules.cpp:    for (int y = 0; y < pkg_list->length(); y++) {
classfile/modules.cpp:                        (pkg_list->at(y))->as_C_string(), module_name);
classfile/placeholders.cpp:    st->print(", loader ");
classfile/placeholders.cpp:    st->print(", supername ");
classfile/placeholders.cpp:    st->print(", definer ");
classfile/placeholders.cpp:    st->print(", InstanceKlass ");
classfile/placeholders.cpp:  st->cr();
classfile/placeholders.cpp:  st->print("loadInstanceThreadQ threads:");
classfile/placeholders.cpp:  st->cr();
classfile/placeholders.cpp:  st->print("superThreadQ threads:");
classfile/placeholders.cpp:  st->cr();
classfile/placeholders.cpp:  st->print("defineThreadQ threads:");
classfile/placeholders.cpp:  st->cr();
classfile/placeholders.cpp:  st->print_cr("Placeholder table (table_size=%d, placeholders=%d)",
classfile/placeholders.cpp:      st->print("%4d: placeholder ", pindex);
classfile/classFileParser.cpp:                         "Nest-host class_info_index %u has bad constant type in class file %s",
classfile/classFileParser.cpp:  st->print_cr("  OopMapBlocks: %3d  /%3d", _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
classfile/classFileParser.cpp:      st->print_cr("    Offset: %3d  -%3d Count: %3d", map->offset(),
classfile/classFileParser.cpp:  // If it cannot be fast-path allocated, set a bit in the layout helper.
classfile/classFileParser.cpp:    // Forbid fast-path allocation.
classfile/classFileParser.cpp:  // can only set dynamic nest-host after static nest information is set
classfile/classFileParser.cpp:    ClassLoader::package_from_class_name(unsafe_anonymous_host->name());
classfile/classFileParser.cpp:    if (!_unsafe_anonymous_host->is_same_class_package(_unsafe_anonymous_host->class_loader(), _class_name)) {
classfile/classFileParser.cpp:        _unsafe_anonymous_host->name()->as_C_string(), _class_name->as_C_string()));
classfile/verificationType.hpp:      // Primitive values (type descriminator stored in most-signifcant bytes)
classfile/packageEntry.cpp:          !pkg_list->contains(entry->name())) {
classfile/packageEntry.cpp:  st->print_cr("Package Entry Table (table_size=%d, entries=%d)",
classfile/packageEntry.cpp:  st->print_cr("package entry " PTR_FORMAT " name %s module %s classpath_index "
classfile/protectionDomainCache.cpp:  st->print_cr("Protection domain cache table (table_size=%d, classes=%d)",
classfile/protectionDomainCache.cpp:      st->print_cr("%4d: protection_domain: " PTR_FORMAT, index, p2i(probe->object_no_keepalive()));
classfile/loaderConstraints.cpp:  st->print_cr("Java loader constraints (table_size=%d, constraints=%d)",
classfile/loaderConstraints.cpp:      st->print("%4d: ", cindex);
classfile/loaderConstraints.cpp:      st->print(" , loaders:");
classfile/loaderConstraints.cpp:        st->print(", ");
classfile/loaderConstraints.cpp:      st->cr();
classfile/symbolTable.cpp:    _st->print("%d %d: ", utf8_length, sym->refcount());
classfile/symbolTable.cpp:    _st->cr();
classfile/symbolTable.cpp:    st->print_cr("VERSION: 1.1");
classfile/stackMapTableFormat.hpp:      case ITEM_Top: st->print("Top"); break;
classfile/stackMapTableFormat.hpp:      case ITEM_Integer: st->print("Integer"); break;
classfile/stackMapTableFormat.hpp:      case ITEM_Float: st->print("Float"); break;
classfile/stackMapTableFormat.hpp:      case ITEM_Double: st->print("Double"); break;
classfile/stackMapTableFormat.hpp:      case ITEM_Long: st->print("Long"); break;
classfile/stackMapTableFormat.hpp:      case ITEM_Null: st->print("Null"); break;
classfile/stackMapTableFormat.hpp:        st->print("UninitializedThis"); break;
classfile/stackMapTableFormat.hpp:        st->print("Uninitialized[#%d]", bci()); break;
classfile/stackMapTableFormat.hpp:        st->print("Object[#%d]", cpool_index()); break;
classfile/stackMapTableFormat.hpp:        st->print("BAD:%d", tag()); break;
classfile/stackMapTableFormat.hpp:    st->print("same_frame(@%d)", offset_delta() + current_offset);
classfile/stackMapTableFormat.hpp:    st->print("same_frame_extended(@%d)", offset_delta() + current_offset);
classfile/stackMapTableFormat.hpp:    st->print("same_locals_1_stack_item_frame(@%d,",
classfile/stackMapTableFormat.hpp:    st->print(")");
classfile/stackMapTableFormat.hpp:    st->print("same_locals_1_stack_item_frame(@%d), output truncated, Stackmap exceeds table size.",
classfile/stackMapTableFormat.hpp:    st->print("same_locals_1_stack_item_extended(@%d,",
classfile/stackMapTableFormat.hpp:    st->print(")");
classfile/stackMapTableFormat.hpp:    st->print("same_locals_1_stack_item_extended(@%d), output truncated, Stackmap exceeds table size.",
classfile/stackMapTableFormat.hpp:    st->print("chop_frame(@%d,%d)", offset_delta() + current_offset, chops());
classfile/stackMapTableFormat.hpp:    st->print("append_frame(@%d,", offset_delta() + current_offset);
classfile/stackMapTableFormat.hpp:        st->print(",");
classfile/stackMapTableFormat.hpp:    st->print(")");
classfile/stackMapTableFormat.hpp:    st->print("append_frame(@%d), output truncated, Stackmap exceeds table size.",
classfile/stackMapTableFormat.hpp:    st->print("full_frame(@%d,{", offset_delta() + current_offset);
classfile/stackMapTableFormat.hpp:        st->print(",");
classfile/stackMapTableFormat.hpp:    st->print("},{");
classfile/stackMapTableFormat.hpp:        st->print(",");
classfile/stackMapTableFormat.hpp:    st->print("})");
classfile/stackMapTableFormat.hpp:    st->print("full_frame(@%d), output truncated, Stackmap exceeds table size.",
classfile/dictionary.cpp:  st->print("/mode=" INTX_FORMAT, symbol_mode());
classfile/dictionary.cpp:  st->print(" -> ");
classfile/dictionary.cpp:    if (printed)  st->print(" and ");
classfile/dictionary.cpp:    st->print(INTPTR_FORMAT, p2i((void *)method_type()));
classfile/dictionary.cpp:  st->print_cr(printed ? "" : "(empty)");
classfile/dictionary.cpp:  st->print_cr("pd set count = #%d", count);
classfile/dictionary.cpp:  st->print_cr("Java dictionary (table_size=%d, classes=%d, resizable=%s)",
classfile/dictionary.cpp:  st->print_cr("^ indicates that initiating loader is different from defining loader");
classfile/dictionary.cpp:      st->print("%4d: %s%s", index, is_defining_class ? " " : "^", e->external_name());
classfile/dictionary.cpp:        st->print(", ");
classfile/dictionary.cpp:      st->cr();
classfile/defaultMethods.cpp:    _st->indent().print_cr("%s", cls->name()->as_C_string());
classfile/defaultMethods.cpp:    if (!_free_list->is_empty()) {
classfile/defaultMethods.cpp:      restorer = _free_list->pop();
classfile/defaultMethods.cpp:      _free_list->push(restorer);
classfile/verifier.cpp:    st->print("Verification for %s has", klassName);
classfile/verifier.cpp:      st->print_cr(" exception pending '%s %s'",
classfile/verifier.cpp:      st->print_cr(" exception pending %s ",
classfile/verifier.cpp:    st->print_cr("Verification for %s failed", klassName);
classfile/verifier.cpp:  st->print_cr("End class verification for: %s", klassName);
classfile/verifier.cpp:      if (!handler_list->contains(exhandler_pc)) {
classfile/verifier.cpp:        handler_list->append(exhandler_pc);
classfile/systemDictionary.cpp:  assert(st->need_verify(), "invariant");
classfile/systemDictionary.cpp:    if (st->buffer() == NULL) {
classfile/systemDictionary.cpp:  assert(shared_nest_host->is_shared(), "nest host must be in CDS archive");
classfile/systemDictionary.cpp:  Symbol* cn = shared_nest_host->name();
classfile/systemDictionary.cpp:  assert(shared_nest_host->class_loader() == class_loader(), "mismatched class loader");
classfile/systemDictionary.cpp:  assert(shared_nest_host->class_loader_data() == ClassLoaderData::class_loader_data(class_loader()), "mismatched class loader data");
classfile/systemDictionary.cpp:  assert(shared_nest_host->is_same_class_package(ik),
classfile/systemDictionary.cpp:  st->cr();
classfile/systemDictionary.cpp:  st->cr();
classfile/systemDictionary.cpp:  st->cr();
classfile/compactHashtable.cpp:    case '\t': st->print("\\t"); break;
classfile/compactHashtable.cpp:    case '\r': st->print("\\r"); break;
classfile/compactHashtable.cpp:    case '\n': st->print("\\n"); break;
classfile/compactHashtable.cpp:    case '\\': st->print("\\\\"); break;
classfile/compactHashtable.cpp:        st->print("%c", *c);
classfile/compactHashtable.cpp:        st->print("\\x%02x", ((unsigned int)*c) & 0xff);
classfile/classLoaderHierarchyDCmd.cpp:      st->print("%c%.*s", _branches[i], branch_spacing, "          ");
classfile/classLoaderHierarchyDCmd.cpp:    st->print("+%.*s", BranchTracker::twig_len, "----------");
classfile/classLoaderHierarchyDCmd.cpp:      st->print(" <bootstrap>");
classfile/classLoaderHierarchyDCmd.cpp:        st->print(" \"%s\",", loader_name->as_C_string());
classfile/classLoaderHierarchyDCmd.cpp:      st->print(" %s", loader_klass != NULL ? loader_klass->external_name() : "??");
classfile/classLoaderHierarchyDCmd.cpp:        st->print(" (+ %d more)", _num_folded);
classfile/classLoaderHierarchyDCmd.cpp:    st->cr();
classfile/classLoaderHierarchyDCmd.cpp:      st->cr();
classfile/classLoaderHierarchyDCmd.cpp:        st->print_cr("%*s " PTR_FORMAT, indentation, "Loader Oop:", p2i(_loader_oop));
classfile/classLoaderHierarchyDCmd.cpp:        st->print_cr("%*s " PTR_FORMAT, indentation, "Loader Data:", p2i(_cld));
classfile/classLoaderHierarchyDCmd.cpp:        st->print_cr("%*s " PTR_FORMAT, indentation, "Loader Klass:", p2i(loader_klass));
classfile/classLoaderHierarchyDCmd.cpp:        st->cr();
classfile/classLoaderHierarchyDCmd.cpp:              st->print("%*s ", indentation, "Classes:");
classfile/classLoaderHierarchyDCmd.cpp:              st->print("%*s ", indentation, "");
classfile/classLoaderHierarchyDCmd.cpp:            st->print("%s", lci->_klass->external_name());
classfile/classLoaderHierarchyDCmd.cpp:              st->print(" (invokes: ");
classfile/classLoaderHierarchyDCmd.cpp:              st->print(")");
classfile/classLoaderHierarchyDCmd.cpp:            st->cr();
classfile/classLoaderHierarchyDCmd.cpp:          st->print("%*s ", indentation, "");
classfile/classLoaderHierarchyDCmd.cpp:          st->print_cr("(%u class%s)", _num_classes, (_num_classes == 1) ? "" : "es");
classfile/classLoaderHierarchyDCmd.cpp:          st->cr();
classfile/classLoaderHierarchyDCmd.cpp:              st->print("%*s ", indentation, "Hidden Classes:");
classfile/classLoaderHierarchyDCmd.cpp:              st->print("%*s ", indentation, "");
classfile/classLoaderHierarchyDCmd.cpp:            st->print("%s", lci->_klass->external_name());
classfile/classLoaderHierarchyDCmd.cpp:              st->print("  (Loader Data: " PTR_FORMAT ")", p2i(lci->_cld));
classfile/classLoaderHierarchyDCmd.cpp:            st->cr();
classfile/classLoaderHierarchyDCmd.cpp:          st->print("%*s ", indentation, "");
classfile/classLoaderHierarchyDCmd.cpp:          st->print_cr("(%u hidden class%s)", _num_hidden_classes,
classfile/classLoaderHierarchyDCmd.cpp:          st->cr();
classfile/classLoaderDataGraph.cpp:    st->print("Dictionary for ");
classfile/classLoaderDataGraph.cpp:    st->cr();
classfile/classLoaderDataGraph.cpp:    st->cr();
classfile/compactHashtable.hpp:    st->print_cr("%s statistics:", name);
classfile/compactHashtable.hpp:    st->print_cr("Number of buckets       : %9d", _bucket_count);
classfile/compactHashtable.hpp:    st->print_cr("Number of entries       : %9d", total_entries);
classfile/compactHashtable.hpp:    st->print_cr("Maximum bucket size     : %9d", max_bucket);
classfile/stringTable.cpp:      _st->print("%d: ", length);
classfile/stringTable.cpp:      _st->print("%d: ", utf8_length);
classfile/stringTable.cpp:    _st->cr();
classfile/stringTable.cpp:    st->print_cr("VERSION: 1.1");
classfile/stringTable.cpp:      st->print_cr("dump unavailable at this moment");
classfile/classLoader.cpp:  if ((st->st_mode & S_IFMT) == S_IFREG) {
classfile/classLoader.cpp:  int num_of_entries = module_list->length();
classfile/classLoader.cpp:    ModuleClassPathList* mpl = module_list->at(i);
classfile/classLoader.cpp:  int num_of_entries = module_list->length();
classfile/classLoader.cpp:    ModuleClassPathList* module_cpl = module_list->at(i);
classfile/verificationType.cpp:    case Bogus:            st->print("top"); break;
classfile/verificationType.cpp:    case Category1:        st->print("category1"); break;
classfile/verificationType.cpp:    case Category2:        st->print("category2"); break;
classfile/verificationType.cpp:    case Category2_2nd:    st->print("category2_2nd"); break;
classfile/verificationType.cpp:    case Boolean:          st->print("boolean"); break;
classfile/verificationType.cpp:    case Byte:             st->print("byte"); break;
classfile/verificationType.cpp:    case Short:            st->print("short"); break;
classfile/verificationType.cpp:    case Char:             st->print("char"); break;
classfile/verificationType.cpp:    case Integer:          st->print("integer"); break;
classfile/verificationType.cpp:    case Float:            st->print("float"); break;
classfile/verificationType.cpp:    case Long:             st->print("long"); break;
classfile/verificationType.cpp:    case Double:           st->print("double"); break;
classfile/verificationType.cpp:    case Long_2nd:         st->print("long_2nd"); break;
classfile/verificationType.cpp:    case Double_2nd:       st->print("double_2nd"); break;
classfile/verificationType.cpp:    case Null:             st->print("null"); break;
classfile/verificationType.cpp:    case ReferenceQuery:   st->print("reference type"); break;
classfile/verificationType.cpp:    case Category1Query:   st->print("category1 type"); break;
classfile/verificationType.cpp:    case Category2Query:   st->print("category2 type"); break;
classfile/verificationType.cpp:    case Category2_2ndQuery: st->print("category2_2nd type"); break;
classfile/verificationType.cpp:        st->print("uninitializedThis");
classfile/verificationType.cpp:        st->print("uninitialized %d", bci());
classfile/verificationType.cpp:          st->print_cr("NULL");
classfile/systemDictionaryShared.cpp:    _st->print_cr("%4d:  %s", (_index++), record->_klass->external_name());
classfile/systemDictionaryShared.cpp:    _st->print_cr("%4d:  %s", (_index++), record->proxy_klass_head()->external_name());
classfile/systemDictionaryShared.cpp:      _st->print_cr("%4d:  %s", (_index++), k->external_name());
classfile/systemDictionaryShared.cpp:    st->print_cr("Shared Dictionary");
classfile/systemDictionaryShared.cpp:        st->print_cr("Shared Lambda Dictionary");
classfile/fieldLayoutBuilder.cpp:// Insert a set of fields into a layout using a best-fit strategy.
classfile/fieldLayoutBuilder.cpp:  for (int i = 0; i < list->length(); i ++) {
classfile/fieldLayoutBuilder.cpp:    LayoutRawBlock* b = list->at(i);
classfile/fieldLayoutBuilder.cpp:  for (int i = 0; i < list->length(); i++) {
classfile/fieldLayoutBuilder.cpp:    size += list->at(i)->size();
classfile/fieldLayoutBuilder.cpp:    LayoutRawBlock* first = list->at(0);
classfile/fieldLayoutBuilder.cpp:    while (candidate->kind() != LayoutRawBlock::EMPTY || !candidate->fit(size, first->alignment())) {
classfile/fieldLayoutBuilder.cpp:    assert(candidate->fit(size, first->alignment()), "Candidate must be able to store the whole contiguous block");
classfile/fieldLayoutBuilder.cpp:  for (int i = 0; i < list->length(); i++) {
classfile/fieldLayoutBuilder.cpp:    LayoutRawBlock* b = list->at(i);
classfile/fieldLayoutBuilder.cpp:    _last->set_next_block(b);
classfile/fieldLayoutBuilder.cpp:  last->set_offset(b->offset() + b->size());
classfile/fieldLayoutBuilder.cpp:  assert(last->offset() > 0, "Sanity check");
classfile/fieldLayoutBuilder.cpp:  last->set_prev_block(b);
classfile/javaClasses.cpp:    st->print("NULL");
classfile/javaClasses.cpp:  st->print("\"");
classfile/javaClasses.cpp:    st->print("%c", (!is_latin1) ?  value->char_at(index) :
classfile/javaClasses.cpp:  st->print("\"");
classfile/javaClasses.cpp:    st->print("<null>");
classfile/javaClasses.cpp:  if (is_instance)  st->print("L");
classfile/javaClasses.cpp:  st->write((char*) name->base(), (int) name->utf8_length());
classfile/javaClasses.cpp:  if (is_instance)  st->print(";");
classfile/javaClasses.cpp:  st->print("%s", k->external_name());
classfile/javaClasses.cpp:    st->print(": %s", java_lang_String::as_utf8_string(msg));
classfile/javaClasses.cpp:  st->print_cr("%s", buf);
classfile/javaClasses.cpp:  st->cr();
classfile/javaClasses.cpp:      st->print_raw_cr("\t<<no stack trace available>>");
classfile/javaClasses.cpp:          st->print("Caused by: ");
classfile/javaClasses.cpp:          st->cr();
classfile/javaClasses.cpp:  case T_BOOLEAN:   st->print("%s", value->z ? "true" : "false");   break;
classfile/javaClasses.cpp:  case T_CHAR:      st->print("%d", value->c);                      break;
classfile/javaClasses.cpp:  case T_BYTE:      st->print("%d", value->b);                      break;
classfile/javaClasses.cpp:  case T_SHORT:     st->print("%d", value->s);                      break;
classfile/javaClasses.cpp:  case T_INT:       st->print("%d", value->i);                      break;
classfile/javaClasses.cpp:  case T_LONG:      st->print(JLONG_FORMAT, value->j);              break;
classfile/javaClasses.cpp:  case T_FLOAT:     st->print("%f", value->f);                      break;
classfile/javaClasses.cpp:  case T_DOUBLE:    st->print("%lf", value->d);                     break;
classfile/javaClasses.cpp:  default:          st->print("type %d?", type);                    break;
classfile/javaClasses.cpp:  st->print("(");
classfile/javaClasses.cpp:  st->print(")");
classfile/javaAssertions.cpp:  // sub-package in classname is checked, from most-specific to least, until one
classfile/javaAssertions.cpp:  // Find the length of the "most-specific" package in classname.  If classname
classfile/placeholders.hpp:      st->print(", ");
code/exceptionHandlerTable.hpp:// followed by pairs of <excp-offset, const-offset>.
code/dependencyContext.cpp:          last->set_next(b->next_not_unloading());
code/location.cpp:    case on_stack:     st->print("empty");    break;
code/location.cpp:    case in_register:  st->print("invalid");  break;
code/location.cpp:  case on_stack:    st->print("stack[%d]", stack_offset());    break;
code/location.cpp:  case in_register: st->print("reg %s [%d]", reg()->name(), register_number()); break;
code/location.cpp:  default:          st->print("Wrong location where %d", where());
code/location.cpp:  case oop:          st->print(",oop");        break;
code/location.cpp:  case narrowoop:    st->print(",narrowoop");  break;
code/location.cpp:  case int_in_long:  st->print(",int");        break;
code/location.cpp:  case lng:          st->print(",long");       break;
code/location.cpp:  case float_in_dbl: st->print(",float");      break;
code/location.cpp:  case dbl:          st->print(",double");     break;
code/location.cpp:  case addr:         st->print(",address");    break;
code/location.cpp:  default:           st->print("Wrong location type %d", type());
code/codeBlob.cpp:  st->print_cr("[CodeBlob (" INTPTR_FORMAT ")]", p2i(this));
code/codeBlob.cpp:  st->print_cr("Framesize: %d", _frame_size);
code/codeBlob.cpp:  st->print_cr("[CodeBlob]");
code/codeBlob.cpp:      st->print_cr(INTPTR_FORMAT " is at code_begin+%d in an Interpreter codelet", p2i(addr), (int)(addr - i->code_begin()));
code/codeBlob.cpp:      st->print_cr(INTPTR_FORMAT " is pointing into interpreter code"
code/codeBlob.cpp:      st->print_cr(INTPTR_FORMAT " is at code_begin+%d in an AdapterHandler", p2i(addr), (int)(addr - code_begin()));
code/codeBlob.cpp:      st->print_cr(INTPTR_FORMAT " is at begin+%d in a stub", p2i(addr), (int)(addr - d->begin()));
code/codeBlob.cpp:      st->cr();
code/codeBlob.cpp:      st->print_cr(INTPTR_FORMAT " is pointing to an (unnamed) stub routine", p2i(addr));
code/codeBlob.cpp:      st->print_cr(INTPTR_FORMAT " is pointing into InlineCacheBuffer", p2i(addr));
code/codeBlob.cpp:      st->print_cr(INTPTR_FORMAT " is at entry_point+%d in a vtable stub", p2i(addr), (int)(addr - v->entry_point()));
code/codeBlob.cpp:      st->cr();
code/codeBlob.cpp:    st->print(INTPTR_FORMAT " is at entry_point+%d in (nmethod*)" INTPTR_FORMAT,
code/codeBlob.cpp:      st->print(" for ");
code/codeBlob.cpp:    st->cr();
code/codeBlob.cpp:  st->print_cr(INTPTR_FORMAT " is at code_begin+%d in ", p2i(addr), (int)(addr - code_begin()));
code/codeBlob.cpp:  st->print_cr("BufferBlob (" INTPTR_FORMAT  ") used for %s", p2i(this), name());
code/codeBlob.cpp:  st->print("Runtime Stub (" INTPTR_FORMAT "): ", p2i(this));
code/codeBlob.cpp:  st->print_cr("%s", name());
code/codeBlob.cpp:  st->print("RuntimeStub (" INTPTR_FORMAT "): ", p2i(this)); st->print("%s", name());
code/codeBlob.cpp:  st->print_cr("%s", name());
code/codeBlob.cpp:  st->print_cr("%s", name());
code/codeBlob.cpp:  st->print_cr("Deoptimization (frame not available)");
code/pcDesc.cpp:  st->print("PcDesc(pc=" PTR_FORMAT " offset=%x bits=%x):", p2i(real_pc(code)), pc_offset(), _flags);
code/pcDesc.cpp:    st->cr();
code/pcDesc.cpp:  int pos = st->position() + 2; // current column plus two spaces
code/codeCache.cpp:      st->print("%s:", heap->name());
code/codeCache.cpp:      st->print("CodeCache:");
code/codeCache.cpp:    st->print_cr(" size=" SIZE_FORMAT "Kb used=" SIZE_FORMAT
code/codeCache.cpp:      st->print_cr(" bounds [" INTPTR_FORMAT ", " INTPTR_FORMAT ", " INTPTR_FORMAT "]",
code/codeCache.cpp:    st->print_cr(" total_blobs=" UINT32_FORMAT " nmethods=" UINT32_FORMAT
code/codeCache.cpp:    st->print_cr(" compilation: %s", CompileBroker::should_compile_new_jobs() ?
code/codeCache.cpp:    st->print_cr("              stopped_count=%d, restarted_count=%d",
code/codeCache.cpp:    st->print_cr(" full_count=%d", full_count);
code/codeCache.cpp:    st->print_cr("%d %d %d %s [" INTPTR_FORMAT ", " INTPTR_FORMAT " - " INTPTR_FORMAT "]",
code/codeCache.cpp:  st->print(" total_blobs='" UINT32_FORMAT "' nmethods='" UINT32_FORMAT "'"
code/debugInfoRec.cpp:      assert(prev == last-1, "sane");
code/vtableStubs.hpp://   platform-specific stub emitters. It accumulates the difference between worst-case
code/debugInfo.cpp:    st->print("marker");
code/debugInfo.cpp:  st->print("%s[%d]", is_auto_box() ? "box_obj" : "obj", _id);
code/debugInfo.cpp:    st->print(", ");
code/debugInfo.cpp:  st->print("%d", value());
code/debugInfo.cpp:  st->print(JLONG_FORMAT, value());
code/debugInfo.cpp:  st->print("%f", value());
code/debugInfo.cpp:    st->print_cr("NULL");
code/debugInfo.cpp:  st->print("monitor{");
code/debugInfo.cpp:  st->print(",");
code/debugInfo.cpp:  st->print("}");
code/debugInfo.cpp:    st->print(" (eliminated)");
code/relocInfo.cpp:  dest->set_locs_end(data);  // sync end: the next call may read dest.locs_end
code/relocInfo.cpp:  relocInfo* data_limit = dest->locs_end();
code/relocInfo.cpp:    dest->set_locs_end(data_limit+1);
code/relocInfo.cpp:  int sect = dest->section_index_of(newa);
code/relocInfo.cpp:  address nstart = dest->code_section(sect)->start();
code/relocInfo.cpp:  address nstart = dest->code_section(sect)->start();
code/relocInfo.cpp:  if (addr0 == NULL || dest->allocates2(addr0))  return;
code/relocInfo.cpp:  CodeBuffer* cb = dest->outer();
code/relocInfo.cpp:  assert(allow_other_sections || dest->contains2(addr),
code/relocInfo.cpp:  short* p = (short*) dest->locs_end();
code/relocInfo.cpp:  dest->set_locs_end((relocInfo*) p);
code/relocInfo.cpp:  short* p = (short*) dest->locs_end();
code/relocInfo.cpp:  dest->set_locs_end((relocInfo*) p);
code/relocInfo.cpp:  short*  p     = (short*) dest->locs_end();
code/relocInfo.cpp:  address point =          dest->locs_point();
code/relocInfo.cpp:  dest->set_locs_end((relocInfo*) p);
code/relocInfo.cpp:  short* p = pack_1_int_to((short *)dest->locs_end(), (jint)(_offset >> 2));
code/relocInfo.cpp:  dest->set_locs_end((relocInfo*) p);
code/relocInfo.cpp:  short* p = (short*) dest->locs_end();
code/relocInfo.cpp:  CodeSection* insts = dest->outer()->insts();
code/relocInfo.cpp:  dest->set_locs_end((relocInfo*) p);
code/relocInfo.cpp:  short* p = (short*) dest->locs_end();
code/relocInfo.cpp:  CodeSection* insts = dest->outer()->insts();
code/relocInfo.cpp:  dest->set_locs_end((relocInfo*) p);
code/relocInfo.cpp:  short* p = (short*) dest->locs_end();
code/relocInfo.cpp:  dest->set_locs_end((relocInfo*) p);
code/relocInfo.cpp:  short* p = (short*) dest->locs_end();
code/relocInfo.cpp:      && (!dest->allocates(_target) || _target == dest->locs_point())) {
code/relocInfo.cpp:    sindex = dest->outer()->section_index_of(_target);
code/relocInfo.cpp:    relocInfo* base = dest->locs_end() - 1;
code/relocInfo.cpp:    guarantee(_target == NULL || dest->allocates2(_target), "must be within the given code section");
code/relocInfo.cpp:    jint x0 = scaled_offset_null_special(_target, dest->locs_point());
code/relocInfo.cpp:    CodeSection* sect = dest->outer()->code_section(sindex);
code/relocInfo.cpp:  dest->set_locs_end((relocInfo*) p);
code/relocInfo.cpp:  short* p = (short*) dest->locs_end();
code/relocInfo.cpp:  dest->set_locs_end((relocInfo*) p);
code/relocInfo.cpp:  short* p = (short*) dest->locs_end();
code/relocInfo.cpp:  dest->set_locs_end((relocInfo*) p);
code/scopeDesc.cpp:  st->print("  ");
code/scopeDesc.cpp:    st->print("@%d (line %d)", bci(), lineno);
code/scopeDesc.cpp:    st->print("@%d", bci());
code/scopeDesc.cpp:    st->print("  reexecute=true");
code/scopeDesc.cpp:  st->cr();
code/scopeDesc.cpp:    st->print_cr("ScopeDesc(pc=" PTR_FORMAT " offset=%x):", p2i(pd->real_pc(_code)), pd->pc_offset());
code/scopeDesc.cpp:    st->print("ScopeDesc[%d]@" PTR_FORMAT " ", _decode_offset, p2i(_code->content_begin()));
code/scopeDesc.cpp:    st->print_cr(" offset:     %d",    _decode_offset);
code/scopeDesc.cpp:    st->print_cr(" bci:        %d",    bci());
code/scopeDesc.cpp:    st->print_cr(" reexecute:  %s",    should_reexecute() ? "true" : "false");
code/scopeDesc.cpp:    st->print_cr(" locals:     %d",    _locals_decode_offset);
code/scopeDesc.cpp:    st->print_cr(" stack:      %d",    _expressions_decode_offset);
code/scopeDesc.cpp:    st->print_cr(" monitor:    %d",    _monitors_decode_offset);
code/scopeDesc.cpp:    st->print_cr(" sender:     %d",    _sender_decode_offset);
code/scopeDesc.cpp:      st->print_cr("   Locals");
code/scopeDesc.cpp:        st->print("    - l%d: ", index);
code/scopeDesc.cpp:        st->cr();
code/scopeDesc.cpp:      st->print_cr("   Expression stack");
code/scopeDesc.cpp:        st->print("    - @%d: ", index);
code/scopeDesc.cpp:        st->cr();
code/scopeDesc.cpp:      st->print_cr("   Monitor stack");
code/scopeDesc.cpp:        st->print("    - @%d: ", index);
code/scopeDesc.cpp:        st->cr();
code/scopeDesc.cpp:    st->print_cr("   Objects");
code/scopeDesc.cpp:      st->print("    - %d: ", sv->id());
code/scopeDesc.cpp:      st->print("%s ", java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()())->external_name());
code/scopeDesc.cpp:      st->cr();
code/vtableStubs.cpp:  st->print("vtable stub (index = %d, receiver_location = " INTX_FORMAT ", code = [" INTPTR_FORMAT ", " INTPTR_FORMAT "])",
code/vtableStubs.cpp:  // Here is a list of observed worst-case values:
code/vmreg.cpp:    st->print("%s",VMRegImpl::regName[value()]);
code/vmreg.cpp:    st->print("[%d]", stk*4);
code/vmreg.cpp:    st->print("BAD!");
code/codeHeapState.cpp:// buf_st->print() (and the like) calls will be directed to a bufferedStream object.
code/codeHeapState.cpp:// Otherwise, buf_st->position() does not correspond to out_st->position() any longer.
code/codeHeapState.cpp:    ast->print_cr("   The code heap analysis function provides deep insights into\n"
code/codeHeapState.cpp:  ast->print_cr("   The aggregate step takes an aggregated snapshot of the CodeHeap.\n"
code/codeHeapState.cpp:  ast->print_cr("   CodeHeap committed size " SIZE_FORMAT "K (" SIZE_FORMAT "M), reserved size " SIZE_FORMAT "K (" SIZE_FORMAT "M), %d%% occupied.",
code/codeHeapState.cpp:  ast->print_cr("   CodeHeap allocation segment size is " SIZE_FORMAT " bytes. This is the smallest possible granularity.", seg_size);
code/codeHeapState.cpp:  ast->print_cr("   CodeHeap (committed part) is mapped to " SIZE_FORMAT " granules of size " SIZE_FORMAT " bytes.", granules, granularity);
code/codeHeapState.cpp:  ast->print_cr("   Each granule takes " SIZE_FORMAT " bytes of C heap, that is " SIZE_FORMAT "K in total for statistics data.", sizeof(StatElement), (sizeof(StatElement)*granules)/(size_t)K);
code/codeHeapState.cpp:  ast->print_cr("   The number of granules is limited to %dk, requiring a granules size of at least %d bytes for a 1GB heap.", (unsigned int)(max_granules/K), (unsigned int)(G/max_granules));
code/codeHeapState.cpp:        insane = true; ast->print_cr("Sanity check: HeapBlock @%p below low bound (%p)", (char*)h, low_bound);
code/codeHeapState.cpp:        insane = true; ast->print_cr("Sanity check: HeapBlock @%p outside reserved range (%p)", (char*)h, low_bound + res_size);
code/codeHeapState.cpp:        insane = true; ast->print_cr("Sanity check: HeapBlock @%p outside used range (%p)", (char*)h, low_bound + size);
code/codeHeapState.cpp:        insane = true; ast->print_cr("Sanity check: end index (%d) out of bounds (" SIZE_FORMAT ")", ix_end, granules);
code/codeHeapState.cpp:        insane = true; ast->print_cr("Sanity check: code heap capacity has changed (" SIZE_FORMAT "K to " SIZE_FORMAT "K)", size/(size_t)K, heap->capacity()/(size_t)K);
code/codeHeapState.cpp:        insane = true; ast->print_cr("Sanity check: end index (%d) lower than begin index (%d)", ix_end, ix_beg);
code/codeHeapState.cpp:      ast->print_cr("freeSpace        = " SIZE_FORMAT_W(8) "k, nBlocks_free     = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity", freeSpace/(size_t)K,     nBlocks_free,     (100.0*freeSpace)/size,     (100.0*freeSpace)/res_size);
code/codeHeapState.cpp:      ast->print_cr("usedSpace        = " SIZE_FORMAT_W(8) "k, nBlocks_used     = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity", usedSpace/(size_t)K,     nBlocks_used,     (100.0*usedSpace)/size,     (100.0*usedSpace)/res_size);
code/codeHeapState.cpp:      ast->print_cr("  Tier1 Space    = " SIZE_FORMAT_W(8) "k, nBlocks_t1       = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity", t1Space/(size_t)K,       nBlocks_t1,       (100.0*t1Space)/size,       (100.0*t1Space)/res_size);
code/codeHeapState.cpp:      ast->print_cr("  Tier2 Space    = " SIZE_FORMAT_W(8) "k, nBlocks_t2       = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity", t2Space/(size_t)K,       nBlocks_t2,       (100.0*t2Space)/size,       (100.0*t2Space)/res_size);
code/codeHeapState.cpp:      ast->print_cr("  Alive Space    = " SIZE_FORMAT_W(8) "k, nBlocks_alive    = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity", aliveSpace/(size_t)K,    nBlocks_alive,    (100.0*aliveSpace)/size,    (100.0*aliveSpace)/res_size);
code/codeHeapState.cpp:      ast->print_cr("    disconnected = " SIZE_FORMAT_W(8) "k, nBlocks_disconn  = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity", disconnSpace/(size_t)K,  nBlocks_disconn,  (100.0*disconnSpace)/size,  (100.0*disconnSpace)/res_size);
code/codeHeapState.cpp:      ast->print_cr("    not entrant  = " SIZE_FORMAT_W(8) "k, nBlocks_notentr  = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity", notentrSpace/(size_t)K,  nBlocks_notentr,  (100.0*notentrSpace)/size,  (100.0*notentrSpace)/res_size);
code/codeHeapState.cpp:      ast->print_cr("  inconstrSpace  = " SIZE_FORMAT_W(8) "k, nBlocks_inconstr = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity", inconstrSpace/(size_t)K, nBlocks_inconstr, (100.0*inconstrSpace)/size, (100.0*inconstrSpace)/res_size);
code/codeHeapState.cpp:      ast->print_cr("  unloadedSpace  = " SIZE_FORMAT_W(8) "k, nBlocks_unloaded = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity", unloadedSpace/(size_t)K, nBlocks_unloaded, (100.0*unloadedSpace)/size, (100.0*unloadedSpace)/res_size);
code/codeHeapState.cpp:      ast->print_cr("  deadSpace      = " SIZE_FORMAT_W(8) "k, nBlocks_dead     = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity", deadSpace/(size_t)K,     nBlocks_dead,     (100.0*deadSpace)/size,     (100.0*deadSpace)/res_size);
code/codeHeapState.cpp:      ast->print_cr("  stubSpace      = " SIZE_FORMAT_W(8) "k, nBlocks_stub     = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity", stubSpace/(size_t)K,     nBlocks_stub,     (100.0*stubSpace)/size,     (100.0*stubSpace)/res_size);
code/codeHeapState.cpp:      ast->print_cr("ZombieBlocks     = %8d. These are HeapBlocks which could not be identified as CodeBlobs.", nBlocks_zomb);
code/codeHeapState.cpp:      ast->cr();
code/codeHeapState.cpp:      ast->print_cr("Segment start          = " INTPTR_FORMAT ", used space      = " SIZE_FORMAT_W(8)"k", p2i(low_bound), size/K);
code/codeHeapState.cpp:      ast->print_cr("Segment end (used)     = " INTPTR_FORMAT ", remaining space = " SIZE_FORMAT_W(8)"k", p2i(low_bound) + size, (res_size - size)/K);
code/codeHeapState.cpp:      ast->print_cr("Segment end (reserved) = " INTPTR_FORMAT ", reserved space  = " SIZE_FORMAT_W(8)"k", p2i(low_bound) + res_size, res_size/K);
code/codeHeapState.cpp:      ast->cr();
code/codeHeapState.cpp:      ast->print_cr("latest allocated compilation id = %d", latest_compilation_id);
code/codeHeapState.cpp:      ast->print_cr("highest observed compilation id = %d", highest_compilation_id);
code/codeHeapState.cpp:      ast->print_cr("Building TopSizeList iterations = %ld", total_iterations);
code/codeHeapState.cpp:      ast->cr();
code/codeHeapState.cpp:      ast->print_cr("Highest possible method temperature:          %12d", reset_val);
code/codeHeapState.cpp:      ast->print_cr("Threshold for method to be considered 'cold': %12.3f", -reset_val + reverse_free_ratio * NmethodSweepActivity);
code/codeHeapState.cpp:        ast->print_cr("min. hotness = %6d", minTemp);
code/codeHeapState.cpp:        ast->print_cr("avg. hotness = %6d", avgTemp);
code/codeHeapState.cpp:        ast->print_cr("max. hotness = %6d", maxTemp);
code/codeHeapState.cpp:        ast->print_cr("No hotness data available");
code/codeHeapState.cpp:    ast->print_cr("   The aggregate step collects information about all free blocks in CodeHeap.\n"
code/codeHeapState.cpp:    ast->print_cr("   Free space in %s is distributed over %d free blocks.", heapName, nBlocks_free);
code/codeHeapState.cpp:    ast->print_cr("   Each free block takes " SIZE_FORMAT " bytes of C heap for statistics data, that is " SIZE_FORMAT "K in total.", sizeof(FreeBlk), (sizeof(FreeBlk)*nBlocks_free)/K);
code/codeHeapState.cpp:      ast->print_cr("Free block count mismatch. Expected %d free blocks, but found %d.", alloc_freeBlocks, ix);
code/codeHeapState.cpp:      ast->print_cr("I will update the counter and retry data collection");
code/codeHeapState.cpp:      ast->print_cr("Free block count mismatch could not be resolved.");
code/codeHeapState.cpp:      ast->print_cr("Try to run \"aggregate\" function to update counters");
code/codeHeapState.cpp:    ast->print_cr("Note: The Top%d list of the largest used blocks associates method names\n"
code/codeHeapState.cpp:    ast->fill_to(51);
code/codeHeapState.cpp:    ast->print("%4s", "blob");
code/codeHeapState.cpp:    ast->fill_to(56);
code/codeHeapState.cpp:    ast->print("%9s", "compiler");
code/codeHeapState.cpp:    ast->fill_to(66);
code/codeHeapState.cpp:    ast->print_cr("%6s", "method");
code/codeHeapState.cpp:    ast->print_cr("%18s %13s %17s %4s %9s  %5s %s",      "Addr(module)      ", "offset", "size", "type", " type lvl", " temp", "Name");
code/codeHeapState.cpp:          ast->print(INTPTR_FORMAT, p2i(this_blob));
code/codeHeapState.cpp:          ast->fill_to(19);
code/codeHeapState.cpp:          ast->print("(+" PTR32_FORMAT ")", (unsigned int)((char*)this_blob-low_bound));
code/codeHeapState.cpp:          ast->fill_to(33);
code/codeHeapState.cpp:          ast->print(INTPTR_FORMAT, p2i(TopSizeArray[i].start));
code/codeHeapState.cpp:          ast->fill_to(19);
code/codeHeapState.cpp:          ast->print("(+" PTR32_FORMAT ")", (unsigned int)((char*)TopSizeArray[i].start-low_bound));
code/codeHeapState.cpp:          ast->fill_to(33);
code/codeHeapState.cpp:          ast->print(PTR32_FORMAT, total_size);
code/codeHeapState.cpp:          ast->print("(" SIZE_FORMAT_W(4) "K)", total_size/K);
code/codeHeapState.cpp:          ast->fill_to(51);
code/codeHeapState.cpp:          ast->print("  %c", blobTypeChar[TopSizeArray[i].type]);
code/codeHeapState.cpp:          ast->fill_to(56);
code/codeHeapState.cpp:          ast->print("%5s %3d", compTypeName[TopSizeArray[i].compiler], TopSizeArray[i].level);
code/codeHeapState.cpp:          ast->fill_to(67);
code/codeHeapState.cpp:          ast->print("%5d", nm->hotness_counter());
code/codeHeapState.cpp:          ast->fill_to(67+6);
code/codeHeapState.cpp:            ast->print(" not (yet) installed method ");
code/codeHeapState.cpp:            ast->print(" zombie method ");
code/codeHeapState.cpp:          ast->print("%s", blob_name);
code/codeHeapState.cpp:          ast->print(PTR32_FORMAT, (unsigned int)(TopSizeArray[i].len<<log2_seg_size));
code/codeHeapState.cpp:          ast->print("(" SIZE_FORMAT_W(4) "K)", (TopSizeArray[i].len<<log2_seg_size)/K);
code/codeHeapState.cpp:          ast->fill_to(56);
code/codeHeapState.cpp:          ast->fill_to(67+6);
code/codeHeapState.cpp:          ast->print("%s", blob_name);
code/codeHeapState.cpp:        ast->cr();
code/codeHeapState.cpp:        ast->print_cr("used blocks: %d, printed blocks: %d", used_topSizeBlocks, printed_topSizeBlocks);
code/codeHeapState.cpp:          ast->print_cr("  TopSizeArray[%d].index = %d, len = %d", i, TopSizeArray[i].index, TopSizeArray[i].len);
code/codeHeapState.cpp:      ast->print_cr("Note: The histogram indicates how many blocks (as a percentage\n"
code/codeHeapState.cpp:      ast->print_cr("total size   of all blocks: %7ldM", (total_size<<log2_seg_size)/M);
code/codeHeapState.cpp:      ast->print_cr("total number of all blocks: %7ld\n", total_count);
code/codeHeapState.cpp:      ast->print_cr("[Size Range)------avg.-size-+----count-+");
code/codeHeapState.cpp:          ast->print("[" SIZE_FORMAT_W(5) " .." SIZE_FORMAT_W(5) " ): "
code/codeHeapState.cpp:          ast->print("[" SIZE_FORMAT_W(5) "K.." SIZE_FORMAT_W(5) "K): "
code/codeHeapState.cpp:          ast->print("[" SIZE_FORMAT_W(5) "M.." SIZE_FORMAT_W(5) "M): "
code/codeHeapState.cpp:        ast->print(" %8d | %8d |",
code/codeHeapState.cpp:          ast->print("%c", (j%((pctFactor/100)*10) == 0) ? ('0'+j/(((unsigned int)pctFactor/100)*10)) : '*');
code/codeHeapState.cpp:        ast->cr();
code/codeHeapState.cpp:      ast->print_cr("----------------------------+----------+");
code/codeHeapState.cpp:      ast->print_cr("Note: The histogram indicates how much space (as a percentage of all\n"
code/codeHeapState.cpp:      ast->print_cr("total size   of all blocks: %7ldM", (total_size<<log2_seg_size)/M);
code/codeHeapState.cpp:      ast->print_cr("total number of all blocks: %7ld\n", total_count);
code/codeHeapState.cpp:      ast->print_cr("[Size Range)------avg.-size-+----count-+");
code/codeHeapState.cpp:          ast->print("[" SIZE_FORMAT_W(5) " .." SIZE_FORMAT_W(5) " ): "
code/codeHeapState.cpp:          ast->print("[" SIZE_FORMAT_W(5) "K.." SIZE_FORMAT_W(5) "K): "
code/codeHeapState.cpp:          ast->print("[" SIZE_FORMAT_W(5) "M.." SIZE_FORMAT_W(5) "M): "
code/codeHeapState.cpp:        ast->print(" %8d | %8d |",
code/codeHeapState.cpp:          ast->print("%c", (j%((pctFactor/100)*10) == 0) ? ('0'+j/(((unsigned int)pctFactor/100)*10)) : '*');
code/codeHeapState.cpp:        ast->cr();
code/codeHeapState.cpp:      ast->print_cr("----------------------------+----------+");
code/codeHeapState.cpp:    ast->print_cr("Note: in this context, a gap is the occupied space between two free blocks.\n"
code/codeHeapState.cpp:      ast->print(INTPTR_FORMAT ": Len[%4d] = " HEX32_FORMAT ",", p2i(FreeArray[ix].start), ix, FreeArray[ix].len);
code/codeHeapState.cpp:      ast->fill_to(38);
code/codeHeapState.cpp:      ast->print("Gap[%4d..%4d]: " HEX32_FORMAT " bytes,", ix, ix+1, FreeArray[ix].gap);
code/codeHeapState.cpp:      ast->fill_to(71);
code/codeHeapState.cpp:      ast->print("block count: %6d", FreeArray[ix].n_gapBlocks);
code/codeHeapState.cpp:        ast->print(" !! permanent gap, contains stubs and/or blobs !!");
code/codeHeapState.cpp:      ast->cr();
code/codeHeapState.cpp:    ast->print_cr(INTPTR_FORMAT ": Len[%4d] = " HEX32_FORMAT, p2i(FreeArray[ix].start), ix, FreeArray[ix].len);
code/codeHeapState.cpp:        ast->print_cr("Internal logic error. New Max10 = %d detected, but could not be merged. Old Max10 = %d",
code/codeHeapState.cpp:      ast->print("Pos %3d: Block %4d - size " HEX32_FORMAT ",", iy+1, FreeTopTen[iy]->index, FreeTopTen[iy]->len);
code/codeHeapState.cpp:      ast->fill_to(39);
code/codeHeapState.cpp:        ast->print("last free block in list.");
code/codeHeapState.cpp:        ast->print("Gap (to next) " HEX32_FORMAT ",", FreeTopTen[iy]->gap);
code/codeHeapState.cpp:        ast->fill_to(63);
code/codeHeapState.cpp:        ast->print("#blocks (in gap) %d", FreeTopTen[iy]->n_gapBlocks);
code/codeHeapState.cpp:      ast->cr();
code/codeHeapState.cpp:        ast->print_cr("Internal logic error. New Max10 = %d detected, but could not be merged. Old Max10 = %d",
code/codeHeapState.cpp:    ast->print_cr("  Use this information to judge how likely it is that a large(r) free block\n"
code/codeHeapState.cpp:      ast->print("Pos %3d: Block %4d - size " HEX32_FORMAT ",", iy+1, FreeTopTenTriple[iy]->index, FreeTopTenTriple[iy]->len);
code/codeHeapState.cpp:      ast->fill_to(39);
code/codeHeapState.cpp:      ast->print("Gap (to next) " HEX32_FORMAT ",", FreeTopTenTriple[iy]->gap);
code/codeHeapState.cpp:      ast->fill_to(63);
code/codeHeapState.cpp:      ast->print("#blocks (in gap) %d", FreeTopTenTriple[iy]->n_gapBlocks);
code/codeHeapState.cpp:      ast->cr();
code/codeHeapState.cpp:    ast->print_cr("  Each granule contains an individual number of heap blocks. Large blocks\n"
code/codeHeapState.cpp:      ast->print_cr("  You have selected granule size to be as small as segment size.\n"
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:      ast->print("No Tier1 nMethods found in CodeHeap.");
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:      ast->print("No Tier2 nMethods found in CodeHeap.");
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:      ast->print("No not_used/not_entrant nMethods found in CodeHeap.");
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:      ast->print("No Stubs and Blobs found in CodeHeap.");
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:      ast->print("No dead nMethods found in CodeHeap.");
code/codeHeapState.cpp:        ast->print(":");
code/codeHeapState.cpp:        ast->print(":");
code/codeHeapState.cpp:        ast->print(" ");
code/codeHeapState.cpp:    ast->print_cr("  The heap space covered by one granule is occupied to a various extend.\n"
code/codeHeapState.cpp:      ast->print_cr("  You have selected granule size to be as small as segment size.\n"
code/codeHeapState.cpp:      ast->print_cr("  These digits represent a fill percentage range (see legend).\n");
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:      ast->print("No Tier1 nMethods found in CodeHeap.");
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:      ast->print("No Tier2 nMethods found in CodeHeap.");
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:      ast->print("No Tier2 nMethods found in CodeHeap.");
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:      ast->print("No Stubs and Blobs found in CodeHeap.");
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:      ast->print("No dead nMethods found in CodeHeap.");
code/codeHeapState.cpp:        ast->print(":");
code/codeHeapState.cpp:        ast->print(":");
code/codeHeapState.cpp:        ast->print(" ");
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:    ast->print_cr("  The age of a compiled method in the CodeHeap is not available as a\n"
code/codeHeapState.cpp:    ast->print("|");
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:      ast->print("No Tier1 nMethods found in CodeHeap.");
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:      ast->print("No Tier2 nMethods found in CodeHeap.");
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:      ast->print("No Tier2 nMethods found in CodeHeap.");
code/codeHeapState.cpp:        ast->print(":");
code/codeHeapState.cpp:        ast->print(" ");
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:  ast->print_cr("  Method names are dynamically retrieved from the code cache at print time.\n"
code/codeHeapState.cpp:        ast->print_cr("No methods, blobs, or stubs found in this address range");
code/codeHeapState.cpp:      ast->cr();
code/codeHeapState.cpp:      ast->print_cr("--------------------------------------------------------------------");
code/codeHeapState.cpp:      ast->print_cr("Address range [" INTPTR_FORMAT "," INTPTR_FORMAT "), " SIZE_FORMAT "k", p2i(low_bound+ix*granule_size), p2i(low_bound + end_ix*granule_size), (end_ix - ix)*granule_size/(size_t)K);
code/codeHeapState.cpp:      ast->print_cr("--------------------------------------------------------------------");
code/codeHeapState.cpp:          ast->fill_to(51);
code/codeHeapState.cpp:          ast->print("%9s", "compiler");
code/codeHeapState.cpp:          ast->fill_to(61);
code/codeHeapState.cpp:          ast->print_cr("%6s", "method");
code/codeHeapState.cpp:          ast->print_cr("%18s %13s %17s %9s  %5s %18s  %s", "Addr(module)      ", "offset", "size", " type lvl", " temp", "blobType          ", "Name");
code/codeHeapState.cpp:        ast->print(INTPTR_FORMAT, p2i(this_blob));
code/codeHeapState.cpp:        ast->fill_to(19);
code/codeHeapState.cpp:        ast->print("(+" PTR32_FORMAT ")", (unsigned int)((char*)this_blob-low_bound));
code/codeHeapState.cpp:        ast->fill_to(33);
code/codeHeapState.cpp:          ast->print(PTR32_FORMAT, total_size);
code/codeHeapState.cpp:          ast->print("(" SIZE_FORMAT_W(4) "K)", total_size/K);
code/codeHeapState.cpp:          ast->fill_to(51);
code/codeHeapState.cpp:          ast->print("%5s %3d", compTypeName[StatArray[ix].compiler], StatArray[ix].level);
code/codeHeapState.cpp:          ast->fill_to(62);
code/codeHeapState.cpp:          ast->print("%5d", hotness);
code/codeHeapState.cpp:          ast->fill_to(62+6);
code/codeHeapState.cpp:          ast->print("%s", blobTypeName[cbType]);
code/codeHeapState.cpp:          ast->fill_to(82+6);
code/codeHeapState.cpp:            ast->print("%14s", " zombie method");
code/codeHeapState.cpp:            ast->print("%s", methNameS);
code/codeHeapState.cpp:            ast->print("%s", methSigS);
code/codeHeapState.cpp:            ast->print("%s", blob_name);
code/codeHeapState.cpp:          ast->fill_to(62+6);
code/codeHeapState.cpp:          ast->print("%s", blobTypeName[cbType]);
code/codeHeapState.cpp:          ast->fill_to(82+6);
code/codeHeapState.cpp:          ast->print("%s", blob_name);
code/codeHeapState.cpp:          ast->fill_to(62+6);
code/codeHeapState.cpp:          ast->print("<stale blob>");
code/codeHeapState.cpp:        ast->cr();
code/codeHeapState.cpp:  ast->print("%c", edge);
code/codeHeapState.cpp:    ast->print("%c", border);
code/codeHeapState.cpp:  ast->print_cr("%c", edge);
code/codeHeapState.cpp:  ast->print("%c  ", frame);
code/codeHeapState.cpp:    ast->print("%s", text1);
code/codeHeapState.cpp:    ast->print("%s", text2);
code/codeHeapState.cpp:  ast->print_cr("  %c", frame);
code/codeHeapState.cpp:  ast->print("%c", edge);
code/codeHeapState.cpp:    ast->print("%c", border);
code/codeHeapState.cpp:  ast->print_cr("%c", edge);
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:    ast->cr();
code/codeHeapState.cpp:    ast->print(INTPTR_FORMAT, p2i(low_bound + ix*granule_size));
code/codeHeapState.cpp:    ast->fill_to(19);
code/codeHeapState.cpp:    ast->print("(+" PTR32_FORMAT "): |", (unsigned int)(ix*granule_size));
code/codeHeapState.cpp:      ast->print("|");
code/codeHeapState.cpp:    ast->cr();
code/codeHeapState.cpp:    // if ((ast->capacity() - ast->size()) < 512) {
code/codeHeapState.cpp:    if (ast->size() > 3*K) {
code/codeHeapState.cpp:      out->print("%s", ast->as_string());
code/codeHeapState.cpp:      ast->reset();
code/codeHeapState.cpp:    ast->print(INTPTR_FORMAT, p2i(low_bound + ix*granule_size));
code/codeHeapState.cpp:    ast->fill_to(19);
code/codeHeapState.cpp:    ast->print("(+" PTR32_FORMAT "): |", (unsigned int)(ix*granule_size));
code/compiledIC.hpp:    st->verify();
code/compiledIC.hpp:    st->verify();
code/dependencies.cpp:  st->print_cr("%s of type %s",
code/dependencies.cpp:    st->print("  %s = %s", what, (put_star? "*": ""));
code/dependencies.cpp:      st->print("%s", ((Klass*)arg.metadata_value())->external_name());
code/dependencies.cpp:    st->cr();
code/dependencies.cpp:    st->print_cr("  witness = %s%s",
code/dependencies.cpp:      st->print("  code: ");
code/dependencies.cpp:      st->cr();
code/exceptionHandlerTable.cpp:// followed by pairs of <excp-offset, const-offset>.
code/nmethod.cpp:      st->print_cr(" (" INTPTR_FORMAT ")", p2i(this));
code/nmethod.cpp:  st->print("Compiled method ");
code/nmethod.cpp:    st->print("(c1) ");
code/nmethod.cpp:    st->print("(c2) ");
code/nmethod.cpp:    st->print("(JVMCI) ");
code/nmethod.cpp:    st->print("(n/a) ");
code/nmethod.cpp:    st->print("((nmethod*) " INTPTR_FORMAT ") ", p2i(this));
code/nmethod.cpp:    st->print(" for method " INTPTR_FORMAT , p2i(method()));
code/nmethod.cpp:    st->print(" { ");
code/nmethod.cpp:    st->print_cr("%s ", state());
code/nmethod.cpp:    st->print_cr("}:");
code/nmethod.cpp:  if (size              () > 0) st->print_cr(" total in heap  [" INTPTR_FORMAT "," INTPTR_FORMAT "] = %d",
code/nmethod.cpp:  if (relocation_size   () > 0) st->print_cr(" relocation     [" INTPTR_FORMAT "," INTPTR_FORMAT "] = %d",
code/nmethod.cpp:  if (consts_size       () > 0) st->print_cr(" constants      [" INTPTR_FORMAT "," INTPTR_FORMAT "] = %d",
code/nmethod.cpp:  if (insts_size        () > 0) st->print_cr(" main code      [" INTPTR_FORMAT "," INTPTR_FORMAT "] = %d",
code/nmethod.cpp:  if (stub_size         () > 0) st->print_cr(" stub code      [" INTPTR_FORMAT "," INTPTR_FORMAT "] = %d",
code/nmethod.cpp:  if (oops_size         () > 0) st->print_cr(" oops           [" INTPTR_FORMAT "," INTPTR_FORMAT "] = %d",
code/nmethod.cpp:  if (metadata_size     () > 0) st->print_cr(" metadata       [" INTPTR_FORMAT "," INTPTR_FORMAT "] = %d",
code/nmethod.cpp:  if (scopes_data_size  () > 0) st->print_cr(" scopes data    [" INTPTR_FORMAT "," INTPTR_FORMAT "] = %d",
code/nmethod.cpp:  if (scopes_pcs_size   () > 0) st->print_cr(" scopes pcs     [" INTPTR_FORMAT "," INTPTR_FORMAT "] = %d",
code/nmethod.cpp:  if (dependencies_size () > 0) st->print_cr(" dependencies   [" INTPTR_FORMAT "," INTPTR_FORMAT "] = %d",
code/nmethod.cpp:  if (handler_table_size() > 0) st->print_cr(" handler table  [" INTPTR_FORMAT "," INTPTR_FORMAT "] = %d",
code/nmethod.cpp:  if (nul_chk_table_size() > 0) st->print_cr(" nul chk table  [" INTPTR_FORMAT "," INTPTR_FORMAT "] = %d",
code/nmethod.cpp:  if (speculations_size () > 0) st->print_cr(" speculations   [" INTPTR_FORMAT "," INTPTR_FORMAT "] = %d",
code/nmethod.cpp:  if (jvmci_data_size   () > 0) st->print_cr(" JVMCI data     [" INTPTR_FORMAT "," INTPTR_FORMAT "] = %d",
code/nmethod.cpp:  st->print("Oops:");
code/nmethod.cpp:    st->cr();
code/nmethod.cpp:      st->print(PTR_FORMAT " ", *((uintptr_t*)p));
code/nmethod.cpp:        st->print_cr("NON_OOP");
code/nmethod.cpp:        st->print_cr("NULL-oop");
code/nmethod.cpp:      st->cr();
code/nmethod.cpp:    st->print_cr(" <list empty>");
code/nmethod.cpp:  st->print("Metadata:");
code/nmethod.cpp:    st->cr();
code/nmethod.cpp:      st->print(PTR_FORMAT " ", *((uintptr_t*)p));
code/nmethod.cpp:      st->cr();
code/nmethod.cpp:    st->print_cr(" <list empty>");
code/nmethod.cpp:  st->print("scopes:");
code/nmethod.cpp:    st->cr();
code/nmethod.cpp:    st->print_cr(" <list empty>");
code/nmethod.cpp:  st->print("pc-bytecode offsets:");
code/nmethod.cpp:    st->cr();
code/nmethod.cpp:    st->print_cr(" <list empty>");
code/nmethod.cpp:    st->cr();
code/nmethod.cpp:      st->print_cr("[Constant Pool]");
code/nmethod.cpp:      st->cr();
code/nmethod.cpp:      st->print_cr("[Constant Pool (unaligned)]");
code/nmethod.cpp:      st->cr();
code/nmethod.cpp:      st->print_cr("[Code entry alignment]");
code/nmethod.cpp:        st->cr();
code/nmethod.cpp:    st->print_cr("[Constant Pool (empty)]");
code/nmethod.cpp:  st->cr();
code/nmethod.cpp:  st->cr();
code/nmethod.cpp:  st->cr();
code/nmethod.cpp:    st->print_cr("PrintAssembly not possible due to uninitialized section pointers");
code/nmethod.cpp:    //---<  Open the output (Marker for post-mortem disassembler)  >---
code/nmethod.cpp:    st->print_cr("[MachCode]");
code/nmethod.cpp:        st->bol();
code/nmethod.cpp:        st->print_cr("%s", header);
code/nmethod.cpp:    //---<  Close the output (Marker for post-mortem disassembler)  >---
code/nmethod.cpp:    st->bol();
code/nmethod.cpp:    st->print_cr("[/MachCode]");
code/nmethod.cpp:    //---<  Open the output (Marker for post-mortem disassembler)  >---
code/nmethod.cpp:    st->print_cr("[MachCode]");
code/nmethod.cpp:        if (st->position() == 0) {
code/nmethod.cpp:          st->cr();  // interrupt byte stream
code/nmethod.cpp:          st->cr();  // add an empty line
code/nmethod.cpp:        st->bol();
code/nmethod.cpp:        st->cr();
code/nmethod.cpp:    //---<  Close the output (Marker for post-mortem disassembler)  >---
code/nmethod.cpp:    st->bol();
code/nmethod.cpp:    st->print_cr("[/MachCode]");
code/nmethod.cpp:        if (fst->is_reg()) {
code/nmethod.cpp:          stream->print("%s", fst->name());
code/nmethod.cpp:        } else if (fst->is_stack()) {
code/nmethod.cpp:          int offset = fst->reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;
code/nmethod.cpp:    st->move_to(column, 6, 0);
code/nmethod.cpp:      st->print("; implicit exception: deoptimizes");
code/nmethod.cpp:      st->print("; implicit exception: dispatches to " INTPTR_FORMAT, p2i(code_begin() + cont_offset));
code/nmethod.cpp:          st->move_to(column, 6, 0);
code/nmethod.cpp:          st->print("; ");
code/nmethod.cpp:    st->move_to(column, 6, 0);
code/nmethod.cpp:      st->print(";*synchronization entry");
code/nmethod.cpp:      st->print(";* method exit (unlocked if synchronized)");
code/nmethod.cpp:      st->print(";* unwind (locked if synchronized)");
code/nmethod.cpp:      st->print(";* unwind (unlocked if synchronized)");
code/nmethod.cpp:      st->print(";* unknown");
code/nmethod.cpp:      st->print(";* invalid frame state");
code/nmethod.cpp:        st->print("method is NULL");
code/nmethod.cpp:        st->print("method is native");
code/nmethod.cpp:        st->print(";*%s", Bytecodes::name(bc));
code/nmethod.cpp:            st->print(" ");
code/nmethod.cpp:              st->print("<UNKNOWN>");
code/nmethod.cpp:            st->print(" ");
code/nmethod.cpp:              st->print("<UNKNOWN>");
code/nmethod.cpp:      st->print(" {reexecute=%d rethrow=%d return_oop=%d}", sd->should_reexecute(), sd->rethrow_exception(), sd->return_oop());
code/nmethod.cpp:      st->move_to(column, 6, 0);
code/nmethod.cpp:      st->print("; -");
code/nmethod.cpp:        st->print(" (reexecute)");
code/nmethod.cpp:        st->print("method is NULL");
code/nmethod.cpp:        st->print("@%d (line %d)", sd->bci(), lineno);
code/nmethod.cpp:        st->print("@%d", sd->bci());
code/nmethod.cpp:      st->cr();
code/nmethod.cpp:    if (sd != NULL) st->cr();
code/nmethod.cpp:    st->move_to(column, 6, 0);
code/nmethod.cpp:    st->print(";   {%s}", str);
code/nmethod.cpp:  st->print("nmethod");
code/nmethod.cpp:      st->print_cr("Static call at " INTPTR_FORMAT, p2i(iter.reloc()->addr()));
code/vmreg.hpp:    return (_first->is_valid()) && (_first->value() + 1 == _second->value());
code/vmreg.hpp:    return (_first->is_stack() && (_first->value() + 1 == _second->value()) && ((_first->value() & (alignment-1)) == 0));
code/vmreg.hpp:    return (_first->is_stack() && (_first->value() + 1 == _second->value()) && ((_first->value() & (alignment-1)) == 0));
code/vmreg.hpp:    return (_first->is_reg() && (_first->value() + 1 == _second->value()));
compiler/compileTask.cpp:  st->print("%s:", CompileBroker::compiler_name(comp_level()));
compiler/compileTask.cpp:    st->print("%7d ", (int)tty->time_stamp().milliseconds());
compiler/compileTask.cpp:      st->print("%d ", (int)TimeHelper::counter_to_millis(now-time_queued));
compiler/compileTask.cpp:        st->print("%d ", (int)TimeHelper::counter_to_millis(now-time_started));
compiler/compileTask.cpp:    st->print("%s:", CompileBroker::compiler_name(comp_level));
compiler/compileTask.cpp:  st->print("%4d ", compile_id);    // print compilation number
compiler/compileTask.cpp:  st->print("%c%c%c%c%c ", compile_type, sync_char, exception_char, blocking_char, native_char);
compiler/compileTask.cpp:    if (comp_level != -1)  st->print("%d ", comp_level);
compiler/compileTask.cpp:    else                   st->print("- ");
compiler/compileTask.cpp:  st->print("     ");  // more indent
compiler/compileTask.cpp:    st->print("(method)");
compiler/compileTask.cpp:      st->print(" @ %d", osr_bci);
compiler/compileTask.cpp:      st->print(" (native)");
compiler/compileTask.cpp:      st->print(" (%d bytes)", method->code_size());
compiler/compileTask.cpp:    st->print("   %s", msg);
compiler/compileTask.cpp:    st->cr();
compiler/compileTask.cpp:  st->print("        ");     // print timestamp
compiler/compileTask.cpp:  st->print("     ");        // print compilation number
compiler/compileTask.cpp:  st->print("      ");       // print method attributes
compiler/compileTask.cpp:    st->print("  ");
compiler/compileTask.cpp:  st->print("     ");        // more indent
compiler/compileTask.cpp:  st->print("    ");         // initial inlining indent
compiler/compileTask.cpp:  for (int i = 0; i < inline_level; i++)  st->print("  ");
compiler/compileTask.cpp:  st->print("        ");     // print timestamp
compiler/compileTask.cpp:  st->print("     ");        // print compilation number
compiler/compileTask.cpp:    st->print(" %c%c%c  ", sync_char, exception_char, monitors_char);
compiler/compileTask.cpp:    st->print("      ");     // print method attributes
compiler/compileTask.cpp:    st->print("  ");
compiler/compileTask.cpp:  st->print("     ");        // more indent
compiler/compileTask.cpp:  st->print("    ");         // initial inlining indent
compiler/compileTask.cpp:  for (int i = 0; i < inline_level; i++)  st->print("  ");
compiler/compileTask.cpp:  st->print("@ %d  ", bci);  // print bci
compiler/compileTask.cpp:    st->print(" (%d bytes)", method->code_size());
compiler/compileTask.cpp:    st->print(" (not loaded)");
compiler/compileTask.cpp:    st->print("   %s", msg);
compiler/compileTask.cpp:  st->cr();
compiler/directivesParser.cpp:    st->flush();
compiler/directivesParser.cpp:    st->print_cr("Parsing of compiler directives failed");
compiler/directivesParser.cpp:    st->print_cr("Could not load file: %s", filename);
compiler/directivesParser.cpp:    _st->print_cr("No directives in file");
compiler/directivesParser.cpp:    _st->print_cr("%i compiler directives added", i);
compiler/oopMap.cpp:    if (last->offset() == map->offset() ) {
compiler/oopMap.cpp:    if (last->offset() > map->offset()) {
compiler/oopMap.cpp:                      _list.length(),last->offset(),_list.length()+1,map->offset());
compiler/oopMap.cpp:    st->print("Oop");
compiler/oopMap.cpp:    st->print("NarrowOop");
compiler/oopMap.cpp:    st->print("Callers_");
compiler/oopMap.cpp:    st->print("Derived_oop_");
compiler/oopMap.cpp:  st->print("=");
compiler/oopMap.cpp:  st->print(" ");
compiler/oopMap.cpp:  st->print("ImmutableOopMap {");
compiler/oopMap.cpp:  st->print("}");
compiler/oopMap.cpp:  st->print("OopMap {");
compiler/oopMap.cpp:  st->print("off=%d/0x%x}", (int) offset(), (int) offset());
compiler/oopMap.cpp:  st->print_cr("ImmutableOopMapSet contains %d OopMaps", len);
compiler/oopMap.cpp:      st->cr();
compiler/oopMap.cpp:      st->print(" pc offsets: ");
compiler/oopMap.cpp:    st->print("%d ", pair->pc_offset());
compiler/oopMap.cpp:  st->cr();
compiler/oopMap.cpp:  st->print_cr("OopMapSet contains %d OopMaps", len);
compiler/oopMap.cpp:    st->print_cr("#%d ",i);
compiler/oopMap.cpp:    st->cr();
compiler/oopMap.cpp:  st->cr();
compiler/oopMap.cpp:  assert(last->pc_offset() == pc_offset, "oopmap not found");
compiler/oopMap.cpp:  return last->get_from(this);
compiler/oopMap.cpp:  return Entry::_list == NULL || Entry::_list->empty();
compiler/oopMap.cpp:    Entry::_list->push(*entry);
compiler/oopMap.cpp:  Entry* entries = Entry::_list->pop_all();
compiler/oopMap.cpp:  assert(Entry::_list->empty(), "invariant");
compiler/oopMap.hpp:    if (_last != NULL && _last->count() > 0 && _last->equals(map)) {
compiler/compilerDirectives.hpp:  void print_intx(outputStream* st, ccstr n, intx v, bool mod) { if (mod) { st->print("%s:" INTX_FORMAT " ", n, v); } }
compiler/compilerDirectives.hpp:  void print_uintx(outputStream* st, ccstr n, intx v, bool mod) { if (mod) { st->print("%s:" UINTX_FORMAT " ", n, v); } }
compiler/compilerDirectives.hpp:  void print_bool(outputStream* st, ccstr n, bool v, bool mod) { if (mod) { st->print("%s:%s ", n, v ? "true" : "false"); } }
compiler/compilerDirectives.hpp:  void print_double(outputStream* st, ccstr n, double v, bool mod) { if (mod) { st->print("%s:%f ", n, v); } }
compiler/compilerDirectives.hpp:  void print_ccstr(outputStream* st, ccstr n, ccstr v, bool mod) { if (mod) { st->print("%s:%s ", n, v); } }
compiler/compilerDirectives.hpp:    st->print("  ");
compiler/compilerDirectives.hpp:    st->cr();
compiler/methodLiveness.cpp:        dest->add_normal_predecessor(current_block);
compiler/methodLiveness.cpp:        dest->add_normal_predecessor(current_block);
compiler/methodLiveness.cpp:        dest->add_normal_predecessor(current_block);
compiler/methodLiveness.cpp:        dest->add_normal_predecessor(current_block);
compiler/methodLiveness.cpp:          dest->add_normal_predecessor(current_block);
compiler/methodLiveness.cpp:            dest->add_normal_predecessor(current_block);
compiler/methodLiveness.cpp:          dest->add_normal_predecessor(current_block);
compiler/methodLiveness.cpp:            dest->add_normal_predecessor(current_block);
compiler/methodLiveness.cpp:          dest->add_normal_predecessor(current_block);
compiler/methodLiveness.cpp:          jsr_exit_list->append(jsrExit);
compiler/methodLiveness.cpp:          dest->add_normal_predecessor(current_block);
compiler/methodLiveness.cpp:          jsr_exit_list->append(jsrExit);
compiler/methodLiveness.cpp:        ret_list->append(current_block);
compiler/methodLiveness.cpp:  int ret_list_len = ret_list->length();
compiler/methodLiveness.cpp:  int jsr_exit_list_len = jsr_exit_list->length();
compiler/methodLiveness.cpp:      BasicBlock *jsrExit = jsr_exit_list->at(i);
compiler/methodLiveness.cpp:        jsrExit->add_normal_predecessor(ret_list->at(i));
compiler/abstractDisassembler.cpp:// Working assumption: we are at st->bol() upon entry. If not, it's the
compiler/abstractDisassembler.cpp:  const int     pos_0  = st->position();
compiler/abstractDisassembler.cpp:    st->print(" ");
compiler/abstractDisassembler.cpp:      st->print(" %*s", 18, "Address");
compiler/abstractDisassembler.cpp:      st->print(" " PTR_FORMAT, p2i(here));
compiler/abstractDisassembler.cpp:    if ((uintptr_t)begin > (uintptr_t)here) st->print(">>begin(" PTR_FORMAT ") > here(" PTR_FORMAT ")<<", p2i(begin), p2i(here));
compiler/abstractDisassembler.cpp:    if ((uintptr_t)end   < (uintptr_t)here) st->print(">>  end(" PTR_FORMAT ") < here(" PTR_FORMAT ")<<", p2i(end),   p2i(here));
compiler/abstractDisassembler.cpp:      st->print(" %*s", width+5, "offset");
compiler/abstractDisassembler.cpp:      st->print(" (+0x%*.*x)", width, width, offset);
compiler/abstractDisassembler.cpp:    st->print(": ");
compiler/abstractDisassembler.cpp:    const uint pos         = st->position();
compiler/abstractDisassembler.cpp:    st->fill_to(aligned_pos);
compiler/abstractDisassembler.cpp:  return st->position() - pos_0;
compiler/abstractDisassembler.cpp:    const int pos_0       = st->position();
compiler/abstractDisassembler.cpp:        st->print("%2.2x", *byte);
compiler/abstractDisassembler.cpp:      st->print(" ");
compiler/abstractDisassembler.cpp:        st->print("%2.2x", *pos);
compiler/abstractDisassembler.cpp:      st->print("  ");
compiler/abstractDisassembler.cpp:    st->print(" "); // separator space.
compiler/abstractDisassembler.cpp:    return st->position() - pos_0;
compiler/abstractDisassembler.cpp:    const uint pos         = st->position();
compiler/abstractDisassembler.cpp:    st->fill_to(aligned_pos);
compiler/abstractDisassembler.cpp:  const int pos_0 = st->position();
compiler/abstractDisassembler.cpp:  st->fill_to(align);
compiler/abstractDisassembler.cpp:                st->print("hex1");
compiler/abstractDisassembler.cpp:                st->print("0x%02x", *here);
compiler/abstractDisassembler.cpp:              st->fill_to(align += tsize);
compiler/abstractDisassembler.cpp:                st->print("  hex2");
compiler/abstractDisassembler.cpp:                  st->print("0x%04x",   *((jushort*)here));
compiler/abstractDisassembler.cpp:              st->fill_to(align += tsize);
compiler/abstractDisassembler.cpp:                st->print("      hex4");
compiler/abstractDisassembler.cpp:                  st->print("0x%08x",   *((juint*)here));
compiler/abstractDisassembler.cpp:              st->fill_to(align += 2*tsize);
compiler/abstractDisassembler.cpp:                st->print("              hex8");
compiler/abstractDisassembler.cpp:                  st->print(PTR_FORMAT, *((uintptr_t*)here));
compiler/abstractDisassembler.cpp:              st->fill_to(align += 3*tsize);
compiler/abstractDisassembler.cpp:    pos   = st->position();
compiler/abstractDisassembler.cpp:    st->fill_to(align);
compiler/abstractDisassembler.cpp:                st->print("         int");
compiler/abstractDisassembler.cpp:                  st->print("%12.1d",  *((jint*)here));
compiler/abstractDisassembler.cpp:              st->fill_to(align += 2*tsize);
compiler/abstractDisassembler.cpp:                st->print("                   long");
compiler/abstractDisassembler.cpp:                  st->print(JLONG_FORMAT_W(23), *((jlong*)here));
compiler/abstractDisassembler.cpp:              st->fill_to(align += 3*tsize);
compiler/abstractDisassembler.cpp:    pos   = st->position();
compiler/abstractDisassembler.cpp:    st->fill_to(align);
compiler/abstractDisassembler.cpp:                st->print("          float");
compiler/abstractDisassembler.cpp:                  st->print("%15.7e",  (double)*((float*)here));
compiler/abstractDisassembler.cpp:              st->fill_to(align += 2*tsize);
compiler/abstractDisassembler.cpp:                st->print("                 double");
compiler/abstractDisassembler.cpp:                  st->print("%23.15e",         *((double*)here));
compiler/abstractDisassembler.cpp:              st->fill_to(align += 3*tsize);
compiler/abstractDisassembler.cpp:  return st->position() - pos_0;
compiler/abstractDisassembler.cpp:  if (align_instr()) { st->print("| "); return 2; }
compiler/abstractDisassembler.cpp:    st->print("%02x", *current);
compiler/abstractDisassembler.cpp:      if (i%abstract_instruction_bytes_per_block == 0) st->print(" ");
compiler/abstractDisassembler.cpp:      if (i == instruction_size_in_bytes) st->print(" ");
compiler/abstractDisassembler.cpp:    st->print("  ");
compiler/abstractDisassembler.cpp:      if (i%abstract_instruction_bytes_per_block == 0) st->print(" ");
compiler/abstractDisassembler.cpp:      if (i == instruction_size_in_bytes) st->print(" ");
compiler/abstractDisassembler.cpp:      st->cr();
compiler/abstractDisassembler.cpp:  //---<  Open the output (Marker for post-mortem disassembler)  >---
compiler/abstractDisassembler.cpp:  st->bol();
compiler/abstractDisassembler.cpp:  st->print_cr("[MachCode]");
compiler/abstractDisassembler.cpp:  //---<  Close the output (Marker for post-mortem disassembler)  >---
compiler/abstractDisassembler.cpp:  st->bol();
compiler/abstractDisassembler.cpp:  st->print_cr("[/MachCode]");
compiler/compilerDirectives.cpp:    st->cr();
compiler/compilerDirectives.cpp:    st->print("Directive:");
compiler/compilerDirectives.cpp:      st->print_cr(" (default)");
compiler/compilerDirectives.cpp:      st->cr();
compiler/compilerDirectives.cpp:    st->print(" matching: ");
compiler/compilerDirectives.cpp:      st->print(", ");
compiler/compilerDirectives.cpp:    st->cr();
compiler/compilerDirectives.cpp:    st->print_cr(" c1 directives:");
compiler/compilerDirectives.cpp:    st->cr();
compiler/compilerDirectives.cpp:    st->print_cr(" c2 directives:");
compiler/compilerDirectives.cpp:    st->print_cr("Warning:  +LogCompilation must be set to enable compilation logging from directives");
compiler/compilerDirectives.cpp:    st->print_cr("  inline: -");
compiler/compilerDirectives.cpp:    st->print("  inline: ");
compiler/compilerDirectives.cpp:      st->print(", ");
compiler/compilerDirectives.cpp:    st->cr();
compiler/compilerDirectives.cpp:    st->print_cr("Could not add %i more directives. Currently %i/%i directives.", request_size, _depth, CompilerDirectivesLimit);
compiler/compilerDirectives.cpp:    st->cr();
compiler/compileBroker.cpp:    assert(_last->next() == NULL, "not last");
compiler/compileBroker.cpp:    _last->set_next(task);
compiler/compileBroker.cpp:  st->print_cr("Current compiles: ");
compiler/compileBroker.cpp:  st->cr();
compiler/compileBroker.cpp:  st->print_cr("%s:", name());
compiler/compileBroker.cpp:    st->print_cr("Empty");
compiler/compileBroker.cpp:  st->cr();
compiler/disassembler.cpp:    st->bol();
compiler/disassembler.cpp:          st->cr();
compiler/disassembler.cpp:        st->move_to(COMMENT_COLUMN);
compiler/disassembler.cpp:        st->print(";;@FILE: %s", file);
compiler/disassembler.cpp:          st->cr();
compiler/disassembler.cpp:        st->move_to(COMMENT_COLUMN);
compiler/disassembler.cpp:        st->print(";;%5d: %s", line, source_line);
compiler/disassembler.cpp:    ost->print_cr("PrintAssemblyOptions help:");
compiler/disassembler.cpp:    ost->print_cr("  print-raw       test plugin by requesting raw output");
compiler/disassembler.cpp:    ost->print_cr("  print-raw-xml   test plugin by requesting raw xml");
compiler/disassembler.cpp:    ost->cr();
compiler/disassembler.cpp:    ost->print_cr("  show-pc            toggle printing current pc,        currently %s", AbstractDisassembler::show_pc()            ? "ON" : "OFF");
compiler/disassembler.cpp:    ost->print_cr("  show-offset        toggle printing current offset,    currently %s", AbstractDisassembler::show_offset()        ? "ON" : "OFF");
compiler/disassembler.cpp:    ost->print_cr("  show-bytes         toggle printing instruction bytes, currently %s", AbstractDisassembler::show_bytes()         ? "ON" : "OFF");
compiler/disassembler.cpp:    ost->print_cr("  show-data-hex      toggle formatting data as hex,     currently %s", AbstractDisassembler::show_data_hex()      ? "ON" : "OFF");
compiler/disassembler.cpp:    ost->print_cr("  show-data-int      toggle formatting data as int,     currently %s", AbstractDisassembler::show_data_int()      ? "ON" : "OFF");
compiler/disassembler.cpp:    ost->print_cr("  show-data-float    toggle formatting data as float,   currently %s", AbstractDisassembler::show_data_float()    ? "ON" : "OFF");
compiler/disassembler.cpp:    ost->print_cr("  show-structs       toggle compiler data structures,   currently %s", AbstractDisassembler::show_structs()       ? "ON" : "OFF");
compiler/disassembler.cpp:    ost->print_cr("  show-comment       toggle instruction comments,       currently %s", AbstractDisassembler::show_comment()       ? "ON" : "OFF");
compiler/disassembler.cpp:    ost->print_cr("  show-block-comment toggle block comments,             currently %s", AbstractDisassembler::show_block_comment() ? "ON" : "OFF");
compiler/disassembler.cpp:    ost->print_cr("  align-instr        toggle instruction alignment,      currently %s", AbstractDisassembler::align_instr()        ? "ON" : "OFF");
compiler/disassembler.cpp:    ost->print_cr("combined options: %s", options());
compiler/disassembler.cpp:    st->print("NULL");
compiler/disassembler.cpp:    st->print("%d", small_num);
compiler/disassembler.cpp:        st->print("Stub::%s", desc->name());
compiler/disassembler.cpp:          st->print(INTX_FORMAT_W(+) " " PTR_FORMAT, adr - desc->begin(), p2i(adr));
compiler/disassembler.cpp:          st->print(" " PTR_FORMAT, p2i(adr));
compiler/disassembler.cpp:      st->print("Stub::<unknown> " PTR_FORMAT, p2i(adr));
compiler/disassembler.cpp:      st->print("word_map_base");
compiler/disassembler.cpp:      if (WizardMode) st->print(" " INTPTR_FORMAT, p2i(adr));
compiler/disassembler.cpp:      st->print(PTR_FORMAT " = %s",  p2i(adr), buf);
compiler/disassembler.cpp:        st->print("+%d", offset);
compiler/disassembler.cpp:  st->print(PTR_FORMAT, p2i(adr));
compiler/disassembler.cpp:  if (flen == 1 && format[0] == '\n') { st->bol(); return 1; }
compiler/disassembler.cpp:    st->print_raw(raw, (int) flen);
compiler/disassembler.cpp:  julong cnt0 = st->count();
compiler/disassembler.cpp:  st->vprint(format, ap);
compiler/disassembler.cpp:  julong cnt1 = st->count();
compiler/disassembler.cpp:    if (Verbose) st->print_cr("Trying to load: %s", buf);
compiler/disassembler.cpp:      if (Verbose) st->print_cr("Trying to load: %s", buf);
compiler/disassembler.cpp:        if (Verbose) st->print_cr("Trying to load: %s", buf);
compiler/disassembler.cpp:    if (Verbose) st->print_cr("Trying to load: %s via LD_LIBRARY_PATH or equivalent", buf);
compiler/disassembler.cpp:      st->print_cr("Loaded disassembler from %s", buf);
compiler/disassembler.cpp:      st->print_cr("Could not load %s; %s; %s",
compiler/disassembler.cpp:      st->print("Memory range [" PTR_FORMAT ".." PTR_FORMAT "] not contained in CodeBuffer", p2i(start), p2i(end));
compiler/disassembler.cpp:      st->print("Memory range [" PTR_FORMAT ".." PTR_FORMAT "] not readable", p2i(start), p2i(end));
compiler/disassembler.cpp:      st->print("Memory range [" PTR_FORMAT ".." PTR_FORMAT "] not readable", p2i(start), p2i(end));
compiler/compilerOracle.cpp:    TypedMethodOptionMatcher* m = option_list->match(method, option, get_type_for<T>());
compiler/disassembler.hpp:  // Check out if we are doing a live disassembly or a post-mortem
compiler/disassembler.hpp:// Activate once post-mortem disassembly (from hs-err file) is available.
compiler/methodMatcher.cpp:    st->print("*");
compiler/methodMatcher.cpp:    st->print("*");
compiler/methodMatcher.cpp:  st->print(".");
compiler/methodMatcher.cpp:    st->print("+");
compiler/methodMatcher.cpp:    st->print("-");
gc/shenandoah/shenandoahHeap.cpp:  st->print_cr("Shenandoah Heap");
gc/shenandoah/shenandoahHeap.cpp:  st->print_cr(" " SIZE_FORMAT "%s max, " SIZE_FORMAT "%s soft max, " SIZE_FORMAT "%s committed, " SIZE_FORMAT "%s used",
gc/shenandoah/shenandoahHeap.cpp:  st->print_cr(" " SIZE_FORMAT " x " SIZE_FORMAT"%s regions",
gc/shenandoah/shenandoahHeap.cpp:  st->print("Status: ");
gc/shenandoah/shenandoahHeap.cpp:  if (has_forwarded_objects())                 st->print("has forwarded objects, ");
gc/shenandoah/shenandoahHeap.cpp:  if (is_concurrent_mark_in_progress())        st->print("marking, ");
gc/shenandoah/shenandoahHeap.cpp:  if (is_evacuation_in_progress())             st->print("evacuating, ");
gc/shenandoah/shenandoahHeap.cpp:  if (is_update_refs_in_progress())            st->print("updating refs, ");
gc/shenandoah/shenandoahHeap.cpp:  if (is_degenerated_gc_in_progress())         st->print("degenerated gc, ");
gc/shenandoah/shenandoahHeap.cpp:  if (is_full_gc_in_progress())                st->print("full gc, ");
gc/shenandoah/shenandoahHeap.cpp:  if (is_full_gc_move_in_progress())           st->print("full gc move, ");
gc/shenandoah/shenandoahHeap.cpp:  if (is_concurrent_weak_root_in_progress())   st->print("concurrent weak roots, ");
gc/shenandoah/shenandoahHeap.cpp:      !is_concurrent_weak_root_in_progress())  st->print("concurrent strong roots, ");
gc/shenandoah/shenandoahHeap.cpp:    st->print("cancelled");
gc/shenandoah/shenandoahHeap.cpp:    st->print("not cancelled");
gc/shenandoah/shenandoahHeap.cpp:  st->cr();
gc/shenandoah/shenandoahHeap.cpp:  st->print_cr("Reserved region:");
gc/shenandoah/shenandoahHeap.cpp:  st->print_cr(" - [" PTR_FORMAT ", " PTR_FORMAT ") ",
gc/shenandoah/shenandoahHeap.cpp:  st->print_cr("Collection set:");
gc/shenandoah/shenandoahHeap.cpp:    st->print_cr(" - map (vanilla): " PTR_FORMAT, p2i(cset->map_address()));
gc/shenandoah/shenandoahHeap.cpp:    st->print_cr(" - map (biased):  " PTR_FORMAT, p2i(cset->biased_map_address()));
gc/shenandoah/shenandoahHeap.cpp:    st->print_cr(" (NULL)");
gc/shenandoah/shenandoahHeap.cpp:  st->cr();
gc/shenandoah/shenandoahHeap.cpp:  st->print_cr("Heap Regions:");
gc/shenandoah/shenandoahHeap.cpp:  st->print_cr("EU=empty-uncommitted, EC=empty-committed, R=regular, H=humongous start, HC=humongous continuation, CS=collection set, T=trash, P=pinned");
gc/shenandoah/shenandoahHeap.cpp:  st->print_cr("BTE=bottom/top/end, U=used, T=TLAB allocs, G=GCLAB allocs, S=shared allocs, L=live data");
gc/shenandoah/shenandoahHeap.cpp:  st->print_cr("R=root, CP=critical pins, TAMS=top-at-mark-start, UWM=update watermark");
gc/shenandoah/shenandoahHeap.cpp:  st->print_cr("SN=alloc sequence number");
gc/shenandoah/shenandoahFreeSet.cpp:      // Fast-path: try to allocate in the collector view first
gc/shenandoah/shenandoahFreeSet.cpp:    // almost-full regions precede the fully-empty region where we want allocate the entire TLAB.
gc/shenandoah/shenandoahFreeSet.cpp:    _mutator_rightmost--;
gc/shenandoah/shenandoahFreeSet.cpp:    _collector_rightmost--;
gc/shenandoah/shenandoahFreeSet.cpp:    // If regions are not adjacent, then current [beg; end] is useless, and we may fast-forward.
gc/shenandoah/shenandoahFreeSet.cpp:    // If region is not completely free, the current [beg; end] is useless, and we may fast-forward.
gc/shenandoah/shenandoahFreeSet.cpp: *   c) Heap is first-half full => EF = 1/2
gc/shenandoah/c2/shenandoahSupport.cpp:    // Fast-path case
gc/shenandoah/c2/shenandoahBarrierSetC2.cpp:      dist--;
gc/shenandoah/shenandoahHeapRegion.cpp:  st->print("|");
gc/shenandoah/shenandoahHeapRegion.cpp:  st->print(SIZE_FORMAT_W(5), this->_index);
gc/shenandoah/shenandoahHeapRegion.cpp:      st->print("|EU ");
gc/shenandoah/shenandoahHeapRegion.cpp:      st->print("|EC ");
gc/shenandoah/shenandoahHeapRegion.cpp:      st->print("|R  ");
gc/shenandoah/shenandoahHeapRegion.cpp:      st->print("|H  ");
gc/shenandoah/shenandoahHeapRegion.cpp:      st->print("|HP ");
gc/shenandoah/shenandoahHeapRegion.cpp:      st->print("|HC ");
gc/shenandoah/shenandoahHeapRegion.cpp:      st->print("|CS ");
gc/shenandoah/shenandoahHeapRegion.cpp:      st->print("|T  ");
gc/shenandoah/shenandoahHeapRegion.cpp:      st->print("|P  ");
gc/shenandoah/shenandoahHeapRegion.cpp:      st->print("|CSP");
gc/shenandoah/shenandoahHeapRegion.cpp:  st->print("|BTE " INTPTR_FORMAT_W(12) ", " INTPTR_FORMAT_W(12) ", " INTPTR_FORMAT_W(12),
gc/shenandoah/shenandoahHeapRegion.cpp:  st->print("|TAMS " INTPTR_FORMAT_W(12),
gc/shenandoah/shenandoahHeapRegion.cpp:  st->print("|UWM " INTPTR_FORMAT_W(12),
gc/shenandoah/shenandoahHeapRegion.cpp:  st->print("|U " SIZE_FORMAT_W(5) "%1s", byte_size_in_proper_unit(used()),                proper_unit_for_byte_size(used()));
gc/shenandoah/shenandoahHeapRegion.cpp:  st->print("|T " SIZE_FORMAT_W(5) "%1s", byte_size_in_proper_unit(get_tlab_allocs()),     proper_unit_for_byte_size(get_tlab_allocs()));
gc/shenandoah/shenandoahHeapRegion.cpp:  st->print("|G " SIZE_FORMAT_W(5) "%1s", byte_size_in_proper_unit(get_gclab_allocs()),    proper_unit_for_byte_size(get_gclab_allocs()));
gc/shenandoah/shenandoahHeapRegion.cpp:  st->print("|S " SIZE_FORMAT_W(5) "%1s", byte_size_in_proper_unit(get_shared_allocs()),   proper_unit_for_byte_size(get_shared_allocs()));
gc/shenandoah/shenandoahHeapRegion.cpp:  st->print("|L " SIZE_FORMAT_W(5) "%1s", byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));
gc/shenandoah/shenandoahHeapRegion.cpp:  st->print("|CP " SIZE_FORMAT_W(3), pin_count());
gc/shenandoah/shenandoahHeapRegion.cpp:  st->cr();
gc/shenandoah/shenandoahCodeRoots.cpp:   * had claimed the block, it can process all blobs in it. Others have to fast-forward to
gc/shenandoah/shenandoahBarrierSet.cpp:  st->print("ShenandoahBarrierSet");
gc/shenandoah/shenandoahNMethod.cpp:  _list->release();
gc/shenandoah/shenandoahNMethod.cpp:  assert(_index >= 0 && _index <= _list->size(), "Sanity");
gc/shenandoah/shenandoahNMethod.cpp:  return _list->at(index);
gc/shenandoah/shenandoahNMethod.cpp:  assert(_index >= 0 && _index <= _list->size(), "Sanity");
gc/shenandoah/shenandoahNMethod.cpp:  ShenandoahNMethod* snm = _list->at(idx);
gc/shenandoah/shenandoahNMethod.cpp:  ShenandoahNMethod* tmp = _list->at(_index - 1);
gc/shenandoah/shenandoahNMethod.cpp:  _list->set(idx, tmp);
gc/shenandoah/shenandoahNMethod.cpp:    int new_size = 2 * _list->size();
gc/shenandoah/shenandoahNMethod.cpp:  _list->set(_index++,  snm);
gc/shenandoah/shenandoahNMethod.cpp:  assert(_index >= 0 && _index <= _list->size(), "Sanity");
gc/shenandoah/shenandoahNMethod.cpp:  new_list->transfer(_list, _index);
gc/shenandoah/shenandoahNMethod.cpp:  _list->release();
gc/shenandoah/shenandoahNMethod.cpp:    ShenandoahNMethod* m = _list->at(index);
gc/shenandoah/shenandoahNMethod.cpp:  ShenandoahNMethod** old_list = list->list();
gc/shenandoah/shenandoahNMethod.cpp:  _heap(ShenandoahHeap::heap()), _list(table->_list->acquire()), _limit(table->_index), _claimed(0) {
gc/shenandoah/shenandoahNMethod.cpp:  _list->release();
gc/shenandoah/shenandoahNMethod.cpp:  ShenandoahNMethod** const list = _list->list();
gc/shenandoah/shenandoahNMethod.cpp:  ShenandoahNMethod** list = _list->list();
gc/shenandoah/shenandoahTaskqueue.cpp:  st->print_raw_cr("GC Task Stats");
gc/shenandoah/shenandoahTaskqueue.cpp:  st->print_raw("thr "); TaskQueueStats::print_header(1, st); st->cr();
gc/shenandoah/shenandoahTaskqueue.cpp:  st->print_raw("--- "); TaskQueueStats::print_header(2, st); st->cr();
gc/shenandoah/shenandoahTaskqueue.cpp:    st->print(UINT32_FORMAT_W(3), i);
gc/shenandoah/shenandoahTaskqueue.cpp:    st->cr();
gc/shenandoah/shenandoahTaskqueue.cpp:  st->print("tot "); totals.print(st); st->cr();
gc/shenandoah/shenandoahControlThread.cpp:  st->print("Shenandoah Concurrent Thread");
gc/shenandoah/shenandoahControlThread.cpp:  st->cr();
gc/shenandoah/shenandoahStrDedupQueue.cpp:    _free_list = _free_list->next();
gc/shenandoah/shenandoahStrDedupQueue.cpp:    list = list->next();
gc/shenandoah/shenandoahNMethod.hpp:    assert(_index <= _list->size(), "Sanity");
gc/shenandoah/shenandoahNMethod.hpp:    return _index == _list->size();
gc/shenandoah/shenandoahPhaseTimings.cpp:  out->print_cr("        and post-safepoint housekeeping. Use -Xlog:safepoint+stats to dissect.");
gc/parallel/psVirtualspace.cpp:  st->print_cr(" [" PTR_FORMAT ", " PTR_FORMAT ", " PTR_FORMAT ")",
gc/parallel/psYoungGen.cpp:  st->print(" %-15s", "PSYoungGen");
gc/parallel/psYoungGen.cpp:  st->print(" total " SIZE_FORMAT "K, used " SIZE_FORMAT "K",
gc/parallel/psYoungGen.cpp:  st->print("  eden"); eden_space()->print_on(st);
gc/parallel/psYoungGen.cpp:  st->print("  from"); from_space()->print_on(st);
gc/parallel/psYoungGen.cpp:  st->print("  to  "); to_space()->print_on(st);
gc/parallel/mutableNUMASpace.cpp:// Bias region towards the first-touching lgrp. Set the right page sizes.
gc/parallel/mutableNUMASpace.cpp:    // And make them local/first-touch biased.
gc/parallel/mutableNUMASpace.cpp:      // If that's a system with the first-touch policy then it's enough
gc/parallel/mutableNUMASpace.cpp:  st->print(" (");
gc/parallel/mutableNUMASpace.cpp:    st->print("lgrp %d: ", lgrp_spaces()->at(i)->lgrp_id());
gc/parallel/mutableNUMASpace.cpp:      st->print(", ");
gc/parallel/mutableNUMASpace.cpp:  st->print(")");
gc/parallel/mutableNUMASpace.cpp:    st->print("    lgrp %d", ls->lgrp_id());
gc/parallel/mutableNUMASpace.cpp:      st->print("    local/remote/unbiased/uncommitted: " SIZE_FORMAT "K/"
gc/parallel/parMarkBitMap.hpp:    st->print_cr("Marking Bits: (ParMarkBitMap*) " PTR_FORMAT, p2i(this));
gc/parallel/mutableSpace.cpp:  st->print(" space " SIZE_FORMAT "K, %d%% used", capacity_in_bytes() / K,
gc/parallel/mutableSpace.cpp:  st->print_cr(" [" INTPTR_FORMAT "," INTPTR_FORMAT "," INTPTR_FORMAT ")",
gc/parallel/psAdaptiveSizePolicy.hpp:  // These variables represent linear least-squares fits of
gc/parallel/parallelScavengeHeap.cpp:  st->cr();
gc/parallel/psOldGen.cpp:  st->print(" %-15s", name());
gc/parallel/psOldGen.cpp:  st->print(" total " SIZE_FORMAT "K, used " SIZE_FORMAT "K",
gc/parallel/psOldGen.cpp:  st->print_cr(" [" INTPTR_FORMAT ", " INTPTR_FORMAT ", " INTPTR_FORMAT ")",
gc/parallel/psOldGen.cpp:  st->print("  object"); object_space()->print_on(st);
gc/z/zHeap.cpp:  st->print_cr(" ZHeap           used " SIZE_FORMAT "M, capacity " SIZE_FORMAT "M, max capacity " SIZE_FORMAT "M",
gc/z/zHeap.cpp:  st->cr();
gc/z/zHeap.cpp:  st->print_cr("ZGC Page Table:");
gc/z/zHeap.cpp:    st->print(PTR_FORMAT " is a %s oop: ", addr, ZAddress::is_good(addr) ? "good" : "bad");
gc/z/zMemory.cpp:  if (last != NULL && start == last->end()) {
gc/z/zBarrierSet.cpp:  st->print_cr("ZBarrierSet");
gc/z/zMessagePort.inline.hpp:    if (request->message() == _message && request->seqnum() < _seqnum) {
gc/z/zMessagePort.inline.hpp:      request->satisfy(_message);
gc/z/zCollectedHeap.cpp:  st->print_cr("ZGC Globals:");
gc/z/zCollectedHeap.cpp:  st->print_cr(" GlobalPhase:       %u (%s)", ZGlobalPhase, ZGlobalPhaseToString());
gc/z/zCollectedHeap.cpp:  st->print_cr(" GlobalSeqNum:      %u", ZGlobalSeqNum);
gc/z/zCollectedHeap.cpp:  st->print_cr(" Offset Max:        " SIZE_FORMAT "%s (" PTR_FORMAT ")",
gc/z/zCollectedHeap.cpp:  st->print_cr(" Page Size Small:   " SIZE_FORMAT "M", ZPageSizeSmall / M);
gc/z/zCollectedHeap.cpp:  st->print_cr(" Page Size Medium:  " SIZE_FORMAT "M", ZPageSizeMedium / M);
gc/z/zCollectedHeap.cpp:  st->cr();
gc/z/zCollectedHeap.cpp:  st->print_cr("ZGC Metadata Bits:");
gc/z/zCollectedHeap.cpp:  st->print_cr(" Good:              " PTR_FORMAT, ZAddressGoodMask);
gc/z/zCollectedHeap.cpp:  st->print_cr(" Bad:               " PTR_FORMAT, ZAddressBadMask);
gc/z/zCollectedHeap.cpp:  st->print_cr(" WeakBad:           " PTR_FORMAT, ZAddressWeakBadMask);
gc/z/zCollectedHeap.cpp:  st->print_cr(" Marked:            " PTR_FORMAT, ZAddressMetadataMarked);
gc/z/zCollectedHeap.cpp:  st->print_cr(" Remapped:          " PTR_FORMAT, ZAddressMetadataRemapped);
gc/z/zCollectedHeap.cpp:  st->cr();
gc/z/zList.inline.hpp:  if (!list->is_empty()) {
gc/z/zList.inline.hpp:    list->_head._next->_prev = _head._prev;
gc/z/zList.inline.hpp:    list->_head._prev->_next = _head._prev->_next;
gc/z/zList.inline.hpp:    _head._prev->_next = list->_head._next;
gc/z/zList.inline.hpp:    _head._prev = list->_head._prev;
gc/z/zList.inline.hpp:    list->_head._next = &list->_head;
gc/z/zList.inline.hpp:    list->_head._prev = &list->_head;
gc/z/zList.inline.hpp:    _size += list->_size;
gc/z/zList.inline.hpp:    list->_size = 0;
gc/z/zList.inline.hpp:    list->verify();
gc/z/zList.inline.hpp:    _next(Forward ? list->first() : list->last()) {}
gc/z/zList.inline.hpp:    _next = Forward ? _list->next(_next) : _list->prev(_next);
gc/z/zList.inline.hpp:  *elem = Forward ? _list->remove_first() : _list->remove_last();
gc/shared/referenceProcessor.cpp:    oop current_head = list->head();
gc/shared/referenceProcessor.cpp:    list->set_head(obj);
gc/shared/referenceProcessor.cpp:    list->inc_length(1);
gc/shared/softRefPolicy.hpp:  // Set to true by the GC if the just-completed gc cleared all
gc/shared/generation.hpp:  // Typically used to enable diagnostic output for post-mortem analysis,
gc/shared/generation.hpp:  // slow path (the only fast-path place to allocate is DefNew, which
gc/shared/generation.hpp:  // beginning allocation point post-collection, which might allow some later
gc/shared/ptrQueue.cpp:    BufferNode* next = list->next();
gc/shared/ptrQueue.cpp:    DEBUG_ONLY(list->set_next(NULL);)
gc/shared/ptrQueue.cpp:    for (BufferNode* next = first->next(); next != NULL; next = next->next()) {
gc/shared/collectedHeap.cpp:  st->print_cr("GC heap %s", m.is_before ? "before" : "after");
gc/shared/collectedHeap.cpp:  st->print_raw(m);
gc/shared/collectedHeap.cpp:  st->print_cr("Heap:");
gc/shared/collectedHeap.cpp:  st->cr();
gc/shared/c2/barrierSetC2.cpp:      st->set_unaligned_access();
gc/shared/c2/barrierSetC2.cpp:      st->set_mismatched_access();
gc/shared/c2/barrierSetC2.cpp:    // Fast-path succeeded with no contention!
gc/shared/cardTableBarrierSet.cpp:// to a newly allocated object along the fast-path. We
gc/shared/cardTableBarrierSet.cpp://     to the post-barrier, we note that G1 needs a RS update barrier
gc/shared/cardTableBarrierSet.cpp:    // Arrays of non-references don't need a post-barrier.
gc/shared/cr:adaptiveSizePolicy.cpp:      _avg_minor_gc_cost->sample(collection_cost);
gc/shared/cr:adaptiveSizePolicy.cpp:      (_avg_minor_gc_cost->count() >= AdaptiveSizePolicyReadyThreshold);
gc/shared/cr:adaptiveSizePolicy.cpp:                        collection_cost, _avg_minor_gc_cost->average());
gc/shared/cr:adaptiveSizePolicy.cpp://        time-since-last-major-gc
gc/shared/cr:adaptiveSizePolicy.cpp:// is less than time-since-last-major-gc.
gc/shared/cr:adaptiveSizePolicy.cpp:      // Decay using the time-since-last-major-gc
gc/shared/cr:adaptiveSizePolicy.hpp:  // These variables represent linear least-squares fits of
gc/shared/cr:adaptiveSizePolicy.hpp:    return MAX2(0.0F, _avg_major_gc_cost->average());
gc/shared/cr:adaptiveSizePolicy.hpp:    return MAX2(0.0F, _avg_minor_gc_cost->average());
gc/shared/cr:c2/barrierSetC2.cpp:      st->set_unaligned_access();
gc/shared/cr:c2/barrierSetC2.cpp:      st->set_mismatched_access();
gc/shared/cr:c2/barrierSetC2.cpp:    // Fast-path succeeded with no contention!
gc/shared/cr:cardTableBarrierSet.cpp:// to a newly allocated object along the fast-path. We
gc/shared/cr:cardTableBarrierSet.cpp://     to the post-barrier, we note that G1 needs a RS update barrier
gc/shared/cr:cardTableBarrierSet.cpp:    // Arrays of non-references don't need a post-barrier.
gc/shared/cr:cardTableBarrierSet.hpp:  // initialization of the object itself, and no post-store-barriers will
gc/shared/cr:cardTable.cpp:  memset(first, dirty_card, last-first);
gc/shared/cr:cardTable.cpp:  st->print_cr("Card table byte_map: [" INTPTR_FORMAT "," INTPTR_FORMAT "] _byte_map_base: " INTPTR_FORMAT,
gc/shared/cr:collectedHeap.cpp:  st->print_cr("GC heap %s", m.is_before ? "before" : "after");
gc/shared/cr:collectedHeap.cpp:  st->print_raw(m);
gc/shared/cr:collectedHeap.cpp:  st->print_cr("Heap:");
gc/shared/cr:collectedHeap.cpp:  st->cr();
gc/shared/cr:gcLogPrecious.cpp:      st->print_cr("GC Precious Log:");
gc/shared/cr:gcLogPrecious.cpp:      st->print_cr("%s", _lines->base());
gc/shared/cr:genCollectedHeap.cpp:      min_size     = smallest->num_words;
gc/shared/cr:genCollectedHeap.cpp:  *smallest_ptr = smallest->next;
gc/shared/cr:genCollectedHeap.cpp:    smallest->next  = sorted;
gc/shared/cr:genCollectedHeap.hpp:  // free-list-based heap (or subheap), as long as the two kinds are
gc/shared/cr:generation.cpp:  st->print(" %-20s", name());
gc/shared/cr:generation.cpp:  st->print(" total " SIZE_FORMAT "K, used " SIZE_FORMAT "K",
gc/shared/cr:generation.cpp:  st->print_cr(" [" INTPTR_FORMAT ", " INTPTR_FORMAT ", " INTPTR_FORMAT ")",
gc/shared/cr:generation.cpp:  st->print_cr("Accumulated %s generation GC time %3.7f secs, "
gc/shared/cr:generation.hpp:  // Typically used to enable diagnostic output for post-mortem analysis,
gc/shared/cr:generation.hpp:  // slow path (the only fast-path place to allocate is DefNew, which
gc/shared/cr:generation.hpp:  // beginning allocation point post-collection, which might allow some later
gc/shared/cr:locationPrinter.inline.hpp:        st->print(INTPTR_FORMAT " is an oop: ", p2i(addr));
gc/shared/cr:locationPrinter.inline.hpp:        st->print(INTPTR_FORMAT " is pointing into object: " , p2i(addr));
gc/shared/cr:locationPrinter.inline.hpp:    st->print_cr(INTPTR_FORMAT " is an unallocated location in the heap", p2i(addr));
gc/shared/cr:locationPrinter.inline.hpp:      st->print(UINT32_FORMAT " is a compressed pointer to object: ", narrow_oop);
gc/shared/cr:memAllocator.cpp:             "Found badHeapWordValue in post-allocation check");
gc/shared/cr:oopStorage.cpp:  // Const-ness of ptr is not related to const-ness of containing block.
gc/shared/cr:oopStorage.cpp:  st->print("%s: " SIZE_FORMAT " entries in " SIZE_FORMAT " blocks (%.F%%), " SIZE_FORMAT " bytes",
gc/shared/cr:oopStorage.cpp:    st->print(", concurrent iteration active");
gc/shared/cr:ptrQueue.cpp:    BufferNode* next = list->next();
gc/shared/cr:ptrQueue.cpp:    DEBUG_ONLY(list->set_next(NULL);)
gc/shared/cr:ptrQueue.cpp:    for (BufferNode* next = first->next(); next != NULL; next = next->next()) {
gc/shared/cr:referenceProcessor.cpp:    oop current_head = list->head();
gc/shared/cr:referenceProcessor.cpp:    list->set_head(obj);
gc/shared/cr:referenceProcessor.cpp:    list->inc_length(1);
gc/shared/cr:softRefPolicy.hpp:  // Set to true by the GC if the just-completed gc cleared all
gc/shared/cr:space.cpp:  // oop_iterate()) To be done post-beta XXX
gc/shared/cr:space.cpp:  st->print(" space " SIZE_FORMAT "K, %3d%% used", capacity() / K,
gc/shared/cr:space.cpp:  st->print_cr(" [" INTPTR_FORMAT ", " INTPTR_FORMAT ")",
gc/shared/cr:space.cpp:  st->print_cr(" [" INTPTR_FORMAT ", " INTPTR_FORMAT ", " INTPTR_FORMAT ")",
gc/shared/cr:space.cpp:  st->print_cr(" [" INTPTR_FORMAT ", " INTPTR_FORMAT ", "
gc/shared/cr:space.hpp:// free-list-based space whose normal collection is a mark-sweep without
gc/shared/cr:space.hpp:  // post-compaction addresses, and insert forwarding pointers.  The fields
gc/shared/cr:stringdedup/stringDedupTable.cpp:  size_t index = dest->hash_to_index(hash);
gc/shared/cr:stringdedup/stringDedupTable.cpp:  StringDedupEntry** list = dest->bucket(index);
gc/shared/cr:workgroup.cpp:  st->print("\"%s\" ", name());
gc/shared/cr:workgroup.cpp:  st->cr();
gc/shared/space.cpp:  // oop_iterate()) To be done post-beta XXX
gc/shared/space.cpp:  st->print(" space " SIZE_FORMAT "K, %3d%% used", capacity() / K,
gc/shared/space.cpp:  st->print_cr(" [" INTPTR_FORMAT ", " INTPTR_FORMAT ")",
gc/shared/space.cpp:  st->print_cr(" [" INTPTR_FORMAT ", " INTPTR_FORMAT ", " INTPTR_FORMAT ")",
gc/shared/space.cpp:  st->print_cr(" [" INTPTR_FORMAT ", " INTPTR_FORMAT ", "
gc/shared/locationPrinter.inline.hpp:        st->print(INTPTR_FORMAT " is an oop: ", p2i(addr));
gc/shared/locationPrinter.inline.hpp:        st->print(INTPTR_FORMAT " is pointing into object: " , p2i(addr));
gc/shared/locationPrinter.inline.hpp:    st->print_cr(INTPTR_FORMAT " is an unallocated location in the heap", p2i(addr));
gc/shared/locationPrinter.inline.hpp:      st->print(UINT32_FORMAT " is a compressed pointer to object: ", narrow_oop);
gc/shared/cardTableBarrierSet.hpp:  // initialization of the object itself, and no post-store-barriers will
gc/shared/adaptiveSizePolicy.cpp:      _avg_minor_gc_cost->sample(collection_cost);
gc/shared/adaptiveSizePolicy.cpp:      (_avg_minor_gc_cost->count() >= AdaptiveSizePolicyReadyThreshold);
gc/shared/adaptiveSizePolicy.cpp:                        collection_cost, _avg_minor_gc_cost->average());
gc/shared/adaptiveSizePolicy.cpp://        time-since-last-major-gc
gc/shared/adaptiveSizePolicy.cpp:// is less than time-since-last-major-gc.
gc/shared/adaptiveSizePolicy.cpp:      // Decay using the time-since-last-major-gc
gc/shared/stringdedup/stringDedupTable.cpp:  size_t index = dest->hash_to_index(hash);
gc/shared/stringdedup/stringDedupTable.cpp:  StringDedupEntry** list = dest->bucket(index);
gc/shared/adaptiveSizePolicy.hpp:  // These variables represent linear least-squares fits of
gc/shared/adaptiveSizePolicy.hpp:    return MAX2(0.0F, _avg_major_gc_cost->average());
gc/shared/adaptiveSizePolicy.hpp:    return MAX2(0.0F, _avg_minor_gc_cost->average());
gc/shared/gcLogPrecious.cpp:      st->print_cr("GC Precious Log:");
gc/shared/gcLogPrecious.cpp:      st->print_cr("%s", _lines->base());
gc/shared/space.hpp:// free-list-based space whose normal collection is a mark-sweep without
gc/shared/space.hpp:  // post-compaction addresses, and insert forwarding pointers.  The fields
gc/shared/workgroup.cpp:  st->print("\"%s\" ", name());
gc/shared/workgroup.cpp:  st->cr();
gc/shared/generation.cpp:  st->print(" %-20s", name());
gc/shared/generation.cpp:  st->print(" total " SIZE_FORMAT "K, used " SIZE_FORMAT "K",
gc/shared/generation.cpp:  st->print_cr(" [" INTPTR_FORMAT ", " INTPTR_FORMAT ", " INTPTR_FORMAT ")",
gc/shared/generation.cpp:  st->print_cr("Accumulated %s generation GC time %3.7f secs, "
gc/shared/genCollectedHeap.cpp:      min_size     = smallest->num_words;
gc/shared/genCollectedHeap.cpp:  *smallest_ptr = smallest->next;
gc/shared/genCollectedHeap.cpp:    smallest->next  = sorted;
gc/shared/cardTable.cpp:  memset(first, dirty_card, last-first);
gc/shared/cardTable.cpp:  st->print_cr("Card table byte_map: [" INTPTR_FORMAT "," INTPTR_FORMAT "] _byte_map_base: " INTPTR_FORMAT,
gc/shared/memAllocator.cpp:             "Found badHeapWordValue in post-allocation check");
gc/shared/oopStorage.cpp:  // Const-ness of ptr is not related to const-ness of containing block.
gc/shared/oopStorage.cpp:  st->print("%s: " SIZE_FORMAT " entries in " SIZE_FORMAT " blocks (%.F%%), " SIZE_FORMAT " bytes",
gc/shared/oopStorage.cpp:    st->print(", concurrent iteration active");
gc/shared/genCollectedHeap.hpp:  // free-list-based heap (or subheap), as long as the two kinds are
gc/g1/heapRegionManager.hpp:  // Start and end defines the range to seek in, policy is first-fit.
gc/g1/heapRegionSet.inline.hpp:    if (_last != NULL && _last->hrm_index() < hr->hrm_index()) {
gc/g1/heapRegionSet.cpp:  from_list->check_mt_safety();
gc/g1/heapRegionSet.cpp:  from_list->verify_optional();
gc/g1/heapRegionSet.cpp:  if (from_list->is_empty()) {
gc/g1/heapRegionSet.cpp:  if (_node_info != NULL && from_list->_node_info != NULL) {
gc/g1/heapRegionSet.cpp:    _node_info->add(from_list->_node_info);
gc/g1/heapRegionSet.cpp:  _length += from_list->length();
gc/g1/heapRegionSet.cpp:  from_list->clear();
gc/g1/heapRegionSet.cpp:  from_list->verify_optional();
gc/g1/heapRegionSet.cpp:  if (from_list->is_empty()) {
gc/g1/heapRegionSet.cpp:    _head = from_list->_head;
gc/g1/heapRegionSet.cpp:    _tail = from_list->_tail;
gc/g1/heapRegionSet.cpp:    assert(_tail->hrm_index() < from_list->_head->hrm_index(), "Should be sorted %u < %u",
gc/g1/heapRegionSet.cpp:           _tail->hrm_index(), from_list->_head->hrm_index());
gc/g1/heapRegionSet.cpp:    _tail->set_next(from_list->_head);
gc/g1/heapRegionSet.cpp:    from_list->_head->set_prev(_tail);
gc/g1/heapRegionSet.cpp:    _tail = from_list->_tail;
gc/g1/heapRegionSet.cpp:  if (from_list->is_empty()) {
gc/g1/heapRegionSet.cpp:    _head = from_list->_head;
gc/g1/heapRegionSet.cpp:    _tail = from_list->_tail;
gc/g1/heapRegionSet.cpp:    HeapRegion* curr_from = from_list->_head;
gc/g1/heapRegionSet.cpp:    if (_tail->hrm_index() < from_list->_tail->hrm_index()) {
gc/g1/heapRegionSet.cpp:      _tail = from_list->_tail;
gc/g1/g1ParScanThreadState.cpp:  assert(dest->is_in_cset_or_humongous(), "Unexpected dest: %s region attr", dest->get_type_str());
gc/g1/g1ParScanThreadState.cpp:  if (dest->is_young()) {
gc/g1/g1ParScanThreadState.cpp:      dest->set_old();
gc/g1/g1ParScanThreadState.cpp:    assert(dest->is_old(), "Unexpected dest region attr: %s", dest->get_type_str());
gc/g1/sparsePRT.cpp:    _table = new RSHashTable(last->capacity() * 2);
gc/g1/sparsePRT.cpp:    for (size_t i = 0; i < last->num_entries(); i++) {
gc/g1/sparsePRT.cpp:      SparsePRTEntry* e = last->entry((int)i);
Binary file gc/g1/.g1CollectedHeap.hpp.swp matches
gc/g1/g1CollectionSet.cpp:    _st->print_cr("  " HR_FORMAT ", P: " PTR_FORMAT "N: " PTR_FORMAT ", age: %4d",
gc/g1/g1CollectionSet.cpp:  st->print_cr("\nCollection_set:");
gc/g1/heapRegionManager.cpp:        free_list->add_to_tail(region);
gc/g1/g1Allocator.cpp:    assert(mutator_alloc_region(i)->get() == NULL, "post-condition");
gc/g1/g1Policy.cpp:  assert(young_list_target_length >= absolute_min_length, "post-condition");
gc/g1/g1Policy.cpp:      // These are the post-conditions of the binary search above:
gc/g1/g1Policy.cpp:  assert(_young_list_target_length <= _young_list_max_length, "post-condition");
gc/g1/heapRegionSet.hpp:    _list->verify_region(hr);
gc/g1/heapRegionSet.hpp:    _curr(list->_head) {
gc/g1/g1RemSet.cpp:    _opt_refs_scanned += opt_rem_set_list->oops_do(&cl, _pss->closures()->strong_oops());
gc/g1/g1RemSet.cpp:    _opt_refs_memory_used += opt_rem_set_list->used_memory();
gc/g1/g1RemSet.cpp:  // distinctly marked (set to g1_young_gen), so the post-barrier will
gc/g1/c2/g1BarrierSetC2.cpp: * post-barrier.
gc/g1/c2/g1BarrierSetC2.cpp: * To reduce the number of updates to the remembered set the post-barrier
gc/g1/c2/g1BarrierSetC2.cpp: * post-barrier completely if it is possible during compile time to prove
gc/g1/g1_globals.hpp:          "filtering on the SATB buffers it generates. If post-filtering "  \
gc/g1/g1ConcurrentMark.cpp:    _chunks_in_chunk_list--;
gc/g1/g1ConcurrentMark.cpp:    _g1h(g1h), _cm(cm), _hrclaimer(num_workers), _total_selected_for_rebuild(0), _cl("Post-Marking") { }
gc/g1/g1ConcurrentMark.cpp:      _cleanup_list->add_ordered(&local_cleanup_list);
gc/g1/g1ConcurrentMark.cpp:      assert(local_cleanup_list.is_empty(), "post-condition");
gc/g1/g1ConcurrentMark.cpp:    G1PrintRegionLivenessInfoClosure cl("Post-Cleanup");
gc/g1/g1ConcurrentMark.cpp:  st->print_cr("Marking Bits (Prev, Next): (CMBitMap*) " PTR_FORMAT ", (CMBitMap*) " PTR_FORMAT,
gc/g1/g1CollectedHeap.hpp:  // First-level mutator allocation attempt: try to allocate out of
gc/g1/g1CollectedHeap.hpp:  // True iff an evacuation has failed in the most-recent collection.
gc/g1/g1CollectedHeap.hpp:  // free-list-based heap (or subheap), as long as the two kinds are
gc/g1/g1OopStarChunkedList.inline.hpp:  } else if (list->is_full()) {
gc/g1/g1DirtyCardQueue.cpp:      // it may have already performed its list-was-empty update of _head,
gc/g1/g1DirtyCardQueue.cpp:  assert(plist->is_next(), "invariant");
gc/g1/g1DirtyCardQueue.cpp:  plist->add(node);
gc/g1/g1DirtyCardQueue.cpp:    result = plist->take();
gc/g1/g1AllocRegion.cpp:         "post-condition");
gc/g1/g1AllocRegion.cpp:  assert_alloc_region(_alloc_region == _dummy_region, "post-condition of retire()");
gc/g1/heapRegionRemSet.hpp:      last->set_next(fl);
gc/g1/g1NUMA.cpp:  _inst->initialize(UseNUMA);
gc/g1/g1NUMA.cpp:  _inst->initialize(false);
gc/g1/g1HeapVerifier.cpp:    guarantee(free_list->num_free_regions() == _free_count, "Free list count mismatch. Expected %u, actual %u.", free_list->num_free_regions(), _free_count);
gc/g1/heapRegion.cpp:  st->print("|%4u", this->_hrm_index);
gc/g1/heapRegion.cpp:  st->print("|" PTR_FORMAT ", " PTR_FORMAT ", " PTR_FORMAT,
gc/g1/heapRegion.cpp:  st->print("|%3d%%", (int) ((double) used() * 100 / capacity()));
gc/g1/heapRegion.cpp:  st->print("|%2s", get_short_type_str());
gc/g1/heapRegion.cpp:  //st->print("|objs %zd", object_num);
gc/g1/heapRegion.cpp:    st->print("|CS");
gc/g1/heapRegion.cpp:    st->print("|  ");
gc/g1/heapRegion.cpp:  st->print("|TAMS " PTR_FORMAT ", " PTR_FORMAT "| %s ",
gc/g1/heapRegion.cpp:      st->print("|%d", numa->numa_id(node_index()));
gc/g1/heapRegion.cpp:      st->print("|-");
gc/g1/heapRegion.cpp:  st->print_cr("");
gc/g1/g1CollectedHeap.cpp:  // We should only get here after the first-level allocation attempt
gc/g1/g1CollectedHeap.cpp:    assert(actual_expand_bytes <= aligned_expand_bytes, "post-condition");
gc/g1/g1CollectedHeap.cpp:    // to 0 which means that we are not requesting a post-GC allocation.
gc/g1/g1CollectedHeap.cpp:  st->print(" %-20s", "garbage-first heap");
gc/g1/g1CollectedHeap.cpp:    st->print(" total " SIZE_FORMAT "K, used " SIZE_FORMAT "K",
gc/g1/g1CollectedHeap.cpp:    st->print(" [" PTR_FORMAT ", " PTR_FORMAT ")",
gc/g1/g1CollectedHeap.cpp:  st->cr();
gc/g1/g1CollectedHeap.cpp:  st->print("  region size " SIZE_FORMAT "K, ", HeapRegion::GrainBytes / K);
gc/g1/g1CollectedHeap.cpp:  st->print("%u young (" SIZE_FORMAT "K), ", young_regions,
gc/g1/g1CollectedHeap.cpp:  st->print("%u survivors (" SIZE_FORMAT "K)", survivor_regions,
gc/g1/g1CollectedHeap.cpp:  st->cr();
gc/g1/g1CollectedHeap.cpp:    st->print("  remaining free region(s) on each NUMA node: ");
gc/g1/g1CollectedHeap.cpp:      st->print("%d=%u ", node_ids[node_index], num_free_regions);
gc/g1/g1CollectedHeap.cpp:    st->cr();
gc/g1/g1CollectedHeap.cpp:  st->print_cr("Heap Regions: E=young(eden), S=young(survivor), O=old, "
gc/g1/g1CollectedHeap.cpp:    st->cr();
gc/g1/g1CollectedHeap.cpp:    st->cr();
gc/g1/g1CollectedHeap.cpp:  st->print_raw_cr("GC Task Stats");
gc/g1/g1CollectedHeap.cpp:  st->print_raw("thr "); TaskQueueStats::print_header(1, st); st->cr();
gc/g1/g1CollectedHeap.cpp:  st->print_raw("--- "); TaskQueueStats::print_header(2, st); st->cr();
gc/g1/g1CollectedHeap.cpp:    st->print("%3u ", i); task_queue(i)->stats.print(st); st->cr();
gc/g1/g1CollectedHeap.cpp:  st->print_raw("tot "); totals.print(st); st->cr();
gc/g1/g1CollectedHeap.cpp:// record the durations of the phases. Hence the almost-copy.
gc/g1/g1CollectedHeap.cpp:    free_list->add_ordered(hr);
gc/g1/g1CollectedHeap.cpp:  if (!list->is_empty()) {
gc/g1/g1CollectedHeap.cpp:    assert(_old_set->is_empty(), "post-condition");
gc/g1/g1AllocRegion.hpp:// implementation assumes that fast-path allocations will be lock-free
gc/g1/g1AllocRegion.hpp:  // First-level allocation: Should be called without holding a
gc/epsilon/epsilonHeap.cpp:  st->print_cr("Epsilon Heap");
gc/epsilon/epsilonHeap.cpp:    st->print_cr("Allocation space:");
gc/serial/defNewGeneration.cpp:  st->print("  eden");
gc/serial/defNewGeneration.cpp:  st->print("  from");
gc/serial/defNewGeneration.cpp:  st->print("  to  ");
gc/serial/defNewGeneration.cpp:  // Most allocations are fast-path in compiled code.
gc/serial/tenuredGeneration.cpp:  st->print("   the");
include/jvm.h: * least-recently-inspected heap object was last inspected by the garbage
interpreter/bytecodeTracer.cpp:      st->cr();
interpreter/bytecodeTracer.cpp:      st->print("[%ld] ", (long) Thread::current()->osthread()->thread_id());
interpreter/bytecodeTracer.cpp:      st->cr();
interpreter/bytecodeTracer.cpp:    st->print("[%ld] ", (long) Thread::current()->osthread()->thread_id());
interpreter/bytecodeTracer.cpp:      st->print("%8d  %4d  " INTPTR_FORMAT " " INTPTR_FORMAT " %s",
interpreter/bytecodeTracer.cpp:      st->print("%8d  %4d  %s",
interpreter/bytecodeTracer.cpp:      st->print("%d %s_w", bci, Bytecodes::name(code));
interpreter/bytecodeTracer.cpp:      st->print("%d %s", bci, Bytecodes::name(code));
interpreter/bytecodeTracer.cpp:    st->print_cr(" %s...[%d]", sym->as_C_string(buf, sizeof(buf)), len);
interpreter/bytecodeTracer.cpp:    st->print(" ");
interpreter/bytecodeTracer.cpp:    sym->print_on(st); st->cr();
interpreter/bytecodeTracer.cpp:    st->print_cr(" NULL");
interpreter/bytecodeTracer.cpp:      st->print_cr(" %s...[%d]", buf, len);
interpreter/bytecodeTracer.cpp:      st->print_cr(" %s", buf);
interpreter/bytecodeTracer.cpp:    st->print_cr(" " INTPTR_FORMAT, p2i((void *)value));
interpreter/bytecodeTracer.cpp:    if (WizardMode)  st->print(" cp[%d]", cp_index);
interpreter/bytecodeTracer.cpp:  st->print_cr(" CP[%d] not in CP", cp_index);
interpreter/bytecodeTracer.cpp:      st->print_cr(" CP[%d] missing bias?", i);
interpreter/bytecodeTracer.cpp:    st->print_cr("%d not in CP[*]?", i);
interpreter/bytecodeTracer.cpp:    st->print_cr("%d not in OBJ[*]?", i);
interpreter/bytecodeTracer.cpp:    st->print_cr(" " INT32_FORMAT, constants->int_at(i));
interpreter/bytecodeTracer.cpp:    st->print_cr(" " INT64_FORMAT, (int64_t)(constants->long_at(i)));
interpreter/bytecodeTracer.cpp:    st->print_cr(" %f", constants->float_at(i));
interpreter/bytecodeTracer.cpp:    st->print_cr(" %f", constants->double_at(i));
interpreter/bytecodeTracer.cpp:    st->print_cr(" %s", string);
interpreter/bytecodeTracer.cpp:    st->print_cr(" %s", constants->resolved_klass_at(i)->external_name());
interpreter/bytecodeTracer.cpp:    st->print_cr(" <unresolved klass at %d>", i);
interpreter/bytecodeTracer.cpp:    st->print(" <MethodType> %d", i2);
interpreter/bytecodeTracer.cpp:    st->print(" <MethodHandle of kind %d index at %d>", kind, i2);
interpreter/bytecodeTracer.cpp:    st->print_cr(" bad tag=%d at %d", tag.value(), i);
interpreter/bytecodeTracer.cpp:    st->print_cr(" bad tag=%d at %d", tag.value(), i);
interpreter/bytecodeTracer.cpp:    st->print_cr(" %d <%s.%s%s%s> ", i, klass->as_C_string(), name->as_C_string(), sep, signature->as_C_string());
interpreter/bytecodeTracer.cpp:      st->print(" bsm=%d", bsm);
interpreter/bytecodeTracer.cpp:    st->print_cr(" %d <%s%s%s>", i, name->as_C_string(), sep, signature->as_C_string());
interpreter/bytecodeTracer.cpp:    st->cr();
interpreter/bytecodeTracer.cpp:      st->print_cr(" " INT32_FORMAT, get_byte());
interpreter/bytecodeTracer.cpp:      st->print_cr(" " INT32_FORMAT, get_short());
interpreter/bytecodeTracer.cpp:      st->print_cr(" #%d", get_index_special());
interpreter/bytecodeTracer.cpp:        st->print_cr(" #%d " INT32_FORMAT, index, offset);
interpreter/bytecodeTracer.cpp:        st->print_cr(" %s", str);
interpreter/bytecodeTracer.cpp:        st->print_cr(" %s ", name->as_C_string());
interpreter/bytecodeTracer.cpp:        st->print_cr(" %s %d", name->as_C_string(), nof_dims);
interpreter/bytecodeTracer.cpp:      st->print_cr(" %d", bci + get_short());
interpreter/bytecodeTracer.cpp:      st->print_cr(" %d", bci + get_int());
interpreter/bytecodeTracer.cpp:    case Bytecodes::_ret: st->print_cr(" %d", get_index_special()); break;
interpreter/bytecodeTracer.cpp:        st->print(" %d " INT32_FORMAT " " INT32_FORMAT " ",
interpreter/bytecodeTracer.cpp:          st->print("%s %d:" INT32_FORMAT " (delta: %d)", comma, ll, dest[idx], dest[idx]-bci);
interpreter/bytecodeTracer.cpp:        st->cr();
interpreter/bytecodeTracer.cpp:        st->print(" %d %d ", default_dest, len);
interpreter/bytecodeTracer.cpp:          st->print("%s " INT32_FORMAT ":" INT32_FORMAT, comma, key[ll], dest[ll]);
interpreter/bytecodeTracer.cpp:        st->cr();
interpreter/bytecodeTracer.cpp:        st->print_cr(" %d <%s>", i, name->as_C_string());
interpreter/bytecodeTracer.cpp:      st->print("  %d", mdo->dp_to_di(data->dp()));
interpreter/bytecodeTracer.cpp:      st->fill_to(6);
interpreter/bootstrapInfo.cpp:  st->print_cr("%s%sBootstrap in %s %s@CP[%d] %s:%s%s BSMS[%d] BSM@CP[%d]%s argc=%d%s",
interpreter/bootstrapInfo.cpp:    st->print_cr("  argument indexes: {%s}", argbuf);
interpreter/bootstrapInfo.cpp:    st->print("  resolved BSM: "); _bsm->print_on(st);
interpreter/bootstrapInfo.cpp:      st->print("  resolved arg[0]: "); static_args->print_on(st);
interpreter/bootstrapInfo.cpp:            st->print_cr("  resolved arg[%d]: ...", i);
interpreter/bootstrapInfo.cpp:          st->print("  resolved arg[%d]: ", i); x->print_on(st);
interpreter/bootstrapInfo.cpp:      st->print_cr("  resolved arg[0]: %d", tmp_array->int_at(0));
interpreter/bootstrapInfo.cpp:      st->print_cr("  resolved arg[1]: %d", tmp_array->int_at(1));
interpreter/interpreter.cpp:    st->cr();
interpreter/interpreter.cpp:    st->print_cr("----------------------------------------------------------------------");
interpreter/interpreter.cpp:  if (description() != NULL) st->print("%s  ", description());
interpreter/interpreter.cpp:  if (bytecode()    >= 0   ) st->print("%d %s  ", bytecode(), Bytecodes::name(bytecode()));
interpreter/interpreter.cpp:  st->print_cr("[" INTPTR_FORMAT ", " INTPTR_FORMAT "]  %d bytes",
interpreter/interpreter.cpp:    st->cr();
interpreter/bootstrapInfo.hpp:  // post-bootstrap resolution state:
interpreter/bootstrapInfo.hpp:  // setters for post-bootstrap results:
interpreter/bytecodes.cpp:  assert(can_rewrite(code), "post-check only");
interpreter/zero/bytecodeInterpreter.cpp:            // Disable non-TLAB-based fast-path, because profiling requires that all
interpreter/linkResolver.cpp:  st->print("%s%s, compile-time-class:%s, method:%s, method_holder:%s, access_flags: ",
interpreter/linkResolver.cpp:    st->print("vtable_index:%d", index);
interpreter/linkResolver.cpp:  st->cr();
interpreter/linkResolver.cpp:  // from nest-host resolution, have been allowed to propagate.
jfr/leakprofiler/sampling/objectSampler.cpp:    assert(_list->count() == _size, "invariant");
jfr/leakprofiler/sampling/objectSampler.cpp:    sample = _list->reuse(_priority_queue->pop());
jfr/leakprofiler/sampling/objectSampler.cpp:    sample = _list->get();
jfr/leakprofiler/sampling/objectSampler.cpp:  ObjectSample* current = _list->last();
jfr/leakprofiler/sampling/objectSampler.cpp:  _list->release(sample);
jfr/leakprofiler/sampling/objectSampler.cpp:  return _list->last();
jfr/leakprofiler/sampling/objectSampler.cpp:  return _list->first();
jfr/leakprofiler/sampling/objectSampler.cpp:  return _list->last_resolved();
jfr/leakprofiler/sampling/objectSampler.cpp:  _list->set_last_resolved(sample);
jfr/leakprofiler/checkpoint/rootResolver.cpp:    for (int i = 0; i < list->length(); i++) {
jfr/leakprofiler/checkpoint/rootResolver.cpp:      list->at(i)->oops_do(&rcl);
jfr/instrumentation/jfrEventClassTransformer.cpp:  // post-increment number_of_new_constants
jfr/periodic/sampling/jfrThreadSampler.cpp:  assert(_cur_index >= -1 && (uint)_cur_index + 1 <= t_list->length(), "invariant");
jfr/periodic/sampling/jfrThreadSampler.cpp:  assert((current == NULL && -1 == _cur_index) || (t_list->find_index_of_JavaThread(current) == _cur_index), "invariant");
jfr/periodic/sampling/jfrThreadSampler.cpp:  if ((uint)_cur_index + 1 == t_list->length()) {
jfr/periodic/sampling/jfrThreadSampler.cpp:  assert(_cur_index >= 0 && (uint)_cur_index < t_list->length(), "invariant");
jfr/periodic/sampling/jfrThreadSampler.cpp:  JavaThread* const next = t_list->thread_at(_cur_index);
jfr/utilities/jfrConcurrentLinkedListHost.inline.hpp:  if (Atomic::load_acquire(&last->_next) == predecessor) {
jfr/utilities/jfrConcurrentLinkedListHost.inline.hpp:    /* Even after we store the new node into the last->_next field, there is no race
jfr/utilities/jfrConcurrentLinkedListHost.inline.hpp:    last->_next = node;
jfr/utilities/jfrConcurrentLinkedListHost.inline.hpp:    last->_next = node;
jfr/utilities/jfrConcurrentLinkedListHost.inline.hpp:  if (last != NULL && Atomic::load_acquire(&last->_next) == successor) {
jfr/utilities/jfrConcurrentQueue.inline.hpp:  return _list != NULL && _list->initialize();
jfr/utilities/jfrConcurrentQueue.inline.hpp:  _list->insert_tail(node, &_head, &_last, &_tail);
jfr/utilities/jfrConcurrentQueue.inline.hpp:  return _list->remove(&_head, &_tail, &_last, false);
jfr/utilities/jfrConcurrentQueue.inline.hpp:  _list->iterate(&_head, &_tail, cb);
jfr/utilities/jfrConcurrentQueue.inline.hpp:  return _list->in_list(node, const_cast<NodePtr>(&_head), &_tail);
jfr/recorder/checkpoint/jfrCheckpointManager.cpp:  _global_mspace =  create_mspace<JfrCheckpointMspace, JfrCheckpointManager>(global_buffer_size, 0, 0, false, this); // post-pone preallocation
jfr/recorder/checkpoint/jfrCheckpointManager.cpp: * The buffer is effectively invalidated for the thread post-return,
jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp:    for (int i = 0; i < _klass_list->length(); ++i) {
jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp:      if (!functor(_klass_list->at(i))) {
jfr/recorder/checkpoint/types/jfrTypeSetUtils.cpp:  return _klass_list->is_nonempty();
jfr/recorder/checkpoint/types/jfrTypeSetUtils.cpp:  return _klass_list->length();
jfr/recorder/checkpoint/types/jfrTypeSetUtils.cpp:  _klass_list->append(k);
jfr/recorder/checkpoint/types/jfrThreadGroup.cpp:    for (int i = 0; i < _list->length(); i++) {
jfr/recorder/checkpoint/types/jfrThreadGroup.cpp:      JfrThreadGroupEntry* e = _list->at(i);
jfr/recorder/checkpoint/types/jfrThreadGroup.cpp:  for (int index = 0; index < _list->length(); ++index) {
jfr/recorder/checkpoint/types/jfrThreadGroup.cpp:    JfrThreadGroupEntry* curtge = _list->at(index);
jfr/recorder/checkpoint/types/jfrThreadGroup.cpp:  return _list->append(tge);
jfr/recorder/checkpoint/types/jfrThreadGroup.cpp:  assert(_list != NULL && !_list->is_empty(), "should not need be here!");
jfr/recorder/checkpoint/types/jfrThreadGroup.cpp:  const int number_of_tg_entries = _list->length();
jfr/recorder/checkpoint/types/jfrThreadGroup.cpp:    const JfrThreadGroupEntry* const curtge = _list->at(index);
jfr/recorder/checkpoint/types/jfrThreadGroup.cpp:  assert(_list != NULL && !_list->is_empty(), "should not need be here!");
jfr/recorder/checkpoint/types/jfrThreadGroup.cpp:  const int number_of_tg_entries = _list->length();
jfr/recorder/checkpoint/types/jfrThreadGroup.cpp:    const JfrThreadGroupEntry* const curtge = _list->at(index);
jfr/recorder/storage/jfrEpochStorage.hpp: * all buffers will be reinitialized post-callback, with retired buffers reclaimed
jfr/recorder/storage/jfrEpochStorage.hpp: * Setting EagerReclaim to true, retired buffers will be reclaimed post-callback, by reinitialization
jfr/recorder/storage/jfrFullStorage.inline.hpp:  while (_free_node_list->is_nonempty()) {
jfr/recorder/storage/jfrFullStorage.inline.hpp:    node = _free_node_list->remove();
jfr/recorder/storage/jfrFullStorage.inline.hpp:  if (_free_node_list == NULL || !_free_node_list->initialize()) {
jfr/recorder/storage/jfrFullStorage.inline.hpp:    _free_node_list->add(node);
jfr/recorder/storage/jfrFullStorage.inline.hpp:  NodePtr node = _free_node_list->remove();
jfr/recorder/storage/jfrFullStorage.inline.hpp:  _free_node_list->add(node);
jfr/recorder/storage/jfrStorage.cpp:  return _full_list != NULL && _full_list->initialize(num_global_buffers * 2);
jfr/recorder/storage/jfrStorage.cpp:* The buffer is effectively invalidated for the thread post-return,
jfr/recorder/storage/jfrStorage.cpp:  if (_full_list->add(buffer)) {
jfr/recorder/storage/jfrStorage.cpp:    while (_full_list->is_nonempty()) {
jfr/recorder/storage/jfrStorage.cpp:      BufferPtr oldest = _full_list->remove();
jfr/recorder/storage/jfrStorage.cpp:      assert(oldest->identity() != NULL, "invariant");
jfr/recorder/storage/jfrStorage.cpp:      discarded_size += oldest->discard();
jfr/recorder/storage/jfrStorage.cpp:      assert(oldest->unflushed_size() == 0, "invariant");
jfr/recorder/storage/jfrStorage.cpp:      if (oldest->transient()) {
jfr/recorder/storage/jfrStorage.cpp:      oldest->reinitialize();
jfr/recorder/storage/jfrStorage.cpp:      assert(!oldest->retired(), "invariant");
jfr/recorder/storage/jfrStorage.cpp:      oldest->release(); // publish
jfr/recorder/storage/jfrStorage.cpp:  assert(list->is_nonempty(), "invariant");
jfr/recorder/storage/jfrStorage.cpp:    BufferPtr full = list->remove();
jfr/recorder/storage/jfrStorage.cpp:  } while (list->is_nonempty());
jfr/recorder/storage/jfrStorage.cpp:  if (_full_list->is_empty()) {
jfr/recorder/storage/jfrStorage.cpp:  if (_full_list->is_empty()) {
jfr/recorder/stringpool/jfrStringPool.cpp:* The buffer is effectively invalidated for the thread post-return,
jfr/recorder/repository/jfrEmergencyDump.cpp:    st->print_raw("# JFR recording file will be written. Location: ");
jfr/recorder/repository/jfrEmergencyDump.cpp:    st->print_raw_cr(_path_buffer);
jfr/recorder/repository/jfrEmergencyDump.cpp:    st->print_raw_cr("#");
jfr/recorder/repository/jfrEmergencyDump.cpp:    st->print_raw("# The JFR repository may contain useful JFR files. Location: ");
jfr/recorder/repository/jfrEmergencyDump.cpp:    st->print_raw_cr(repository_path);
jfr/recorder/repository/jfrEmergencyDump.cpp:    st->print_raw_cr("#");
jfr/recorder/repository/jfrEmergencyDump.cpp:    st->print_raw("# Unable to create a JFR recording file at location: ");
jfr/recorder/repository/jfrEmergencyDump.cpp:    st->print_raw_cr(_path_buffer);
jfr/recorder/repository/jfrEmergencyDump.cpp:    st->print_raw_cr("#");
jfr/jni/jfrJavaSupport.cpp:    for (int i = 0; i < exclusion_list->length(); ++i) {
jfr/jni/jfrJavaSupport.cpp:      if (equals(exclusion_list->at(i), thread)) {
jfr/jni/jfrJavaSupport.cpp:  const int idx = exclusion_list->append(ref);
jfr/jni/jfrJavaSupport.cpp:  assert(idx < exclusion_list->length(), "invariant");
jfr/jni/jfrJavaSupport.cpp:  JfrJavaSupport::destroy_global_weak_jni_handle(exclusion_list->at(idx));
jfr/jni/jfrJavaSupport.cpp:  exclusion_list->delete_at(idx);
jfr/jni/jfrJavaSupport.cpp:  if (0 == exclusion_list->length()) {
jvmci/jvmciJavaClasses.cpp:    st->print_cr("field %s %s %s", class_name, name, signature);
jvmci/jvmciJavaClasses.cpp:    st->print_cr("class %s", current_class_name);                                           \
jvmci/jvmciJavaClasses.cpp:      st->print_cr("method %s %s %s", current_class_name, methodName, signature);              \
jvmci/jvmciJavaClasses.cpp:              _st->print_cr("class %s", class_name);
jvmci/jvmciJavaClasses.cpp:            _st->print_cr("method %s %s %s", class_name, m->name()->as_C_string(), m->signature()->as_C_string());
jvmci/jvmciJavaClasses.cpp:    st->print_cr("field %s value %s", current_class_name, #type);                                                 \
jvmci/jvmciJavaClasses.cpp:    st->print_cr("method %s <init> (%s)V", current_class_name, #type);                                            \
jvmci/jvmciJavaClasses.cpp:    st->print_cr("class [B");
jvmci/jvmciJavaClasses.cpp:      st->print_cr("method %s %s %s", current_class_name, m->name()->as_C_string(), m->signature()->as_C_string()); \
jvmci/jvmciJavaClasses.cpp:    st->flush();
jvmci/jvmciRuntime.cpp:  // the dominant fast-path is to simply return.
jvmci/metadataHandles.hpp:    if (_last->_top < MetadataHandleBlock::block_size_in_handles) {
jvmci/metadataHandles.hpp:      return &(_last->_handles)[_last->_top++];
jvmci/metadataHandles.cpp:  if (_last->_next != NULL) {
jvmci/metadataHandles.cpp:    _last = _last->_next;
jvmci/metadataHandles.cpp:    _last->_next = new MetadataHandleBlock();
jvmci/metadataHandles.cpp:    _last = _last->_next;
jvmci/jvmciCodeInstaller.cpp:  JVMCIEnv* JVMCIENV = _code_inst->jvmci_env();
logging/logConfiguration.hpp:  // Perform necessary post-initialization after VM startup. Enables reconfiguration of logging.
logging/logOutputList.hpp:      itr._list->increase_readers();
logging/logOutputList.hpp:        rhs._list->increase_readers();
logging/logOutputList.hpp:        _list->decrease_readers();
logging/logOutputList.hpp:      _list->decrease_readers();
memory/arena.cpp:      _first = _first->next();
memory/arena.cpp:    char* end = _first->next() ? _first->top() : _hwm;
memory/arena.cpp:    free_malloced_objects(_first, _first->bottom(), end, _hwm);
memory/arena.cpp:  _first->chop();
memory/universe.cpp:  int list_length = list->length();
memory/universe.cpp:    Klass* k = list->at(i);
memory/universe.cpp:  st->print_cr("Heap");
memory/heap.cpp:  FreeBlock* cur  = _freelist->link();
memory/heap.cpp:  // Search for best-fitting block
memory/heap.cpp:      _freelist = _freelist->link();
memory/metaspace.cpp:  return list == NULL ? 0 : list->free_bytes();
memory/metaspace.cpp:  return list == NULL ? 0 : list->reserved_bytes();
memory/metaspace.cpp:  return list == NULL ? 0 : list->committed_bytes();
memory/metaspace.cpp:    address base = (address)_class_space_list->current_virtual_space()->bottom();
memory/metaspace.cpp:    st->print("Compressed class space mapped at: " PTR_FORMAT "-" PTR_FORMAT ", size: " SIZE_FORMAT,
memory/metaspace.cpp:    st->cr();
memory/metaspace.cpp:  if (!_class_space_list->initialization_succeeded()) {
memory/metaspace.cpp:  if (!_space_list->initialization_succeeded()) {
memory/freeList.inline.hpp:  st->print("%16s\t", c);
memory/freeList.inline.hpp:  st->print("%14s\t"    "%14s\t"    "%14s\t"    "%14s\t"    "%14s\t"
memory/freeList.inline.hpp:    st->print("%16s", c);
memory/freeList.inline.hpp:    st->print(SIZE_FORMAT_W(16), size());
memory/binaryTreeDictionary.inline.hpp:  assert(!list || list != list->next(), "Chunk on list twice");
memory/binaryTreeDictionary.inline.hpp:  st->print_cr("Statistics for BinaryTreeDictionary:");
memory/binaryTreeDictionary.inline.hpp:  st->print_cr("------------------------------------");
memory/binaryTreeDictionary.inline.hpp:  st->print_cr("Total Free Space: " SIZE_FORMAT, total_size);
memory/binaryTreeDictionary.inline.hpp:  st->print_cr("Max   Chunk Size: " SIZE_FORMAT, max_chunk_size());
memory/binaryTreeDictionary.inline.hpp:  st->print_cr("Number of Blocks: " SIZE_FORMAT, free_blocks);
memory/binaryTreeDictionary.inline.hpp:    st->print_cr("Av.  Block  Size: " SIZE_FORMAT, total_size/free_blocks);
memory/binaryTreeDictionary.inline.hpp:  st->print_cr("Tree      Height: " SIZE_FORMAT, tree_height());
memory/binaryTreeDictionary.inline.hpp:      _st->print_cr("\t[" PTR_FORMAT "," PTR_FORMAT ")  %s",
memory/metaspaceShared.cpp:    st->print("CDS archive(s) mapped at: ");
memory/metaspaceShared.cpp:      st->print("[" PTR_FORMAT "-" PTR_FORMAT "-" PTR_FORMAT "), ", p2i(base), p2i(static_top), p2i(top));
memory/metaspaceShared.cpp:      st->print("[" PTR_FORMAT "-" PTR_FORMAT "), ", p2i(base), p2i(top));
memory/metaspaceShared.cpp:    st->print("size " SIZE_FORMAT ", ", top - base);
memory/metaspaceShared.cpp:    st->print("SharedBaseAddress: " PTR_FORMAT ", ArchiveRelocationMode: %d.", SharedBaseAddress, (int)ArchiveRelocationMode);
memory/metaspaceShared.cpp:    st->print("CDS disabled.");
memory/metaspaceShared.cpp:  st->cr();
memory/heapInspection.hpp:      st->print("%*s", num_spaces, "");
memory/heapInspection.hpp:    st->print(JULONG_FORMAT, n);
memory/filemap.hpp:    return (_manifest == NULL) ? NULL : (const char*)_manifest->data();
memory/filemap.hpp:    return (_manifest == NULL) ? 0 : _manifest->length();
memory/metaspace/smallBlocks.cpp:  st->print_cr("SmallBlocks:");
memory/metaspace/smallBlocks.cpp:    st->print_cr("small_lists size " SIZE_FORMAT " count " SIZE_FORMAT, _small_lists[k].size(), _small_lists[k].count());
memory/metaspace/metaspaceCommon.cpp:  st->print(" (");
memory/metaspace/metaspaceCommon.cpp:  st->print(")");
memory/metaspace/metaspaceCommon.cpp:    st->print("%*" PRIuPTR " bytes", width, byte_size);
memory/metaspace/metaspaceCommon.cpp:    st->print("%*" PRIuPTR " words", width, byte_size / BytesPerWord);
memory/metaspace/metaspaceCommon.cpp:      st->print("%*s %s", width, "<0.01", display_unit);
memory/metaspace/metaspaceCommon.cpp:      st->print("%*.2f %s", width, display_value, display_unit);
memory/metaspace/metaspaceCommon.cpp:    st->print("  ?%%");
memory/metaspace/metaspaceCommon.cpp:    st->print("  0%%");
memory/metaspace/metaspaceCommon.cpp:    st->print("100%%");
memory/metaspace/metaspaceCommon.cpp:      st->print(" <1%%");
memory/metaspace/metaspaceCommon.cpp:      st->print(">99%%");
memory/metaspace/metaspaceCommon.cpp:      st->print("%3.0f%%", p);
memory/metaspace/chunkManager.cpp:  list->return_chunk_at_head(p_new_chunk);
memory/metaspace/chunkManager.cpp:    list->remove_chunk(cur);
memory/metaspace/chunkManager.cpp:      Metachunk* chunk = list->head();
memory/metaspace/chunkManager.cpp:  st->print_cr("Free chunk total " SIZE_FORMAT "  count " SIZE_FORMAT,
memory/metaspace/chunkManager.cpp:    chunk = free_list->head();
memory/metaspace/chunkManager.cpp:    free_list->remove_chunk(chunk);
memory/metaspace/chunkManager.cpp:                                       p2i(free_list), free_list->count());
memory/metaspace/chunkManager.cpp:      list_count = list->count();
memory/metaspace/chunkManager.cpp:    assert(list->size() == chunk->word_size(), "Wrong chunk type.");
memory/metaspace/chunkManager.cpp:    list->return_chunk_at_head(chunk);
memory/metaspace/spaceManager.cpp:    st->print("SpaceManager: " UINTX_FORMAT " %s chunks.",
memory/metaspace/virtualSpaceList.cpp:    // Humongous chunks are allocated at smallest-chunksize
memory/metaspace/virtualSpaceList.cpp:  st->print_cr(SIZE_FORMAT " nodes, current node: " PTR_FORMAT,
memory/metaspace/virtualSpaceList.cpp:    st->cr();
memory/metaspace/virtualSpaceList.cpp:    st->print_cr("Node %u:", i);
memory/metaspace/metaspaceStatistics.cpp:  st->print(UINTX_FORMAT, _num);
memory/metaspace/metaspaceStatistics.cpp:  st->print(" chunks, total capacity ");
memory/metaspace/metaspaceStatistics.cpp:    st->cr();
memory/metaspace/metaspaceStatistics.cpp:    st->print("%12s chunks: ", chunk_size_name(i));
memory/metaspace/metaspaceStatistics.cpp:      st->print(UINTX_FORMAT_W(4) ", capacity ", _chunk_stats[i].num());
memory/metaspace/metaspaceStatistics.cpp:      st->print("(none)");
memory/metaspace/metaspaceStatistics.cpp:  st->cr();
memory/metaspace/metaspaceStatistics.cpp:  st->print("%19s: " UINTX_FORMAT_W(4) ", capacity=", "Total", totals.num());
memory/metaspace/metaspaceStatistics.cpp:  st->cr();
memory/metaspace/metaspaceStatistics.cpp:  int col = st->position();
memory/metaspace/metaspaceStatistics.cpp:  st->print(UINTX_FORMAT_W(4) " chunk%s, ", _num, _num != 1 ? "s" : "");
memory/metaspace/metaspaceStatistics.cpp:    col += 14; st->fill_to(col);
memory/metaspace/metaspaceStatistics.cpp:    st->print(" capacity, ");
memory/metaspace/metaspaceStatistics.cpp:    col += 18; st->fill_to(col);
memory/metaspace/metaspaceStatistics.cpp:    st->print(" used, ");
memory/metaspace/metaspaceStatistics.cpp:    col += 20; st->fill_to(col);
memory/metaspace/metaspaceStatistics.cpp:    st->print(" free, ");
memory/metaspace/metaspaceStatistics.cpp:    col += 20; st->fill_to(col);
memory/metaspace/metaspaceStatistics.cpp:    st->print(" waste, ");
memory/metaspace/metaspaceStatistics.cpp:    col += 20; st->fill_to(col);
memory/metaspace/metaspaceStatistics.cpp:    st->print(" overhead");
memory/metaspace/metaspaceStatistics.cpp:    st->cr_indent();
memory/metaspace/metaspaceStatistics.cpp:    st->print("Usage by chunk type:");
memory/metaspace/metaspaceStatistics.cpp:        st->cr_indent();
memory/metaspace/metaspaceStatistics.cpp:        st->print("%15s: ", chunk_size_name(i));
memory/metaspace/metaspaceStatistics.cpp:          st->print(" (none)");
memory/metaspace/metaspaceStatistics.cpp:      st->cr_indent();
memory/metaspace/metaspaceStatistics.cpp:      st->print("%15s: ", "-total-");
memory/metaspace/metaspaceStatistics.cpp:      st->cr_indent();
memory/metaspace/metaspaceStatistics.cpp:      st->print("deallocated: " UINTX_FORMAT " blocks with ", _free_blocks_num);
memory/metaspace/metaspaceStatistics.cpp:    st->print(", ");
memory/metaspace/metaspaceStatistics.cpp:    st->print("deallocated: " UINTX_FORMAT " blocks with ", _free_blocks_num);
memory/metaspace/metaspaceStatistics.cpp:  st->cr_indent();
memory/metaspace/metaspaceStatistics.cpp:    st->print("Non-Class: ");
memory/metaspace/metaspaceStatistics.cpp:    st->cr();
memory/metaspace/metaspaceStatistics.cpp:    st->cr_indent();
memory/metaspace/metaspaceStatistics.cpp:    st->print("    Class: ");
memory/metaspace/metaspaceStatistics.cpp:      st->cr();
memory/metaspace/metaspaceStatistics.cpp:    st->cr_indent();
memory/metaspace/metaspaceStatistics.cpp:    st->print("     Both: ");
memory/metaspace/metaspaceStatistics.cpp:      st->cr();
memory/metaspace/metaspaceStatistics.cpp:  st->cr();
memory/metaspace/virtualSpaceNode.cpp:        st->fill_to(22);
memory/metaspace/virtualSpaceNode.cpp:        st->print_raw(lines[i], line_len);
memory/metaspace/virtualSpaceNode.cpp:        st->cr();
memory/metaspace/virtualSpaceNode.cpp:      st->print(PTR_FORMAT ":", p2i(p));
memory/metaspace/virtualSpaceNode.cpp:      st->fill_to(22);
memory/metaspace/virtualSpaceNode.cpp:      st->print_raw(lines[i], line_len);
memory/metaspace/virtualSpaceNode.cpp:      st->cr();
memory/metaspace/virtualSpaceNode.cpp:  st->print("node @" PTR_FORMAT ": ", p2i(this));
memory/metaspace/virtualSpaceNode.cpp:  st->print("reserved=");
memory/metaspace/virtualSpaceNode.cpp:  st->print(", committed=");
memory/metaspace/virtualSpaceNode.cpp:  st->print(", used=");
memory/metaspace/virtualSpaceNode.cpp:  st->cr();
memory/metaspace/virtualSpaceNode.cpp:  st->print("   [" PTR_FORMAT ", " PTR_FORMAT ", "
memory/metaspace/metachunk.cpp:  st->print_cr("Metachunk:"
memory/metaspace/metachunk.cpp:    st->print_cr("    used " SIZE_FORMAT " free " SIZE_FORMAT,
memory/guardedMemory.cpp:    st->print_cr("GuardedMemory(" PTR_FORMAT ") not associated to any memory", p2i(this));
memory/guardedMemory.cpp:  st->print_cr("GuardedMemory(" PTR_FORMAT ") base_addr=" PTR_FORMAT
memory/guardedMemory.cpp:  st->print_cr("  Header guard @" PTR_FORMAT " is %s", p2i(guard), (guard->verify() ? "OK" : "BROKEN"));
memory/guardedMemory.cpp:  st->print_cr("  Trailer guard @" PTR_FORMAT " is %s", p2i(guard), (guard->verify() ? "OK" : "BROKEN"));
memory/guardedMemory.cpp:    st->print_cr("  User data appears unused");
memory/guardedMemory.cpp:    st->print_cr("  User data appears to have been freed");
memory/guardedMemory.cpp:    st->print_cr("  User data appears to be in use");
memory/heapInspection.cpp:    st->print_cr(INT64_FORMAT_W(13) "  " UINT64_FORMAT_W(13) "  %s (%s%s%s)",
memory/heapInspection.cpp:    st->print_cr(INT64_FORMAT_W(13) "  " UINT64_FORMAT_W(13) "  %s",
memory/heapInspection.cpp:    _success &= _dest->merge_entry(cie);
memory/heapInspection.cpp:    st->print("%4d: ", i+1);
memory/heapInspection.cpp:  st->print_cr("Total " INT64_FORMAT_W(13) "  " UINT64_FORMAT_W(13),
memory/heapInspection.cpp:    st->print_cr("ERROR: Ran out of C-heap; hierarchy not generated");
memory/heapInspection.cpp:  st->flush();
memory/heapInspection.cpp:    st->print("|");
memory/heapInspection.cpp:      st->print("  ");
memory/heapInspection.cpp:  st->print("%s/", klass->external_name());
memory/heapInspection.cpp:    st->print("null");
memory/heapInspection.cpp:    st->print(INTPTR_FORMAT, p2i(klass->class_loader_data()));
memory/heapInspection.cpp:  st->print("  implements ");
memory/heapInspection.cpp:  st->print(" (%s intf)\n", intf_type);
memory/heapInspection.cpp:  if (indent != 0) st->print("--");
memory/heapInspection.cpp:    st->print(" (intf)");
memory/heapInspection.cpp:    st->print(" (invokes: ");
memory/heapInspection.cpp:    st->print(")");
memory/heapInspection.cpp:  st->print("\n");
memory/heapInspection.cpp:  st->print_cr(" num     #instances         #bytes  class name (module)");
memory/heapInspection.cpp:  st->print_cr("-------------------------------------------------------");
memory/heapInspection.cpp:    st->print_cr("ERROR: Ran out of C-heap; histogram not generated");
memory/heapInspection.cpp:  st->flush();
memory/allocation.cpp:  st->print(" {" INTPTR_FORMAT "}", p2i(this));
memory/allocation.cpp:  st->print_cr("AllocatedObj(" INTPTR_FORMAT ")", p2i(this));
memory/allocation.cpp:  st->print("AllocatedObj(" INTPTR_FORMAT ")", p2i(this));
oops/constMethod.cpp:  st->print_cr("%s", internal_name());
oops/constMethod.cpp:  st->print(" - method:       " INTPTR_FORMAT " ", p2i((address)m));
oops/constMethod.cpp:  st->cr();
oops/constMethod.cpp:    st->print(" - stackmap data:       ");
oops/constMethod.cpp:    st->cr();
oops/constMethod.cpp:  st->print(" const part of method " );
oops/constMethod.cpp:    st->print("NULL");
oops/oop.cpp:  st->print("{" INTPTR_FORMAT "}", p2i(this));
oops/arrayKlass.cpp:    st->print("[]");
oops/arrayKlass.cpp:  st->print_cr(" - length: %d", arrayOop(obj)->length());
oops/methodData.cpp:  st->print("bci: %d", bci());
oops/methodData.cpp:  st->fill_to(tab_width_one);
oops/methodData.cpp:  st->print("%s", name);
oops/methodData.cpp:    st->print("trap(%s) ", Deoptimization::format_trap_state(buf, sizeof(buf), trap));
oops/methodData.cpp:    st->print("%s", extra);
oops/methodData.cpp:    st->print("flags(%d) ", flags);
oops/methodData.cpp:  st->fill_to(first ? tab_width_one : tab_width_two);
oops/methodData.cpp:  st->cr();
oops/methodData.cpp:  st->print_cr("count(%u)", count());
oops/methodData.cpp:  st->print_cr("taken(%u) displacement(%d)", taken(), displacement());
oops/methodData.cpp:    st->print("none");
oops/methodData.cpp:    st->print("unknown");
oops/methodData.cpp:    st->print(" (null seen)");
oops/methodData.cpp:    st->print("%d: stack(%u) ", i, stack_slot(i));
oops/methodData.cpp:    st->cr();
oops/methodData.cpp:  st->cr();
oops/methodData.cpp:    st->print("argument types");
oops/methodData.cpp:    st->print("return type");
oops/methodData.cpp:    st->print("argument types");
oops/methodData.cpp:    st->print("return type");
oops/methodData.cpp:  st->print_cr("count(%u) nonprofiled_count(%u) entries(%u)", count(), nonprofiled_count(), entries);
oops/methodData.cpp:  st->print_cr("count(%u) entries(%u)", count(), entries);
oops/methodData.cpp:      st->print_cr("(%u %4.2f)", receiver_count(row), (float) receiver_count(row) / (float) total);
oops/methodData.cpp:  st->print_cr("count(%u) entries(%u)", count(), entries);
oops/methodData.cpp:      st->print_cr("bci(%d: count(%u) displacement(%d))",
oops/methodData.cpp:  st->print_cr("taken(%u) displacement(%d)",
oops/methodData.cpp:  st->print_cr("not taken(%u)", not_taken());
oops/methodData.cpp:  st->print_cr("default_count(%u) displacement(%d)",
oops/methodData.cpp:    st->print_cr("count(%u) displacement(%d)",
oops/methodData.cpp:    st->print("  0x%x", arg_modified(i));
oops/methodData.cpp:  st->cr();
oops/methodData.cpp:  st->print("parameter types"); // FIXME extra ignored?
oops/methodData.cpp:  st->cr();
oops/methodData.cpp:  st->print("method data for ");
oops/methodData.cpp:  st->cr();
oops/methodData.cpp:  st->print("method data for ");
oops/methodData.cpp:    st->print("%d", dp_to_di(data->dp()));
oops/methodData.cpp:    st->fill_to(6);
oops/methodData.cpp:  st->print_cr("--- Extra data:");
oops/methodData.cpp:    st->print("%d", dp_to_di(data->dp()));
oops/methodData.cpp:    st->fill_to(6);
oops/weakHandle.cpp:  st->print("WeakHandle: " PTR_FORMAT, p2i(peek()));
oops/instanceKlass.hpp:  // Resolved nest-host klass: either true nest-host or self if we are not
oops/instanceKlass.hpp:  // nest-host. Can also be set directly by JDK API's that establish nest
oops/instanceKlass.hpp:  // By always being set it makes nest-member access checks simpler.
oops/instanceKlass.hpp:  // that is the nest-host of this class. This data has not been validated.
oops/instanceKlass.hpp:  // nest-host index
oops/instanceKlass.hpp:  // Called to verify that k is a member of this nest - does not look at k's nest-host
oops/instanceKlass.hpp:  // Returns nest-host class, resolving and validating it if needed.
oops/instanceKlass.hpp:  // Check if this klass is a nestmate of k - resolves this nest-host and k's
oops/compressedOops.cpp:  st->print("Heap address: " PTR_FORMAT ", size: " SIZE_FORMAT " MB",
oops/compressedOops.cpp:  st->print(", Compressed Oops mode: %s", mode_to_string(mode()));
oops/compressedOops.cpp:    st->print(": " PTR_FORMAT, p2i(base()));
oops/compressedOops.cpp:    st->print(", Oop shift amount: %d", shift());
oops/compressedOops.cpp:    st->print(", no protected page in front of the heap");
oops/compressedOops.cpp:  st->cr();
oops/compressedOops.cpp:  st->print_cr("Narrow klass base: " PTR_FORMAT ", Narrow klass shift: %d, "
oops/method.cpp:  st->print(" %s::", method_holder()->external_name());
oops/method.cpp:  st->print(" %s::", method_holder()->internal_name());
oops/method.cpp:    if (_use_separator) _st->print(", ");
oops/method.cpp:    _st->print("%s", name);
oops/method.cpp:  st->print("%s ", is_static() ? "static" : "virtual");
oops/method.cpp:    st->print("%s.", method_holder()->internal_name());
oops/method.cpp:    st->print(" %s.", method_holder()->internal_name());
oops/method.cpp:    st->print("(");
oops/method.cpp:    st->print(")");
oops/method.cpp:  st->print_cr("%s", internal_name());
oops/method.cpp:  st->print_cr(" - this oop:          " INTPTR_FORMAT, p2i(this));
oops/method.cpp:  st->print   (" - method holder:     "); method_holder()->print_value_on(st); st->cr();
oops/method.cpp:  st->print   (" - constants:         " INTPTR_FORMAT " ", p2i(constants()));
oops/method.cpp:  constants()->print_value_on(st); st->cr();
oops/method.cpp:  st->print   (" - access:            0x%x  ", access_flags().as_int()); access_flags().print_on(st); st->cr();
oops/method.cpp:  st->print   (" - name:              ");    name()->print_value_on(st); st->cr();
oops/method.cpp:  st->print   (" - signature:         ");    signature()->print_value_on(st); st->cr();
oops/method.cpp:  st->print_cr(" - max stack:         %d",   max_stack());
oops/method.cpp:  st->print_cr(" - max locals:        %d",   max_locals());
oops/method.cpp:  st->print_cr(" - size of params:    %d",   size_of_parameters());
oops/method.cpp:  st->print_cr(" - method size:       %d",   method_size());
oops/method.cpp:    st->print_cr(" - intrinsic id:      %d %s", intrinsic_id(), vmIntrinsics::name_at(intrinsic_id()));
oops/method.cpp:    st->print_cr(" - highest level:     %d", highest_comp_level());
oops/method.cpp:  st->print_cr(" - vtable index:      %d",   _vtable_index);
oops/method.cpp:  st->print_cr(" - i2i entry:         " INTPTR_FORMAT, p2i(interpreter_entry()));
oops/method.cpp:  st->print(   " - adapters:          ");
oops/method.cpp:    st->print_cr(INTPTR_FORMAT, p2i(a));
oops/method.cpp:  st->print_cr(" - compiled entry     " INTPTR_FORMAT, p2i(from_compiled_entry()));
oops/method.cpp:  st->print_cr(" - code size:         %d",   code_size());
oops/method.cpp:    st->print_cr(" - code start:        " INTPTR_FORMAT, p2i(code_base()));
oops/method.cpp:    st->print_cr(" - code end (excl):   " INTPTR_FORMAT, p2i(code_base() + code_size()));
oops/method.cpp:    st->print_cr(" - method data:       " INTPTR_FORMAT, p2i(method_data()));
oops/method.cpp:  st->print_cr(" - checked ex length: %d",   checked_exceptions_length());
oops/method.cpp:    st->print_cr(" - checked ex start:  " INTPTR_FORMAT, p2i(table));
oops/method.cpp:        st->print_cr("   - throws %s", constants()->printable_name_at(table[i].class_cp_index));
oops/method.cpp:    st->print_cr(" - linenumber start:  " INTPTR_FORMAT, p2i(table));
oops/method.cpp:        st->print_cr("   - line %d: %d", stream.line(), stream.bci());
oops/method.cpp:  st->print_cr(" - localvar length:   %d",   localvariable_table_length());
oops/method.cpp:    st->print_cr(" - localvar start:    " INTPTR_FORMAT, p2i(table));
oops/method.cpp:        st->print_cr("   - %s %s bci=%d len=%d slot=%d", desc, name, bci, len, slot);
oops/method.cpp:    st->print   (" - compiled code: ");
oops/method.cpp:    st->print_cr(" - native function:   " INTPTR_FORMAT, p2i(native_function()));
oops/method.cpp:    st->print_cr(" - signature handler: " INTPTR_FORMAT, p2i(signature_handler()));
oops/method.cpp:    st->print("default ");
oops/method.cpp:    st->print("overpass ");
oops/method.cpp:  st->print("%s", internal_name());
oops/method.cpp:  st->print(" ");
oops/method.cpp:  st->print(" ");
oops/method.cpp:  st->print(" in ");
oops/method.cpp:  if (WizardMode) st->print("#%d", _vtable_index);
oops/method.cpp:  if (WizardMode) st->print("[%d,%d]", size_of_parameters(), max_locals());
oops/method.cpp:  if (WizardMode && code() != NULL) st->print(" ((nmethod*)%p)", code());
oops/cpCache.cpp:  if (index == 0) st->print_cr("                 -------------");
oops/cpCache.cpp:  st->print("%3d  (" PTR_FORMAT ")  ", index, (intptr_t)this);
oops/cpCache.cpp:  st->print_cr("[%02x|%02x|%5d]", bytecode_2(), bytecode_1(),
oops/cpCache.cpp:  st->print_cr("                 [   " PTR_FORMAT "]", (intptr_t)_f1);
oops/cpCache.cpp:  st->print_cr("                 [   " PTR_FORMAT "]", (intptr_t)_f2);
oops/cpCache.cpp:  st->print_cr("                 [   " PTR_FORMAT "]", (intptr_t)_flags);
oops/cpCache.cpp:  st->print_cr("                 -------------");
oops/cpCache.cpp:  st->print_cr("%s", internal_name());
oops/cpCache.cpp:  st->print("cache [%d]", length());
oops/cpCache.cpp:  st->print(" for ");
oops/methodData.hpp:// during zeroth-tier (interpretive) and first-tier execution.
oops/access.inline.hpp:// * Step 5.b: Post-runtime dispatch. This step now casts previously unknown types such
oops/access.inline.hpp:  // Step 5.b: Post-runtime dispatch.
oops/typeArrayKlass.cpp:  st->print("{type array ");
oops/typeArrayKlass.cpp:    st->print("bool");
oops/typeArrayKlass.cpp:    st->print("%s", type2name_tab[bt]);
oops/typeArrayKlass.cpp:  st->print("}");
oops/typeArrayKlass.cpp:    st->print_cr(" - %3d: %s", index, (ta->bool_at(index) == 0) ? "false" : "true");
oops/typeArrayKlass.cpp:    st->print_cr(" - %3d: %x %c", index, c, isprint(c) ? c : ' ');
oops/typeArrayKlass.cpp:    st->print_cr(" - %3d: %g", index, ta->float_at(index));
oops/typeArrayKlass.cpp:    st->print_cr(" - %3d: %g", index, ta->double_at(index));
oops/typeArrayKlass.cpp:    st->print_cr(" - %3d: %x %c", index, c, isprint(c) ? c : ' ');
oops/typeArrayKlass.cpp:    st->print_cr(" - %3d: 0x%x\t %d", index, v, v);
oops/typeArrayKlass.cpp:    st->print_cr(" - %3d: 0x%x %d", index, v, v);
oops/typeArrayKlass.cpp:    st->print_cr(" - %3d: 0x%x 0x%x", index, high(v), low(v));
oops/typeArrayKlass.cpp:    st->print_cr(" - <%d more elements, increase MaxElementPrintSize to print>", remaining);
oops/array.hpp:    st->print("Array<T>(" INTPTR_FORMAT ")", p2i(this));
oops/array.hpp:       st->print_cr("%d: " INTPTR_FORMAT, i, (intptr_t)at(i));
oops/symbol.cpp:  st->print("%s", as_C_string());
oops/symbol.cpp:    // ResourceMark may not affect st->print(). If st is a string
oops/symbol.cpp:    st->print("(null)");
oops/symbol.cpp:    st->print("%s", s);
oops/symbol.cpp:  st->print("Symbol: '");
oops/symbol.cpp:  st->print("'");
oops/symbol.cpp:  st->print(" count %d", refcount());
oops/symbol.cpp:  st->print("'");
oops/symbol.cpp:    st->print("%c", char_at(i));
oops/symbol.cpp:  st->print("'");
oops/constantPool.cpp:  st->print_cr("%s", internal_name());
oops/constantPool.cpp:    st->print(" - flags: 0x%x", flags());
oops/constantPool.cpp:    if (has_preresolution()) st->print(" has_preresolution");
oops/constantPool.cpp:    if (on_stack()) st->print(" on_stack");
oops/constantPool.cpp:    st->cr();
oops/constantPool.cpp:    st->print_cr(" - holder: " INTPTR_FORMAT, p2i(pool_holder()));
oops/constantPool.cpp:  st->print_cr(" - cache: " INTPTR_FORMAT, p2i(cache()));
oops/constantPool.cpp:  st->print_cr(" - resolved_references: " INTPTR_FORMAT, p2i(resolved_references()));
oops/constantPool.cpp:  st->print_cr(" - reference_map: " INTPTR_FORMAT, p2i(reference_map()));
oops/constantPool.cpp:  st->print_cr(" - resolved_klasses: " INTPTR_FORMAT, p2i(resolved_klasses()));
oops/constantPool.cpp:  st->cr();
oops/constantPool.cpp:  st->print(" - %3d : ", index);
oops/constantPool.cpp:  st->print(" : ");
oops/constantPool.cpp:        st->print(" {" PTR_FORMAT "}", p2i(k));
oops/constantPool.cpp:      st->print("klass_index=%d", uncached_klass_ref_index_at(index));
oops/constantPool.cpp:      st->print(" name_and_type_index=%d", uncached_name_and_type_ref_index_at(index));
oops/constantPool.cpp:        st->print(" {" PTR_FORMAT "}", p2i(anObj));
oops/constantPool.cpp:      st->print("%d", int_at(index));
oops/constantPool.cpp:      st->print("%f", float_at(index));
oops/constantPool.cpp:      st->print_jlong(long_at(index));
oops/constantPool.cpp:      st->print("%lf", double_at(index));
oops/constantPool.cpp:      st->print("name_index=%d", name_ref_index_at(index));
oops/constantPool.cpp:      st->print(" signature_index=%d", signature_ref_index_at(index));
oops/constantPool.cpp:        st->print("klass_index=%d ", name_index);
oops/constantPool.cpp:      st->print("ref_kind=%d", method_handle_ref_kind_at(index));
oops/constantPool.cpp:      st->print(" ref_index=%d", method_handle_index_at(index));
oops/constantPool.cpp:      st->print("signature_index=%d", method_type_index_at(index));
oops/constantPool.cpp:        st->print("bootstrap_method_index=%d", bootstrap_method_ref_index_at(index));
oops/constantPool.cpp:        st->print(" type_index=%d", bootstrap_name_and_type_ref_index_at(index));
oops/constantPool.cpp:            st->print((arg_i == 0 ? " arguments={%d" : ", %d"), arg);
oops/constantPool.cpp:          st->print("}");
oops/constantPool.cpp:        st->print("bootstrap_method_index=%d", bootstrap_method_ref_index_at(index));
oops/constantPool.cpp:        st->print(" name_and_type_index=%d", bootstrap_name_and_type_ref_index_at(index));
oops/constantPool.cpp:            st->print((arg_i == 0 ? " arguments={%d" : ", %d"), arg);
oops/constantPool.cpp:          st->print("}");
oops/constantPool.cpp:  st->cr();
oops/constantPool.cpp:  st->print("constant pool [%d]", length());
oops/constantPool.cpp:  if (has_preresolution()) st->print("/preresolution");
oops/constantPool.cpp:  if (operands() != NULL)  st->print("/operands[%d]", operands()->length());
oops/constantPool.cpp:    st->print(" for ");
oops/constantPool.cpp:    if (extra)  st->print(" (extra)");
oops/constantPool.cpp:    st->print(" cache=" PTR_FORMAT, p2i(cache()));
oops/recordComponent.cpp:  st->print("RecordComponent(" INTPTR_FORMAT ")", p2i(this));
oops/recordComponent.cpp:  st->print("name_index: %d", _name_index);
oops/recordComponent.cpp:  st->print(" - descriptor_index: %d", _descriptor_index);
oops/recordComponent.cpp:  st->print(" - attributes_count: %d", _attributes_count);
oops/recordComponent.cpp:    st->print(" - generic_signature_index: %d", _generic_signature_index);
oops/recordComponent.cpp:  st->cr();
oops/recordComponent.cpp:    st->print_cr("record component annotations");
oops/recordComponent.cpp:    st->print_cr("record component type annotations");
oops/metadata.hpp:      st->print("NULL");
oops/accessBackend.inline.hpp:  dst->init_mark_raw();
oops/access.hpp:// * Step 5.b: Post-runtime dispatch. This step now casts previously unknown types such
oops/metadata.cpp:  st->print("%s", internal_name());
oops/metadata.cpp:  st->cr();
oops/annotations.cpp:  st->print("Annotations(" INTPTR_FORMAT ")", p2i(this));
oops/annotations.cpp:  st->print(BULLET"class_annotations            "); class_annotations()->print_value_on(st);
oops/annotations.cpp:  st->print(BULLET"fields_annotations           "); fields_annotations()->print_value_on(st);
oops/annotations.cpp:  st->print(BULLET"class_type_annotations       "); class_type_annotations()->print_value_on(st);
oops/annotations.cpp:  st->print(BULLET"fields_type_annotations      "); fields_type_annotations()->print_value_on(st);
oops/objArrayKlass.cpp:  st->print(" - instance klass: ");
oops/objArrayKlass.cpp:  st->cr();
oops/objArrayKlass.cpp:  st->print("[]");
oops/objArrayKlass.cpp:    st->print(" - %3d : ", index);
oops/objArrayKlass.cpp:      st->cr();
oops/objArrayKlass.cpp:      st->print_cr("NULL");
oops/objArrayKlass.cpp:    st->print_cr(" - <%d more elements, increase MaxElementPrintSize to print>", remaining);
oops/objArrayKlass.cpp:  st->print("a ");
oops/objArrayKlass.cpp:  st->print("[%d] ", len);
oops/objArrayKlass.cpp:    st->print_cr("NULL");
oops/klass.cpp:  st->print("%s", internal_name());
oops/klass.cpp:  st->cr();
oops/klass.cpp:  st->print_cr("%s ", internal_name());
oops/klass.cpp:     st->cr();
oops/klass.cpp:     st->print(BULLET"prototype_header: " INTPTR_FORMAT, _prototype_header.value());
oops/klass.cpp:     st->cr();
oops/klass.cpp:  st->print(BULLET"klass: ");
oops/klass.cpp:  st->cr();
oops/klass.cpp:  st->print("%s", internal_name());
oops/markWord.cpp:    st->print(" marked(" INTPTR_FORMAT ")", value());
oops/markWord.cpp:    st->print(" monitor(" INTPTR_FORMAT ")=", value());
oops/markWord.cpp:      st->print("NULL (this should never be seen!)");
oops/markWord.cpp:    st->print(" locked(" INTPTR_FORMAT ")", value());
oops/markWord.cpp:    st->print(" mark(");
oops/markWord.cpp:      st->print("is_neutral");
oops/markWord.cpp:        st->print(" no_hash");
oops/markWord.cpp:        st->print(" hash=" INTPTR_FORMAT, hash());
oops/markWord.cpp:      st->print("is_biased");
oops/markWord.cpp:      st->print(" biased_locker=" INTPTR_FORMAT " epoch=%d", p2i(jt), bias_epoch());
oops/markWord.cpp:      st->print("??");
oops/markWord.cpp:    st->print(" age=%d)", age());
oops/compiledICHolder.cpp:  st->print("%s", internal_name());
oops/compiledICHolder.cpp:  st->print(" - metadata: "); holder_metadata()->print_value_on(st); st->cr();
oops/compiledICHolder.cpp:  st->print(" - klass:    "); holder_klass()->print_value_on(st); st->cr();
oops/compiledICHolder.cpp:  st->print("%s", internal_name());
oops/methodCounters.cpp:  st->print("method counters");
oops/instanceKlass.cpp:      log_trace(class, nestmates)("Checked nest membership of %s in non-nest-host class %s",
oops/instanceKlass.cpp:// Return nest-host class, resolving, validating and saving it if needed.
oops/instanceKlass.cpp:// Any errors from nest-host resolution must be preserved so they can be queried
oops/instanceKlass.cpp:  // need to resolve and save our nest-host class.
oops/instanceKlass.cpp:      log_trace(class, nestmates)("Rejected resolution of nest-host of %s in unsuitable thread",
oops/instanceKlass.cpp:    log_trace(class, nestmates)("Resolving nest-host of %s using cp entry for %s",
oops/instanceKlass.cpp:      // A valid nest-host is an instance class in the current package that lists this
oops/instanceKlass.cpp:      // its own nest-host.
oops/instanceKlass.cpp:              _nest_host = nest_host_k; // save resolved nest-host value
oops/instanceKlass.cpp:              log_trace(class, nestmates)("Resolved nest-host of %s to %s",
oops/instanceKlass.cpp:    log_trace(class, nestmates)("Type %s is not part of a nest: setting nest-host to self",
oops/instanceKlass.cpp:  // the nest-host is set to `this`. Any thread that sees this assignment
oops/instanceKlass.cpp:// We also know the "host" is a valid nest-host in the same package so we can
oops/instanceKlass.cpp:  assert(_nest_host == NULL, "current class has resolved nest-host");
oops/instanceKlass.cpp:  assert((host->_nest_host == NULL && host->_nest_host_index == 0) ||
oops/instanceKlass.cpp:         (host->_nest_host == host), "proposed host is not a valid nest-host");
oops/instanceKlass.cpp:    // a hidden class does not expect a statically defined nest-host
oops/instanceKlass.cpp:                                host->external_name(),
oops/instanceKlass.cpp:  const int length = inner_class_list->length();
oops/instanceKlass.cpp:  return inner_class_list->at(index + offset);
oops/instanceKlass.cpp:  int length = inner_class_list->length();
oops/instanceKlass.cpp:    inner_class_list->at_put(
oops/instanceKlass.cpp:    inner_class_list->at_put(
oops/instanceKlass.cpp:      last->set_osr_link(next);
oops/instanceKlass.cpp:        if (best == NULL || (osr->comp_level() > best->comp_level())) {
oops/instanceKlass.cpp:  if (best != NULL && best->comp_level() >= comp_level) {
oops/instanceKlass.cpp:    st->print("%d : " INTPTR_FORMAT, i, e);
oops/instanceKlass.cpp:      st->print(" ");
oops/instanceKlass.cpp:    st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"instance size:     %d", size_helper());                        st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"klass size:        %d", size());                               st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"access:            "); access_flags().print_on(st);            st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"state:             "); st->print_cr("%s", state_names[_init_state]);
oops/instanceKlass.cpp:  st->print(BULLET"name:              "); name()->print_value_on(st);             st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"super:             "); Metadata::print_value_on_maybe_null(st, super()); st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"sub:               ");
oops/instanceKlass.cpp:      st->print("   ");
oops/instanceKlass.cpp:  if (n >= MaxSubklassPrintSize) st->print("(" INTX_FORMAT " more klasses...)", n - MaxSubklassPrintSize);
oops/instanceKlass.cpp:  st->cr();
oops/instanceKlass.cpp:    st->print_cr(BULLET"nof implementors:  %d", nof_implementors());
oops/instanceKlass.cpp:      st->print_cr(BULLET"implementor:    ");
oops/instanceKlass.cpp:      st->print("   ");
oops/instanceKlass.cpp:      st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"arrays:            "); Metadata::print_value_on_maybe_null(st, array_klasses()); st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"methods:           "); methods()->print_value_on(st);                  st->cr();
oops/instanceKlass.cpp:      st->print("%d : ", i); method_array->at(i)->print_value(); st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"method ordering:   "); method_ordering()->print_value_on(st);      st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"default_methods:   "); default_methods()->print_value_on(st);      st->cr();
oops/instanceKlass.cpp:      st->print("%d : ", i); method_array->at(i)->print_value(); st->cr();
oops/instanceKlass.cpp:    st->print(BULLET"default vtable indices:   "); default_vtable_indices()->print_value_on(st);       st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"local interfaces:  "); local_interfaces()->print_value_on(st);      st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"trans. interfaces: "); transitive_interfaces()->print_value_on(st); st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"constants:         "); constants()->print_value_on(st);         st->cr();
oops/instanceKlass.cpp:    st->print(BULLET"class loader data:  ");
oops/instanceKlass.cpp:    st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"unsafe anonymous host class:        "); Metadata::print_value_on_maybe_null(st, unsafe_anonymous_host()); st->cr();
oops/instanceKlass.cpp:    st->print(BULLET"source file:       ");
oops/instanceKlass.cpp:    st->cr();
oops/instanceKlass.cpp:    st->print(BULLET"source debug extension:       ");
oops/instanceKlass.cpp:    st->print("%s", source_debug_extension());
oops/instanceKlass.cpp:    st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"class annotations:       "); class_annotations()->print_value_on(st); st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"class type annotations:  "); class_type_annotations()->print_value_on(st); st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"field annotations:       "); fields_annotations()->print_value_on(st); st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"field type annotations:  "); fields_type_annotations()->print_value_on(st); st->cr();
oops/instanceKlass.cpp:        st->print(BULLET"previous version:  ");
oops/instanceKlass.cpp:    if (have_pv) st->cr();
oops/instanceKlass.cpp:    st->print(BULLET"generic signature: ");
oops/instanceKlass.cpp:    st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"inner classes:     "); inner_classes()->print_value_on(st);     st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"nest members:     "); nest_members()->print_value_on(st);     st->cr();
oops/instanceKlass.cpp:    st->print(BULLET"record components:     "); record_components()->print_value_on(st);     st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"permitted subclasses:     "); permitted_subclasses()->print_value_on(st);     st->cr();
oops/instanceKlass.cpp:    st->print(BULLET"java mirror:       ");
oops/instanceKlass.cpp:    st->cr();
oops/instanceKlass.cpp:    st->print_cr(BULLET"java mirror:       NULL");
oops/instanceKlass.cpp:  st->print(BULLET"vtable length      %d  (start addr: " INTPTR_FORMAT ")", vtable_length(), p2i(start_of_vtable())); st->cr();
oops/instanceKlass.cpp:  st->print(BULLET"itable length      %d (start addr: " INTPTR_FORMAT ")", itable_length(), p2i(start_of_itable())); st->cr();
oops/instanceKlass.cpp:  st->print_cr(BULLET"---- static fields (%d words):", static_field_size());
oops/instanceKlass.cpp:  st->print_cr(BULLET"---- non-static fields (%d words):", nonstatic_field_size());
oops/instanceKlass.cpp:  st->print(BULLET"non-static oop maps: ");
oops/instanceKlass.cpp:    st->print("%d-%d ", map->offset(), map->offset() + heapOopSize*(map->count() - 1));
oops/instanceKlass.cpp:  st->cr();
oops/instanceKlass.cpp:  _st->print(BULLET);
oops/instanceKlass.cpp:     _st->cr();
oops/instanceKlass.cpp:     _st->cr();
oops/instanceKlass.cpp:      st->print(BULLET"string: ");
oops/instanceKlass.cpp:      st->cr();
oops/instanceKlass.cpp:  st->print_cr(BULLET"---- fields (total size %d words):", oop_size(obj));
oops/instanceKlass.cpp:    st->print(BULLET"signature: ");
oops/instanceKlass.cpp:    st->cr();
oops/instanceKlass.cpp:    st->print(BULLET"fake entry for mirror: ");
oops/instanceKlass.cpp:    st->cr();
oops/instanceKlass.cpp:    st->print(BULLET"fake entry for array: ");
oops/instanceKlass.cpp:    st->cr();
oops/instanceKlass.cpp:    st->print_cr(BULLET"fake entry for oop_size: %d", java_lang_Class::oop_size(obj));
oops/instanceKlass.cpp:    st->print_cr(BULLET"fake entry for static_oop_field_count: %d", java_lang_Class::static_oop_field_count(obj));
oops/instanceKlass.cpp:    st->print(BULLET"signature: ");
oops/instanceKlass.cpp:    st->cr();
oops/instanceKlass.cpp:  st->print("a ");
oops/instanceKlass.cpp:    st->print(" = \"%s\"", str);
oops/instanceKlass.cpp:      st->print("...[%d]", len);
oops/instanceKlass.cpp:    st->print(" = ");
oops/instanceKlass.cpp:      st->print("%s", tname ? tname : "type?");
oops/instanceKlass.cpp:    st->print(" = ");
oops/instanceKlass.cpp:    st->print(" = ");
oops/instanceKlass.cpp:      st->print(" => ");
oops/instanceKlass.cpp:      st->print(" = ");
oops/instanceKlass.cpp:      st->print(".");
oops/instanceKlass.cpp:    guarantee(anonymous_host->is_klass(), "should be klass");
oops/instanceKlass.cpp:      last->link_previous_versions(next);
opto/superword.cpp:// 1) A reverse post-order of nodes in the block is constructed.  By scanning
opto/superword.cpp://------------------------------extend_packlist---------------------------
opto/superword.cpp:    if (first->is_Phi() || first->is_reduction()) {
opto/superword.cpp:    if (first->is_Phi() || first->is_reduction()) {
opto/superword.cpp:    MemNode* current   = last->in(MemNode::Memory)->as_Mem();
opto/superword.cpp:    Node*    upper_insert_pt = first->in(MemNode::Memory);
opto/superword.cpp:    current                  = last->in(MemNode::Memory)->as_Mem();
opto/superword.cpp:      NOT_PRODUCT(if(is_trace_cmov()) {tty->print_cr("SWPointer::output: %d executed first, %d executed last in pack", first->_idx, n->_idx); print_pack(p);})
opto/superword.cpp:        Node* mem = first->in(MemNode::Memory);
opto/superword.cpp:        Node* mem = first->in(MemNode::Memory);
opto/superword.cpp:      _stk.pop(); // Remove post-visited node from stack
opto/superword.cpp://------------------------------executed_first---------------------------
opto/superword.cpp://------------------------------executed_last---------------------------
opto/superword.cpp:  assert(first->is_Load(), "must be Load");
opto/superword.cpp:  Node* phi = first->as_Load()->in(MemNode::Memory);
opto/superword.cpp:      first->dump();
opto/macro.cpp:    region->init_req(edge, fast_taken); // Capture fast-control
opto/macro.cpp:          sfpt->del_req(last--);
opto/macro.cpp:            sfpt_done->del_req(last--);
opto/macro.cpp:  // We need a Region and corresponding Phi's to merge the slow-path and fast-path results.
opto/macro.cpp:    // Name successful fast-path variables
opto/macro.cpp:    // Plug in the successful fast-path into the result merge point
opto/macro.cpp:      // Insert a prefetch for each allocation only on the fast-path
opto/movenode.cpp: to figure out which test post-dominates.  The real problem is that it doesn't
opto/node.cpp:  // Ensure that at least one copy of the last-seen edge was deleted.
opto/node.cpp:  // Note:  It is OK to delete multiple copies of the last-seen edge.
opto/node.cpp:  if (cast != NULL && cast->has_range_check()) {
opto/node.cpp:  if (cast != NULL && cast->has_range_check()) {
opto/node.cpp://-----------------------------uncast---------------------------------------
opto/node.cpp:// Get the worst-case Type output for this Node.
opto/node.cpp:  return bottom_type();         // Default to worst-case Type
opto/node.cpp:      if (cast != NULL && cast->has_range_check()) {
opto/node.cpp:    worklist->push(n);
opto/node.cpp:    st->print(" !orig=");
opto/node.cpp:    if (discon) st->print("[");
opto/node.cpp:      st->print("o");
opto/node.cpp:    st->print("%d", orig->_idx);
opto/node.cpp:    if (discon) st->print("]");
opto/node.cpp:    if (orig != NULL) st->print(",");
opto/node.cpp:      fast = fast->debug_orig();
opto/node.cpp:        fast = fast->debug_orig();
opto/node.cpp:        st->print("...");
opto/node.cpp:  st->print("%c%d%s\t%s\t=== ", is_new ? ' ' : 'o', _idx, mark ? " >" : "", Name());
opto/node.cpp:    st->print("  [%d]",debug_idx());
opto/node.cpp:    st->cr();
opto/node.cpp:    st->print("  [%d]",debug_idx());
opto/node.cpp:      st->print("  Interface:");
opto/node.cpp:      st->print("  Oop:");
opto/node.cpp:      st->print("  Klass:");
opto/node.cpp:    st->print("  Memory:");
opto/node.cpp:    st->print("  Type:");
opto/node.cpp:      st->print("no type");
opto/node.cpp:        st->print(" !jvms:");
opto/node.cpp:  if (suffix) st->print("%s", suffix);
opto/node.cpp:      st->print("_ ");
opto/node.cpp:      st->print("NotANode ");  // uninitialized, sentinel, garbage, etc.
opto/node.cpp:      st->print("%c%d ", Compile::current()->node_arena()->contains(d) ? ' ' : 'o', d->_idx);
opto/node.cpp:      if (!any_prec++) st->print(" |");
opto/node.cpp:      if (NotANode(p)) { st->print("NotANode "); continue; }
opto/node.cpp:      st->print("%c%d ", Compile::current()->node_arena()->contains(in(i)) ? ' ' : 'o', in(i)->_idx);
opto/node.cpp:  st->print(" [[");
opto/node.cpp:      st->print("_ ");
opto/node.cpp:      st->print("NotANode ");
opto/node.cpp:      st->print("%c%d ", Compile::current()->node_arena()->contains(u) ? ' ' : 'o', u->_idx);
opto/node.cpp:  st->print("]] ");
opto/node.cpp:  st->print("%s(%d)", Name(), _idx);
opto/node.cpp:    st->print("%s", suffix);
opto/node.cpp:// Graph walk, with both pre-order and post-order functions
opto/node.cpp:  post(*this,env);              // Call the post-order walk function
opto/node.cpp:    st->print(" #"); _type->dump_on(st);
opto/node.cpp:  st->print("#");
opto/block.cpp:    // Pre- and post-loops have low trip count so do not bother with
opto/block.cpp:  if (_pre_order) st->print("B%d", _pre_order);
opto/block.cpp:  else st->print("N%d", head()->_idx);
opto/block.cpp:    st->print(" (");
opto/block.cpp:    st->print(")");
opto/block.cpp:    st->print(" ");
opto/block.cpp:  st->print(": ");
opto/block.cpp:  st->print("#\tout( ");
opto/block.cpp:    st->print(" ");
opto/block.cpp:  st->print(") <- ");
opto/block.cpp:    st->print("in( ");
opto/block.cpp:        st->print("N%d ", s->_idx );
opto/block.cpp:    st->print(") ");
opto/block.cpp:    st->print("BLOCK HEAD IS JUNK ");
opto/block.cpp:    st->print("Loop( B%d-B%d ", bhead->_pre_order, bx->_pre_order);
opto/block.cpp:    st->print(")");
opto/block.cpp:    st->print("top-of-loop");
opto/block.cpp:  st->print(" Freq: %g",_freq);
opto/block.cpp:    st->print(" IDom: %d/#%d", _idom ? _idom->_pre_order : 0, _dom_depth);
opto/block.cpp:    st->print(" RegPressure: %d",_reg_pressure);
opto/block.cpp:    st->print(" IHRP Index: %d",_ihrp_index);
opto/block.cpp:    st->print(" FRegPressure: %d",_freg_pressure);
opto/block.cpp:    st->print(" FHRP Index: %d",_fhrp_index);
opto/block.cpp:  st->cr();
opto/block.cpp:    } else { // Post-processing visited nodes
opto/block.cpp:        last--;                   // No longer check for being uncommon!
opto/block.cpp:          last--;
opto/block.cpp:        // backup block counter post-increment
opto/block.cpp:      last--;
opto/loopPredicate.cpp:  if (!test->is_Bool()){ //Conv2B, ...
opto/loopPredicate.cpp:  BoolNode* bol = test->as_Bool();
opto/loopPredicate.cpp:          //     in the if_proj list post-dominates "iff". So, the condition of "iff"
opto/live.cpp:    while (_worklist->size()) {
opto/live.cpp:      Block* block = _worklist->pop();
opto/live.cpp:    } // End of while-worklist-not-empty
opto/live.cpp:        _worklist->push(p);     // Actually go on worklist if already 1st pass
opto/live.cpp:      _worklist->push(p);       // Actually go on worklist if already 1st pass
opto/loopopts.cpp:  // (courtesy of a post-order visit) and since they did not we must
opto/loopopts.cpp://------------------------------split_if_with_blocks_post----------------------
opto/loopopts.cpp:// in the post-order, so it can dirty the I-DOM info and not use the dirtied
opto/loopopts.cpp:      // All of n's children have been processed, complete post-processing.
opto/loopopts.cpp:// below the post-loop merge point.
opto/loopopts.cpp:      // below the post-loop merge point.
opto/loopopts.cpp:// then alive with the post-incremented trip counter forcing an extra
opto/loopopts.cpp:  // the fall-out  path (forces the pre-incremented  and post-incremented trip
opto/loopopts.cpp:  // post-increment trip counter.
opto/loopopts.cpp:      // Hit!  Refactor use to use the post-incremented tripcounter.
opto/loopopts.cpp:      // Compute a post-increment tripcounter.
opto/bytecodeInfo.cpp:  for (int i = 0; i < indent; i++) st->print(" ");
opto/bytecodeInfo.cpp:  st->print(" @ %d", caller_bci());
opto/bytecodeInfo.cpp:  st->cr();
opto/memnode.hpp:    *(const Type**)&_type = t;   // cast away const-ness
opto/memnode.hpp:    if (_require_atomic_access)  st->print(" Atomic!");
opto/memnode.hpp:    if (_require_atomic_access)  st->print(" Atomic!");
opto/memnode.hpp:    if (_require_atomic_access)  st->print(" Atomic!");
opto/memnode.hpp:    if (_require_atomic_access)  st->print(" Atomic!");
opto/buildOopMap.cpp:    worklist->push(block);
opto/buildOopMap.cpp:    while( worklist->size() ) { // Standard worklist algorithm
opto/buildOopMap.cpp:      Block *b = worklist->rpop();
opto/buildOopMap.cpp:          worklist->push(block);
opto/buildOopMap.cpp:      worklist->push(cfg->get_block(i));
opto/buildOopMap.cpp:      // We have an OopFlow that's the last-use of a predecessor.
opto/superword.hpp:  VectorSet    _post_visited;  // Post-visited set
opto/domgraph.cpp:      // Build a reverse post-order in the CFG _blocks array
opto/node.hpp:  // Get the worst-case Type output for this Node.
opto/node.hpp:// before continuing the loop.  You must delete only the last-produced
opto/node.hpp:// edge.  You must delete only a single copy of the last-produced edge,
opto/node.hpp://------------------------------Unique_Node_List-------------------------------
opto/node.hpp:    *(const Type**)&_type = t;   // cast away const-ness
opto/castnode.cpp:// Take 'join' of input and cast-up type
opto/castnode.cpp:    cast->set_req(0, c);
opto/castnode.cpp:    cast->set_req(0, c);
opto/castnode.cpp:    st->print(" carry dependency");
opto/castnode.cpp:    st->print(" range check dependency");
opto/castnode.cpp:// Take 'join' of input and cast-up type, unless working with an Interface
opto/coalesce.cpp:  // after the last use.  Last use is really first-use on a backwards scan.
opto/replacednodes.cpp:    st->print("replaced nodes: ");
opto/replacednodes.cpp:      st->print("%d->%d", _replaced_nodes->at(i).initial()->_idx, _replaced_nodes->at(i).improved()->_idx);
opto/replacednodes.cpp:        st->print(",");
opto/arraycopynode.cpp:  st->print(" (%s%s)", _kind_names[_kind], _alloc_tightly_coupled ? ", tightly coupled allocation" : "");
opto/arraycopynode.cpp:  st->print("%s%s", _kind_names[_kind], _alloc_tightly_coupled ? ",tight" : "");
opto/arraycopynode.cpp:        ary_dest == NULL || ary_dest->klass() == NULL) {
opto/arraycopynode.cpp:    BasicType dest_elem = ary_dest->klass()->as_array_klass()->element_type()->basic_type();
opto/arraycopynode.cpp:    dest_offset = Compile::conv_I2X_index(phase, dest_offset, ary_dest->size());
opto/arraycopynode.cpp:  if (dest->is_top()) {
opto/block.hpp:    // so (last->is_block_proj() != last) always, then simplify this code
opto/block.hpp:    assert(last->is_block_proj() == last || last->is_block_proj() == _nodes[last_idx - _num_succs], "");
opto/block.hpp:    return (last->is_block_proj() == last) ? last_idx : (last_idx - _num_succs);
opto/macroArrayCopy.cpp:// Helper function for generating guarded fast-slow graph structures.
opto/macroArrayCopy.cpp:    assert(dest->is_CheckCastPP(), "sanity");
opto/macroArrayCopy.cpp:    assert(dest->in(0)->in(0) == init, "dest pinned");
opto/macroArrayCopy.cpp:        st->as_Store()->set_mismatched_access();
opto/macroArrayCopy.cpp:  const Type* dest_type = dest->Value(&_igvn);
opto/macroArrayCopy.cpp:  if (top_dest != NULL && top_dest->klass() != NULL) {
opto/macroArrayCopy.cpp:    dest_elem = top_dest->klass()->as_array_klass()->element_type()->basic_type();
opto/compile.cpp:  if (dest->is_Con())
opto/compile.cpp:  if (dest != NULL && dest != source && dest->debug_orig() == NULL) {
opto/compile.cpp:    dest->set_debug_orig(source);
opto/compile.cpp:  Node_Notes* dest_notes   = node_notes_at(dest->_idx);
opto/compile.cpp:    return set_node_notes_at(dest->_idx, source_notes);
opto/compile.cpp:  return set_node_notes_at(dest->_idx, &merged_notes);
opto/compile.cpp:        st->print("@ <%d> ", index());
opto/compile.cpp:  else  st->print("@ <%d>",  index());
opto/compile.cpp:  st->print(is_rewritable() ? "   " : " RO");
opto/compile.cpp:        st->print(" +any");
opto/compile.cpp:  else  st->print(" +%-3d", offset);
opto/compile.cpp:  st->print(" in ");
opto/compile.cpp:      st->print(" != ");
opto/compile.cpp:      st->print(" ***");
opto/compile.cpp:    if (tinst && tinst->offset() >= instanceOopDesc::base_offset_in_bytes()) {
opto/compile.cpp:      if (tinst->const_oop() != NULL &&
opto/compile.cpp:          tinst->klass() == ciEnv::current()->Class_klass() &&
opto/compile.cpp:          tinst->offset() >= (tinst->klass()->as_instance_klass()->size_helper() * wordSize)) {
opto/compile.cpp:        ciInstanceKlass* k = tinst->const_oop()->as_instance()->java_lang_Class_klass()->as_instance_klass();
opto/compile.cpp:        field = k->get_field_by_offset(tinst->offset(), true);
opto/compile.cpp:        ciInstanceKlass *k = tinst->klass()->as_instance_klass();
opto/compile.cpp:        field = k->get_field_by_offset(tinst->offset(), false);
opto/compile.cpp:    assert(cast->isa_CastII()->has_range_check(), "CastII should have range check dependency");
opto/compile.cpp:    igvn.replace_node(cast, cast->in(1));
opto/compile.cpp:      // Now do post-visit work
opto/compile.cpp:// (2) Move last-uses by commutative operations to the left input to encourage
opto/compile.cpp:  _print_inlining_list->at(_print_inlining_idx).ss()->write(_print_inlining_stream->base(), _print_inlining_stream->size());
opto/compile.cpp:  _print_inlining_list->insert_before(_print_inlining_idx, PrintInliningBuffer());
opto/compile.cpp:  return _print_inlining_list->at(_print_inlining_idx);
opto/compile.cpp:    for (int i = 0; i < _print_inlining_list->length(); i++) {
opto/compile.cpp:      if (_print_inlining_list->adr_at(i)->cg() == cg) {
opto/compile.cpp:    _print_inlining_list->at_put(_print_inlining_idx, PrintInliningBuffer());
opto/compile.cpp:    for (int i = 0; i < _print_inlining_list->length(); i++) {
opto/compile.cpp:      ss.print("%s", _print_inlining_list->adr_at(i)->ss()->as_string());
opto/compile.cpp:      _print_inlining_list->at(i).freeStream();
opto/parse1.cpp:  // Walk over all blocks in Reverse Post-Order.
opto/parse1.cpp:  if (tinst != NULL && tinst->klass()->is_loaded() && !tinst->klass_is_exact()) {
opto/parse1.cpp:    ciInstanceKlass* ik = tinst->klass()->as_instance_klass();
opto/cfgnode.cpp:  // The worst-case type (from ciTypeFlow) should be consistent with "t".
opto/cfgnode.cpp:// values merging here.  We replace the test-and-branch with:
opto/cfgnode.cpp:    st->print(" #tripcount");
opto/cfgnode.cpp:  st->print("@bci %d ",_dest_bci);
opto/cfgnode.cpp:  st->print("(%d)%d@%d", _switch_val, _proj_no, _dest_bci);
opto/cfgnode.cpp:  st->print("@bci %d ",_handler_bci);
opto/cfgnode.cpp:  st->print("%s", Name());
opto/escape.cpp:      delayed_worklist->push(n);
opto/escape.cpp:        delayed_worklist->push(n); // Process it later.
opto/escape.cpp:      delayed_worklist->push(n);
opto/escape.cpp:        delayed_worklist->push(n);
opto/escape.cpp:      delayed_worklist->push(n); // Process it later.
opto/escape.cpp:    delayed_worklist->push(n); // Process it later.
opto/escape.cpp:      delayed_worklist->push(n); // Process unsafe access later.
opto/escape.cpp:  assert(!src->is_Field() && !dst->is_Field(), "only for JavaObject and LocalVar");
opto/escape.cpp:  dst->set_arraycopy_dst();
opto/escape.cpp:      _compile->get_alias_index(tinst->add_offset(oopDesc::mark_offset_in_bytes()));
opto/escape.cpp:      _compile->get_alias_index(tinst->add_offset(oopDesc::klass_offset_in_bytes()));
opto/escape.cpp:        assert(tinst != NULL && tinst->is_known_instance() &&
opto/escape.cpp:               tinst->instance_id() == jobj->idx() , "instance type expected.");
opto/escape.cpp:        if (tn_t != NULL && tinst->klass()->is_subtype_of(tn_t->klass())) {
opto/escape.cpp:            tn_type = tinst->make_narrowoop();
opto/escape.cpp:                 tn_t != NULL && !tinst->klass()->is_subtype_of(tn_t->klass()),
opto/escape.cpp:    if (dest->is_AddP()) {
opto/chaitin.hpp:  // Post-Allocation peephole copy removal
opto/parse2.cpp:    if (!tst->is_Con()) {
opto/parse2.cpp:  if (test->is_Cmp() &&
opto/parse2.cpp:      test->in(1)->Opcode() == Op_ProfileBoolean) {
opto/parse2.cpp:    ProfileBooleanNode* profile = (ProfileBooleanNode*)test->in(1);
opto/parse2.cpp:  if (tst->is_Bool()) {
opto/parse2.cpp:      btest = tst->as_Bool()->_test._test;
opto/parse2.cpp:        tst   = _gvn.transform( tst->as_Bool()->negate(&_gvn) );
opto/parse2.cpp:        btest = tst->as_Bool()->_test._test;
opto/parse2.cpp:      c = tst->in(1);
opto/parse2.cpp:            const Type* tcc = ccast->as_Type()->type();
opto/parse2.cpp:    const Type* tcc = ccast->as_Type()->type();
opto/parse2.cpp:    ccast->set_req(0, control());
opto/type.cpp:  if( this_inst && this_inst->is_loaded() && t_inst && t_inst->is_loaded() ) {
opto/type.cpp:    bool this_interface = this_inst->klass()->is_interface();
opto/type.cpp:    bool    t_interface =    t_inst->klass()->is_interface();
opto/type.cpp:  st->print("%s", _type_info[_base].msg);
opto/type.cpp:    st->print(" [narrow]");
opto/type.cpp:    st->print(" [narrowklass]");
opto/type.cpp:  st->print("%f", _f);
opto/type.cpp:  st->print("%f", _d);
opto/type.cpp:    st->print("int");
opto/type.cpp:    st->print("int:%s", intname(buf, get_con()));
opto/type.cpp:    st->print("bool");
opto/type.cpp:    st->print("byte");
opto/type.cpp:    st->print("char");
opto/type.cpp:    st->print("short");
opto/type.cpp:    st->print("int:>=%s", intname(buf, _lo));
opto/type.cpp:    st->print("int:<=%s", intname(buf, _hi));
opto/type.cpp:    st->print("int:%s..%s", intname(buf, _lo), intname(buf2, _hi));
opto/type.cpp:    st->print(":%.*s", _widen, "wwww");
opto/type.cpp:    st->print("long");
opto/type.cpp:    st->print("long:%s", longname(buf, get_con()));
opto/type.cpp:    st->print("long:>=%s", longname(buf, _lo));
opto/type.cpp:    st->print("long:<=%s", longname(buf, _hi));
opto/type.cpp:    st->print("long:%s..%s", longname(buf, _lo), longname(buf2, _hi));
opto/type.cpp:    st->print(":%.*s", _widen, "wwww");
opto/type.cpp:  st->print("{");
opto/type.cpp:    st->print("...}");
opto/type.cpp:      st->print("%d:", i);
opto/type.cpp:      st->print(", ");
opto/type.cpp:    st->print("%d:", i);
opto/type.cpp:  st->print("}");
opto/type.cpp:  if (_stable)  st->print("stable:");
opto/type.cpp:  st->print("[");
opto/type.cpp:  st->print("]");
opto/type.cpp:    st->print("vectora["); break;
opto/type.cpp:    st->print("vectors["); break;
opto/type.cpp:    st->print("vectord["); break;
opto/type.cpp:    st->print("vectorx["); break;
opto/type.cpp:    st->print("vectory["); break;
opto/type.cpp:    st->print("vectorz["); break;
opto/type.cpp:  st->print("%d]:{", _length);
opto/type.cpp:  st->print("}");
opto/type.cpp:  if( _ptr == Null ) st->print("NULL");
opto/type.cpp:  else st->print("%s *", ptr_msg[_ptr]);
opto/type.cpp:  if( _offset == OffsetTop ) st->print("+top");
opto/type.cpp:  else if( _offset == OffsetBot ) st->print("+bot");
opto/type.cpp:  else if( _offset ) st->print("+%d", _offset);
opto/type.cpp:    st->print(" (speculative=");
opto/type.cpp:    st->print(")");
opto/type.cpp:      st->print(" (inline_depth=InlineDepthTop)");
opto/type.cpp:      st->print(" (inline_depth=%d)", _inline_depth);
opto/type.cpp:    st->print(INTPTR_FORMAT, p2i(_bits));
opto/type.cpp:    st->print("rawptr:%s", ptr_msg[_ptr]);
opto/type.cpp:  st->print("oopptr:%s", ptr_msg[_ptr]);
opto/type.cpp:  if( _klass_is_exact ) st->print(":exact");
opto/type.cpp:  if( const_oop() ) st->print(INTPTR_FORMAT, p2i(const_oop()));
opto/type.cpp:  case OffsetTop: st->print("+top"); break;
opto/type.cpp:  case OffsetBot: st->print("+any"); break;
opto/type.cpp:  default:        st->print("+%d",_offset); break;
opto/type.cpp:    st->print(",iid=top");
opto/type.cpp:    st->print(",iid=%d",_instance_id);
opto/type.cpp:    int off = meet_offset(tinst->offset());
opto/type.cpp:    PTR ptr = meet_ptr(tinst->ptr());
opto/type.cpp:    int instance_id = meet_instance_id(tinst->instance_id());
opto/type.cpp:    int depth = meet_inline_depth(tinst->inline_depth());
opto/type.cpp:    int off = meet_offset( tinst->offset() );
opto/type.cpp:    PTR ptr = meet_ptr( tinst->ptr() );
opto/type.cpp:    int instance_id = meet_instance_id(tinst->instance_id());
opto/type.cpp:    int depth = meet_inline_depth(tinst->inline_depth());
opto/type.cpp:    if (ptr != Constant && klass()->equals(tinst->klass()) && klass_is_exact() == tinst->klass_is_exact()) {
opto/type.cpp:    ciKlass* tinst_klass = tinst->klass();
opto/type.cpp:    bool tinst_xk = tinst->klass_is_exact();
opto/type.cpp:        tty->print(" tinst == "); tinst->dump(); tty->cr();
opto/type.cpp:        o = (this_klass == klass()) ? const_oop() : tinst->const_oop();
opto/type.cpp:      } else if( above_centerline(this ->_ptr) && !above_centerline(tinst->_ptr) ) {
opto/type.cpp:      } else if( above_centerline(tinst->_ptr) && !above_centerline(this ->_ptr) ) {
opto/type.cpp:      ciObject* tinst_oop = tinst->const_oop();
opto/type.cpp:      if( _klass_is_exact ) st->print(":exact");
opto/type.cpp:    st->print(":%s", ptr_msg[_ptr]);
opto/type.cpp:    if( _klass_is_exact ) st->print(":exact");
opto/type.cpp:    if( _offset == OffsetBot )      st->print("+any");
opto/type.cpp:    else if( _offset == OffsetTop ) st->print("+unknown");
opto/type.cpp:    else st->print("+%d", _offset);
opto/type.cpp:  st->print(" *");
opto/type.cpp:    st->print(",iid=top");
opto/type.cpp:    st->print(",iid=%d",_instance_id);
opto/type.cpp:  // Negative length arrays will produce weird intermediate dead fast-path code
opto/type.cpp:      if( _klass_is_exact ) st->print(":exact");
opto/type.cpp:    st->print(":%s", ptr_msg[_ptr]);
opto/type.cpp:    if( _klass_is_exact ) st->print(":exact");
opto/type.cpp:    if( _offset == OffsetTop )       st->print("+undefined");
opto/type.cpp:    else if( _offset == OffsetBot )  st->print("+any");
opto/type.cpp:    else if( _offset < header_size ) st->print("+%d", _offset);
opto/type.cpp:      st->print("[%d]", (_offset - array_base)/elem_size);
opto/type.cpp:  st->print(" *");
opto/type.cpp:    st->print(",iid=top");
opto/type.cpp:    st->print(",iid=%d",_instance_id);
opto/type.cpp:  st->print("narrowoop: ");
opto/type.cpp:  st->print("narrowklass: ");
opto/type.cpp:  st->print("metadataptr:%s", ptr_msg[_ptr]);
opto/type.cpp:  if( metadata() ) st->print(INTPTR_FORMAT, p2i(metadata()));
opto/type.cpp:  case OffsetTop: st->print("+top"); break;
opto/type.cpp:  case OffsetBot: st->print("+any"); break;
opto/type.cpp:  default:        st->print("+%d",_offset); break;
opto/type.cpp:    k_ary = ciObjArrayKlass::make(tinst->klass());
opto/type.cpp:    // we need to cast away const-ness.
opto/type.cpp:    st->print("precise ");
opto/type.cpp:        st->print("klass %s: " INTPTR_FORMAT, name, p2i(klass()));
opto/type.cpp:    st->print(":%s", ptr_msg[_ptr]);
opto/type.cpp:    if( _klass_is_exact ) st->print(":exact");
opto/type.cpp:    if( _offset == OffsetBot )      { st->print("+any"); }
opto/type.cpp:    else if( _offset == OffsetTop ) { st->print("+unknown"); }
opto/type.cpp:    else                            { st->print("+%d", _offset); }
opto/type.cpp:  st->print(" *");
opto/type.cpp:    st->print("void");
opto/type.cpp:      st->print("/");
opto/type.cpp:  st->print(" ");
opto/type.cpp:  st->print("( ");
opto/type.cpp:    st->print("...)");
opto/type.cpp:    st->print(", ");
opto/type.cpp:  st->print(" )");
opto/loopnode.hpp:// CountedLoopNode if there is control flow in the loop), the post-increment
opto/loopnode.hpp:  // For Pre- and Post-loops during debugging ONLY, this holds the index of
opto/loopnode.hpp:  // A 'main' loop has a pre-loop and a post-loop.  The 'main' loop
opto/loopnode.hpp:  // Array of pre-order numbers, plus post-visited bit.
opto/loopnode.hpp:  // ZERO for not pre-visited.  EVEN for pre-visited but not post-visited.
opto/loopnode.hpp:  // ODD for post-visited.  Other bits are the pre-order number.
opto/loopnode.hpp:  // Check for being post-visited.
opto/loopnode.hpp:    // Fast-path NULL lca
opto/loopnode.hpp:  // Return a post-walked LoopNode
opto/loopnode.hpp:  // and inserting an if to select fast-slow versions.
opto/loopnode.hpp:  // the pre-loop or the post-loop until the condition holds true in the main
opto/loopnode.hpp:  // (which are then alive with the post-incremented trip counter
opto/loopTransform.cpp:    if (test->is_If()) {    // Test?
opto/loopTransform.cpp:      Node *ctrl = phase->get_ctrl(test->in(1));
opto/loopTransform.cpp:      assert(test->Opcode() == Op_If ||
opto/loopTransform.cpp:             test->Opcode() == Op_CountedLoopEnd ||
opto/loopTransform.cpp:             test->Opcode() == Op_RangeCheck,
opto/loopTransform.cpp:          test->is_If() &&      // Test?
opto/loopTransform.cpp:          !test->in(1)->is_Con() && // And not already obvious?
opto/loopTransform.cpp:          !loop->is_member(get_loop(get_ctrl(test->in(1))))){
opto/loopTransform.cpp:          if (n->is_If() && n->in(1) == test->in(1) /*&& n != loop->tail()->in(0)*/) {
opto/loopTransform.cpp:  // Step A: Create a new post-Loop.
opto/loopTransform.cpp:  // Step A1: Clone the loop body of main. The clone becomes the post-loop.
opto/loopTransform.cpp:  // Reduce the post-loop trip count.
opto/loopTransform.cpp:  // Step A2: Build a zero-trip guard for the post-loop.  After leaving the
opto/loopTransform.cpp:  // main-loop, the post-loop may not execute at all.  We 'opaque' the incr
opto/loopTransform.cpp:  // Plug in the false-path, taken if we need to skip this post-loop
opto/loopTransform.cpp:  // Step A3: Make the fall-in values to the post-loop come from the
opto/loopTransform.cpp:// the pre-loop or the post-loop until the condition holds true in the main
opto/loopTransform.cpp:  // pre-loop must check for underflow and the post-loop for overflow.
opto/loopTransform.cpp:  // post-loop for underflow.
opto/loopTransform.cpp:    // post-loop for underflow.
opto/loopTransform.cpp:    uint top = test->Opcode();
opto/loopTransform.cpp:      IfNode *iff = test->in(0)->as_If();
opto/loopTransform.cpp:  // Do nothing special to pre- and post- loops
opto/loopTransform.cpp:  // A post-loop will finish any odd iterations (leftover after
opto/loopTransform.cpp:  // we switch to the pre-/main-/post-loop model.  This model also covers
opto/loopTransform.cpp:    // and we'd rather unroll the post-RCE'd loop SO... do not unroll if
opto/loopTransform.cpp:  if (cast)  ok.set(cast->_idx);
opto/opaquenode.cpp:// pre- and post-increment values both being live and thus requiring an extra
opto/lcm.cpp:  if (best->in(0) == not_null_block->head()) {
opto/lcm.cpp:    best->set_req(0, proj->in(0)->in(0));
opto/lcm.cpp:  for (DUIterator_Fast jmax, j = best->fast_outs(jmax); j < jmax; j++) {
opto/lcm.cpp:    Node* n = best->fast_out(j);
opto/lcm.cpp:  MachNode *nul_chk = new MachNullCheckNode(old_tst->in(0),best,bidx);
opto/lcm.cpp:  for (DUIterator_Last i2min, i2 = old_tst->last_outs(i2min); i2 >= i2min; --i2)
opto/lcm.cpp:    old_tst->last_out(i2)->set_req(0, nul_chk);
opto/lcm.cpp:  for (uint i3 = 0; i3 < old_tst->req(); i3++) {
opto/lcm.cpp:    Node* in = old_tst->in(i3);
opto/lcm.cpp:    old_tst->set_req(i3, NULL);
opto/lcm.cpp:  if (! best->needs_anti_dependence_check()) {
opto/lcm.cpp:          n->in(LoadNode::Memory) == best->in(StoreNode::Memory)) {
opto/runtime.cpp:// We failed the fast-path allocation.  Now we need to do a scavenge or GC
opto/runtime.cpp:  // the dominant fast-path is to simply return.
opto/runtime.cpp:  // This is the case the fast-path above isn't provisioned to handle.
opto/runtime.cpp:  // The fast-path is designed to handle frequently arising cases in an efficient manner.
opto/runtime.cpp:  // (The fast-path is just a degenerate variant of the slow-path).
opto/runtime.cpp:  // This is the case the fast-path above isn't provisioned to handle.
opto/runtime.cpp:  // The fast-path is designed to handle frequently arising cases in an efficient manner.
opto/runtime.cpp:  // (The fast-path is just a degenerate variant of the slow-path).
opto/runtime.cpp:  st->print_raw_cr(tempst.as_string());
opto/escape.hpp:        delayed_worklist->push(n);
opto/graphKit.hpp:  // Return a cast-not-null node which depends on the not-null control.
opto/graphKit.hpp:    if (!tst->is_Con())  record_for_igvn(iff);     // Range-check and Null-check removal is later
opto/graphKit.hpp:    if (!tst->is_Con())  record_for_igvn(iff);     // Range-check and Null-check removal is later
opto/machnode.cpp:      st->print(" _");
opto/machnode.cpp:      st->print(" Volatile!");
opto/machnode.cpp:    st->print(" NULL");
opto/machnode.cpp:  st->print("%s %s", Name(), Matcher::regName[reg]);
opto/machnode.cpp:  case unmatched_proj:  st->print("/unmatched");                           break;
opto/machnode.cpp:  case fat_proj:        st->print("/fat"); if (WizardMode) _rout.dump(st); break;
opto/machnode.cpp:  st->print("P=%f, C=%f",_prob, _fcnt);
opto/machnode.cpp:  st->print("# ");
opto/machnode.cpp:  if (_cnt != COUNT_UNKNOWN)  st->print(" C=%f",_cnt);
opto/machnode.cpp:    st->print("MethodHandle ");
opto/machnode.cpp:    st->print(" ");
opto/machnode.cpp://----------------------------uncommon_trap_request----------------------------
opto/machnode.cpp:    st->print("(%s)",
opto/machnode.cpp:  st->print("Static ");
opto/machnode.cpp:    st->print("wrapper for: %s", _name );
opto/machnode.cpp:    st->print(" ");
opto/machnode.cpp:  st->print("Dynamic ");
opto/machnode.cpp:  st->print("%s ",_name);
opto/machnode.cpp:  st->print("B%d", _block_num);
opto/machnode.cpp:  st->print(INTPTR_FORMAT, _method);
opto/phaseX.cpp:  worklist->remove_useless_nodes(_useful.member_set());
opto/phaseX.cpp:  uint worklist_size = worklist->size();
opto/phaseX.cpp:    if (worklist->member(n)) {
opto/phaseX.cpp:      new_worklist->push(n);
opto/phaseX.cpp:  assert(worklist_size == new_worklist->size(), "the new worklist must have the same size as the original worklist");
opto/phaseX.cpp:  while (modified_list != NULL && modified_list->size()) {
opto/phaseX.cpp:    Node* n = modified_list->pop();
opto/phaseX.cpp:  while (modified_list != NULL && modified_list->size()) {
opto/phaseX.cpp:    Node* n = modified_list->pop();
opto/phaseX.cpp:  while (modified_list->size()) {
opto/phaseX.cpp:    Node* n = modified_list->pop();
opto/phaseX.cpp:      if (cast != NULL && cast->has_range_check()) {
opto/phaseX.cpp://------------------------------add_users_to_worklist--------------------------
opto/locknode.hpp:  virtual void dump_spec(outputStream *st) const { st->print("  Lock %d",_slot); }
opto/multnode.cpp:void ProjNode::dump_spec(outputStream *st) const { st->print("#%d",_con); if(_is_io_use) st->print(" (i_o_use)");}
opto/multnode.cpp:      st->print("[?]");
opto/multnode.cpp:      st->print("[_]");
opto/multnode.cpp:      st->print("[%d]", o->_idx);
opto/multnode.cpp:  st->print("#%d", _con);
opto/output.cpp:  // branch-at-end), plus just-prior exception-throwing call.
opto/output.cpp:    if( last->is_MachIf() && last->in(1) == n &&
opto/output.cpp:    while (_bb_end > 0 && last->is_Mach() &&
opto/output.cpp:           last->as_Mach()->ideal_Opcode() == Op_Con) {
opto/output.cpp:    assert(!last->is_Mach() || last->as_Mach()->ideal_Opcode() != Op_Con, "");
opto/output.cpp:    if( last->is_Catch() ||
opto/output.cpp:        (last->is_Mach() && last->as_Mach()->ideal_Opcode() == Op_Halt) ) {
opto/output.cpp:    } else if( last->is_MachNullCheck() ) {
opto/output.cpp:      Node *mem = last->in(1);
opto/output.cpp:  st->print_cr("#");
opto/output.cpp:  st->print("#  ");  C->tf()->dump_on(st);  st->cr();
opto/output.cpp:  st->print_cr("#");
opto/output.cpp:      st->print("%*.*x", pc_digits, pc_digits, pc);
opto/output.cpp:    st->fill_to(prefix_len);
opto/output.cpp:      st->fill_to(prefix_len);
opto/output.cpp:      st->print_cr("# Empty connector block");
opto/output.cpp:      st->fill_to(prefix_len);
opto/output.cpp:      st->print_cr("# Block is sole successor of call");
opto/output.cpp:          st->print("%*.*x", pc_digits, pc_digits, pc);
opto/output.cpp:          st->fill_to(pc_digits);
opto/output.cpp:        st->print(" %c ", starts_bundle);
opto/output.cpp:        st->fill_to(prefix_len);
opto/output.cpp:        st->cr();
opto/output.cpp:          st->print("%*.*x", pc_digits, pc_digits, pc);
opto/output.cpp:          st->fill_to(pc_digits);
opto/output.cpp:        st->print(" %c ", starts_bundle);
opto/output.cpp:        st->fill_to(prefix_len);
opto/output.cpp:        st->cr();
opto/output.cpp:      st->bol(); // Make sure we start on a new line
opto/output.cpp:    st->cr(); // one empty line between blocks
opto/output.cpp:  if (cut_short)  st->print_cr("*** disassembly is cut short ***");
opto/ifnode.cpp:    dist--;
opto/ifnode.cpp:  st->print("P=%f, C=%f",_prob,_fcnt);
opto/ifnode.cpp://------------------------------idealize_test----------------------------------
opto/ifnode.cpp:    // so all checks we inspect post-dominate the top-most check we find.
opto/ifnode.cpp:    // We 'expand' the top 3 range checks to include all post-dominating
opto/parseHelper.cpp://------------------------------do_checkcast-----------------------------------
opto/parseHelper.cpp://--------------------------profile_null_checkcast----------------------------
opto/compile.hpp:  // Final graph reshaping, a post-pass after the regular optimizer is done.
opto/compile.hpp:  // Update histogram.  Return boolean if this is a first-time occurrence.
opto/live.hpp://------------------------------LRG_List---------------------------------------
opto/loopnode.cpp:  if (is_inner_loop()) st->print( "inner " );
opto/loopnode.cpp:  if (is_partial_peel_loop()) st->print( "partial_peel " );
opto/loopnode.cpp:  if (partial_peel_has_failed()) st->print( "partial_peel_failed " );
opto/loopnode.cpp:  bt = test->_test._test;
opto/loopnode.cpp:  Node* cmp = test->in(1);
opto/loopnode.cpp:  test = test->clone()->as_Bool();
opto/loopnode.cpp:  (*(BoolTest*)&test->_test)._test = bt;
opto/loopnode.cpp:  test->set_req(1,cmp);
opto/loopnode.cpp:    st->print("stride: %d ",stride_con());
opto/loopnode.cpp:  if (is_pre_loop ()) st->print("pre of N%d" , _main_idx);
opto/loopnode.cpp:  if (is_main_loop()) st->print("main of N%d", _idx);
opto/loopnode.cpp:  if (is_post_loop()) st->print("post of N%d", _main_idx);
opto/loopnode.cpp:  if (is_strip_mined()) st->print(" strip mined");
opto/loopnode.cpp:          Node* next = first->in(MemNode::Memory);
opto/loopnode.cpp:          for (DUIterator_Fast jmax, j = last->fast_outs(jmax); j < jmax; j++) {
opto/loopnode.cpp:            Node* uu = last->fast_out(j);
opto/loopnode.cpp:            if (be == last || be == first->in(MemNode::Memory)) {
opto/loopnode.cpp:          phi = PhiNode::make(this, first->in(MemNode::Memory), Type::MEMORY,
opto/loopnode.cpp:          if (be == first->in(MemNode::Memory)) {
opto/loopnode.cpp:    st->print("[");
opto/loopnode.cpp:    st->print("]");
opto/loopnode.cpp:  st->print(" ");
opto/loopnode.cpp://------------------------------set_nest---------------------------------------
opto/loopnode.cpp:  assert( loop_preorder, "not yet post-walked loop" );
opto/loopnode.cpp:    assert( l_preorder, "not yet post-walked l" );
opto/loopnode.cpp:// I use a modified Vick/Tarjan algorithm.  I need pre- and a post- visit
opto/loopnode.cpp:// not-yet-pre-walked, pre-order # for pre-but-not-post-walked and holds the
opto/loopnode.cpp:// tightest enclosing IdealLoopTree for post-walked.
opto/loopnode.cpp:// Once I've done the forward recursion, I do the post-work.  For each child
opto/loopnode.cpp:// During the post-work I also check to see if I have several children
opto/loopnode.cpp:      // Pre-walked but not post-walked nodes need a pre_order number.
opto/loopnode.cpp:                !is_postvisited(l) &&  // But not post-visited
opto/loopnode.cpp:      (void)bltstack.pop(); // Remove post-visited node from stack
opto/loopnode.cpp:  // ---- Post-pass Work ----
opto/loopnode.cpp:  // Pre-walked but not post-walked nodes need a pre_order number.
opto/loopnode.cpp:    if( !is_postvisited(m) ) {  // Child visited but not post-visited?
opto/loopnode.cpp:        // new loop exit.  This would make the infinite loop a first-class
opto/loopnode.cpp:    // IS the post-work phase).  Is this child's loop header post-visited
opto/loopnode.cpp:  if( innermost && innermost->_head == n ) {
opto/loopnode.cpp:    IdealLoopTree *p = innermost->_parent;
opto/loopnode.cpp:    // Record tightest enclosing loop for self.  Mark as post-visited.
opto/loopnode.cpp:            innermost->_has_call = 1;
opto/loopnode.cpp:        innermost->_allow_optimizations = false;
opto/loopnode.cpp:        innermost->_has_call = 1; // = true
opto/loopnode.cpp:        if (innermost->_safepts == NULL) innermost->_safepts = new Node_List();
opto/loopnode.cpp:        innermost->_safepts->push(n);
opto/loopnode.cpp:  // Flag as post-visited now
opto/loopnode.cpp:        // All of n's inputs have been processed, complete post-processing.
opto/loopnode.cpp:        // All of n's children have been processed, complete post-processing.
opto/loopnode.cpp://------------------------------build_loop_late_post---------------------------
opto/loopnode.cpp:    Node* ctrl_out = least->unique_ctrl_out();
opto/loopnode.cpp:// Result list is in post-order (scan backwards for RPO)
opto/regmask.cpp:  case Special: st->print("r---"); break;
opto/regmask.cpp:  case Bad:     st->print("rBAD"); break;
opto/regmask.cpp:    if (r < _last_Mach_Reg) st->print("%s", Matcher::regName[r]);
opto/regmask.cpp:    else st->print("rS%d",r);
opto/regmask.cpp:// Find the lowest-numbered register set in the mask.  Return the
opto/regmask.cpp:  st->print("[");
opto/regmask.cpp:          st->print(",");       // 2-register run; print as "rX,rY"
opto/regmask.cpp:          st->print("-");
opto/regmask.cpp:        st->print(",");         // Seperate start of new run
opto/regmask.cpp:      st->print(",");           // 2-register run; print as "rX,rY"
opto/regmask.cpp:      st->print("-");
opto/regmask.cpp:    if (rm.is_AllStack()) st->print("...");
opto/regmask.cpp:  st->print("]");
opto/chaitin.cpp:        // if( test->is_Mach() ) {
opto/chaitin.cpp:        //   MachNode *m = test->as_Mach();
opto/chaitin.cpp:    // Low degree, dead or must-spill guys just get to simplify right away
opto/chaitin.cpp:      // going through a just-lo-degree stage: If you remove a double from
opto/chaitin.cpp:      // just-lo-degree stage.  It's very rare (shows up after 5000+ methods
opto/chaitin.cpp:  // CNC - Fun hack.  Alternate 1st and 2nd selection.  Enables post-allocate
opto/chaitin.cpp:  // copy removal to remove many more copies, by preventing a just-assigned
opto/chaitin.cpp:      // Note that reg is the highest-numbered register in the newly-bound mask.
opto/chaitin.cpp:              "No dead instructions after post-alloc" );
opto/chaitin.cpp:    if( _node_regs ) {          // Got a post-allocation copy of allocation?
opto/graphKit.cpp:      if (dst->in(0) != region) {
opto/graphKit.cpp:        while (dst->req() > orig_width)  dst->del_req(dst->req()-1);
opto/graphKit.cpp:        assert(dst->is_Phi(), "nobody else uses a hidden region");
opto/graphKit.cpp:        phi = dst->as_Phi();
opto/graphKit.cpp:        while (dst->req() < region->req())  add_one_req(dst, src);
opto/graphKit.cpp:  // must-be-null assertion has failed.  This could cause performance
opto/graphKit.cpp:  cast->init_req(0, control());
opto/graphKit.cpp:    st->as_Store()->set_unaligned_access();
opto/graphKit.cpp:    st->as_Store()->set_mismatched_access();
opto/graphKit.cpp:    st->as_Store()->set_unsafe_access();
opto/graphKit.cpp:// Make a cast-not-nullness use the other not-null control.  Return cast.
opto/graphKit.cpp:// Optimize the fast-check IfNode.  Set the fast-path region slot 2.
opto/graphKit.cpp:  region->init_req(2,fast_taken); // Capture fast-control
opto/graphKit.cpp:  // Worst-case type is a little odd: NULL is allowed as a result (usually
opto/graphKit.cpp://-------------------------------gen_checkcast---------------------------------
opto/graphKit.cpp:  // from sliding up past the just-emitted store.
opto/graphKit.cpp:  if (initial_slow_test->is_Bool()) {
opto/graphKit.cpp:    initial_slow_test = initial_slow_test->as_Bool()->as_int_value(&_gvn);
opto/idealKit.cpp:    st->as_Store()->set_mismatched_access();
opto/idealKit.cpp:  // Merge the other fast-memory inputs with the new slow-default memory.
opto/callnode.cpp:void StartNode::dump_spec(outputStream *st) const { st->print(" #"); _domain->dump_on(st);}
opto/callnode.cpp:    st->print("%s", names[_con]);
opto/callnode.cpp:    st->print("Parm%d: ",_con-TypeFunc::Parms);
opto/callnode.cpp:    st->print("%s", names[_con]);
opto/callnode.cpp:    st->print("%d:", _con-TypeFunc::Parms);
opto/callnode.cpp:    if (i == TypeFunc::Parms) st->print("returns");
opto/callnode.cpp:    if (in(i)) st->print("%c%d ", Compile::current()->node_arena()->contains(in(i)) ? ' ' : 'o', in(i)->_idx);
opto/callnode.cpp:    else st->print("_ ");
opto/callnode.cpp:    if (i == TypeFunc::Parms) st->print("exception");
opto/callnode.cpp:    if (in(i)) st->print("%c%d ", Compile::current()->node_arena()->contains(in(i)) ? ' ' : 'o', in(i)->_idx);
opto/callnode.cpp:    else st->print("_ ");
opto/callnode.cpp:  if (n == NULL) { st->print(" NULL"); return; }
opto/callnode.cpp:    st->print(" %s%d]=#ScObj" INT32_FORMAT, msg, i, sco_n);
opto/callnode.cpp:    st->print(" %s%d]=%s",msg,i,buf);
opto/callnode.cpp:      st->print(" %s%d]=#" INT32_FORMAT,msg,i,t->is_int()->get_con());
opto/callnode.cpp:      st->print(" %s%d]=#NULL",msg,i);
opto/callnode.cpp:      st->print(" %s%d]=#Ptr" INTPTR_FORMAT,msg,i,p2i(t->isa_oopptr()->const_oop()));
opto/callnode.cpp:      st->print(" %s%d]=#Ptr" INTPTR_FORMAT,msg,i,p2i(t->make_ptr()->isa_klassptr()->klass()));
opto/callnode.cpp:      st->print(" %s%d]=#Ptr" INTPTR_FORMAT,msg,i,p2i(t->make_ptr()->isa_metadataptr()->metadata()));
opto/callnode.cpp:      st->print(" %s%d]=#Ptr" INTPTR_FORMAT,msg,i,p2i(t->make_ptr()->isa_oopptr()->const_oop()));
opto/callnode.cpp:      st->print(" %s%d]=#Raw" INTPTR_FORMAT,msg,i,p2i(t->is_rawptr()));
opto/callnode.cpp:      st->print(" %s%d]=#%fD",msg,i,t->is_double_constant()->_d);
opto/callnode.cpp:      st->print(" %s%d]=#%fF",msg,i,t->is_float_constant()->_f);
opto/callnode.cpp:      st->print(" %s%d]=#" INT64_FORMAT,msg,i,(int64_t)(t->is_long()->get_con()));
opto/callnode.cpp:      st->print(" %s%d]=_",msg,i);
opto/callnode.cpp:  st->print("        #");
opto/callnode.cpp:    st->print(" @ bci:%d ",_bci);
opto/callnode.cpp:    st->print_cr(" runtime stub ");
opto/callnode.cpp:        st->print(" oob ");
opto/callnode.cpp:        st->print(" MON-BOX%d=%s+%d",
opto/callnode.cpp:      st->cr();
opto/callnode.cpp:      st->print("        # ScObj" INT32_FORMAT " ", i);
opto/callnode.cpp:        st->print("[%d]", spobj->n_fields());
opto/callnode.cpp:        st->print("[%d]", spobj->n_fields());
opto/callnode.cpp:          st->print("[]");
opto/callnode.cpp:      st->print("={");
opto/callnode.cpp:          st->print(" [");
opto/callnode.cpp:            st->print(", [");
opto/callnode.cpp:      st->print(" }");
opto/callnode.cpp:  st->cr();
opto/callnode.cpp:        st->print(" %s", endcn);
opto/callnode.cpp:    st->print(" @ bci:%d",_bci);
opto/callnode.cpp:      st->print(" reexecute");
opto/callnode.cpp:    st->print(" runtime stub");
opto/callnode.cpp:  st->print("JVMS depth=%d loc=%d stk=%d arg=%d mon=%d scalar=%d end=%d mondepth=%d sp=%d bci=%d reexecute=%s method=",
opto/callnode.cpp:    st->print_cr("(none)");
opto/callnode.cpp:    st->cr();
opto/callnode.cpp:      st->print("    bc: ");
opto/callnode.cpp:    if (i == TypeFunc::Parms) st->print("(");
opto/callnode.cpp:    if (in(i)) st->print("%c%d ", Compile::current()->node_arena()->contains(in(i)) ? ' ' : 'o', in(i)->_idx);
opto/callnode.cpp:    else st->print("_ ");
opto/callnode.cpp:  st->print(")");
opto/callnode.cpp:  st->print(" ");
opto/callnode.cpp:  if (_cnt != COUNT_UNKNOWN)  st->print(" C=%f",_cnt);
opto/callnode.cpp:    if (!dest->is_top() && may_modify_arraycopy_helper(phase->type(dest)->is_oopptr(), t_oop, phase)) {
opto/callnode.cpp:    st->print("<?>");
opto/callnode.cpp://----------------------------uncommon_trap_request----------------------------
opto/callnode.cpp:  st->print("# Static ");
opto/callnode.cpp:    st->print("%s", _name);
opto/callnode.cpp:      st->print("(%s)",
opto/callnode.cpp:    st->print(" ");
opto/callnode.cpp:    st->print("%s", _name);
opto/callnode.cpp:    st->print("<?>");
opto/callnode.cpp:  st->print("# Dynamic ");
opto/callnode.cpp:  st->print("# ");
opto/callnode.cpp:  st->print("%s", _name);
opto/callnode.cpp:  st->print("# ");
opto/callnode.cpp:  st->print("%s", _name);
opto/callnode.cpp:  st->print(" SafePoint ");
opto/callnode.cpp:  st->print(" # fields@[%d..%d]", first_index(),
opto/callnode.cpp:  st->print("%s ", _kind_names[_kind]);
opto/callnode.cpp:  st->print("%s", _kind_names[_kind]);
opto/convertnode.cpp:          // post-unrolling graph cleanup.  Choose a type which depends only
opto/library_call.cpp:// Helper function for generating guarded fast-slow graph structures.
opto/library_call.cpp:    ccast->set_req(0, control());
opto/library_call.cpp:  const Type* dst_type = dst->Value(&_gvn);
opto/library_call.cpp:      assert(dst->is_CheckCastPP(), "sanity");
opto/library_call.cpp:      assert(dst->in(0)->in(0) == init, "dest pinned");
opto/library_call.cpp:                   tdst->is_con() && ((tdst->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);
opto/library_call.cpp:        assert(dst->is_CheckCastPP(), "sanity");
opto/library_call.cpp:        assert(dst->in(0)->in(0) == init, "dest pinned");
opto/library_call.cpp://-------------------------inline_Class_cast-------------------
opto/library_call.cpp:      cast->init_req(0, control());
opto/library_call.cpp:    assert(dest->is_CheckCastPP(), "not an allocation result?");
opto/library_call.cpp:    dest->set_req(0, control());
opto/library_call.cpp:  bool has_dest = (top_dest != NULL && top_dest->klass() != NULL);
opto/library_call.cpp:        has_dest = (top_dest != NULL && top_dest->klass() != NULL);
opto/library_call.cpp:    BasicType dest_elem = top_dest->klass()->as_array_klass()->element_type()->basic_type();
opto/library_call.cpp:      ciKlass* dest_k = top_dest->klass();
opto/library_call.cpp:      !src->is_top() && !dest->is_top()) {
opto/library_call.cpp:  const Type* dst_type = dst->Value(&_gvn);
opto/library_call.cpp:      top_dest == NULL || top_dest->klass() == NULL) {
opto/library_call.cpp:       cast->init_req(0, control());
opto/library_call.cpp:       _gvn.set_type(cast, cast->bottom_type());
opto/library_call.cpp:  assert(tinst->klass()->is_loaded(), "obj is not loaded");
opto/library_call.cpp:  ciInstanceKlass* referenceKlass = tinst->klass()->as_instance_klass();
opto/library_call.cpp:    assert(tinst->klass()->is_loaded(), "obj is not loaded");
opto/library_call.cpp:    assert(!is_exact || tinst->klass_is_exact(), "klass not exact");
opto/library_call.cpp:    fromKls = tinst->klass()->as_instance_klass();
opto/library_call.cpp:    assert(tinst->klass()->is_loaded(), "obj is not loaded");
opto/library_call.cpp:    assert(!is_exact || tinst->klass_is_exact(), "klass not exact");
opto/library_call.cpp:    fromKls = tinst->klass()->as_instance_klass();
opto/library_call.cpp:  const Type* dest_type = dest->Value(&_gvn);
opto/library_call.cpp:  assert (top_src  != NULL && top_src->klass()  != NULL &&  top_dest != NULL && top_dest->klass() != NULL, "args are strange");
opto/library_call.cpp:  const Type* dest_type = dest->Value(&_gvn);
opto/library_call.cpp:          &&  top_dest != NULL && top_dest->klass() != NULL, "args are strange");
opto/library_call.cpp:  assert(tinst->klass()->is_loaded(), "CBC obj is not loaded");
opto/library_call.cpp:  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make("com/sun/crypto/provider/AESCrypt"));
opto/library_call.cpp:  const Type* dest_type = dest->Value(&_gvn);
opto/library_call.cpp:         &&  top_dest != NULL && top_dest->klass() != NULL, "args are strange");
opto/library_call.cpp:  assert(tinst->klass()->is_loaded(), "ECB obj is not loaded");
opto/library_call.cpp:  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make("com/sun/crypto/provider/AESCrypt"));
opto/library_call.cpp:  const Type* dest_type = dest->Value(&_gvn);
opto/library_call.cpp:         top_dest != NULL && top_dest->klass() != NULL, "args are strange");
opto/library_call.cpp:  assert(tinst->klass()->is_loaded(), "CTR obj is not loaded");
opto/library_call.cpp:  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make("com/sun/crypto/provider/AESCrypt"));
opto/library_call.cpp:  assert(tinst->klass()->is_loaded(), "CBCobj is not loaded");
opto/library_call.cpp:  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make("com/sun/crypto/provider/AESCrypt"));
opto/library_call.cpp:  assert(tinst->klass()->is_loaded(), "ECBobj is not loaded");
opto/library_call.cpp:  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make("com/sun/crypto/provider/AESCrypt"));
opto/library_call.cpp:  assert(tinst->klass()->is_loaded(), "CTRobj is not loaded");
opto/library_call.cpp:  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make("com/sun/crypto/provider/AESCrypt"));
opto/library_call.cpp:    assert(tinst->klass()->is_loaded(), "DigestBase is not loaded");
opto/library_call.cpp:    ciKlass* klass_digestBase = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(klass_digestBase_name));
opto/library_call.cpp:  assert(tinst->klass()->is_loaded(), "DigestBase is not loaded");
opto/library_call.cpp:    klass = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(klass_name));
opto/matcher.cpp:      // A just-prior uncommon-trap or deoptimization will use the SOE regs.
opto/matcher.cpp:    // Control of load's memory can post-dominates load's control.
opto/matcher.cpp:      // find, if it post-dominates the others.  This allows us to
opto/matcher.cpp:        if (x == m_control)     // Does 'control' post-dominate
opto/matcher.cpp:        if (x == mem_control)   // Does 'control' post-dominate
opto/matcher.cpp:      if (j == max_scan)        // No post-domination before scan end?
opto/matcher.cpp:  if (last != NULL && rule == last->rule()) {
opto/matcher.cpp:    Node* control = last->in(0);
opto/matcher.cpp:        last->set_req(0, xroot);
opto/matcher.cpp://------------------------------ReduceInst-------------------------------------
opto/subnode.cpp:  st->print("%s", msg[_test]);
opto/subnode.cpp:  //    // checking the trip counter and they want to use the post-incremented
opto/subnode.cpp:  st->print("[");
opto/subnode.cpp:  st->print("]");
opto/subnode.cpp://----------------------is_counted_loop_exit_test------------------------------
opto/stringopts.cpp:  bool aligned = tdst->is_con() && ((tdst->get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0);
opto/opaquenode.hpp:// pre- and post-increment values both being live and thus requiring an extra
opto/cfgnode.hpp:// a just-prior call.  Looks like a PCTableNode but emits no code - just the
opto/loopUnswitch.cpp:// and inserting an if to select fast-slow versions.
opto/loopUnswitch.cpp:    tty->print("\t iffast = %d, ", iffast->_idx); iffast->dump();
opto/callnode.hpp:  // Inovke this method when MemBar at exit of initializer and post-dominate
opto/subnode.hpp://------------------------------BoolTest---------------------------------------
opto/memnode.cpp:    st->print(" Volatile!");
opto/memnode.cpp:    st->print(" unaligned");
opto/memnode.cpp:    st->print(" mismatched");
opto/memnode.cpp:    st->print(" unsafe");
opto/memnode.cpp:  st->print(" @");
opto/memnode.cpp:    st->print("NULL");
opto/memnode.cpp:      st->print(", idx=?\?;");
opto/memnode.cpp:      st->print(", idx=Bot;");
opto/memnode.cpp:      st->print(", idx=Top;");
opto/memnode.cpp:      st->print(", idx=Raw;");
opto/memnode.cpp:        st->print(", name=");
opto/memnode.cpp:      st->print(", idx=%d;", atp->index());
opto/memnode.cpp:      st->print("alias_idx==%d, adr_check==", alias_idx);
opto/memnode.cpp:        st->print("NULL");
opto/memnode.cpp:      st->cr();
opto/memnode.cpp:    st->print(" #"); _type->dump_on(st);
opto/memnode.cpp:    st->print(" (does not depend only on test)");
opto/memnode.cpp:    if (st->is_Store()) {
opto/memnode.cpp:      Node* st_adr = st->in(MemNode::Address);
opto/memnode.cpp:      if (store_Opcode() != st->Opcode())
opto/memnode.cpp:      return st->in(MemNode::ValueIn);
opto/memnode.cpp:    if (st->is_Proj() && st->in(0)->is_Allocate() &&
opto/memnode.cpp:        (st->in(0) == ld_alloc) &&
opto/memnode.cpp:        (ld_off >= st->in(0)->as_Allocate()->minimum_header_size())) {
opto/memnode.cpp:    if (st->is_Proj() && st->in(0)->is_Initialize()) {
opto/memnode.cpp:      InitializeNode* init = st->in(0)->as_Initialize();
opto/memnode.cpp:    ciObject* const_oop = tinst->const_oop();
opto/memnode.cpp:  bool is_instance = (tinst != NULL) && tinst->is_known_instance_field();
opto/memnode.cpp:  bool is_boxed_value = (tinst != NULL) && tinst->is_ptr_to_boxed_value();
opto/memnode.cpp:    ciInstanceKlass* ik = tinst->klass()->as_instance_klass();
opto/memnode.cpp:    int offset = tinst->offset();
opto/memnode.cpp:      ciType* t = tinst->java_mirror_type();
opto/memnode.cpp:      if (tinst->klass_is_exact()) {
opto/memnode.cpp:    while (st->is_Store() && st->outcnt() == 1 && st->Opcode() != Op_StoreCM) {
opto/memnode.cpp:      assert(st != st->in(MemNode::Memory), "dead loop in StoreNode::Ideal");
opto/memnode.cpp:      assert(Opcode() == st->Opcode() ||
opto/memnode.cpp:             st->Opcode() == Op_StoreVector ||
opto/memnode.cpp:             (Opcode() == Op_StoreL && st->Opcode() == Op_StoreI) || // expanded ClearArrayNode
opto/memnode.cpp:             (Opcode() == Op_StoreI && st->Opcode() == Op_StoreL) || // initialization by arraycopy
opto/memnode.cpp:             (is_mismatched_access() || st->as_Store()->is_mismatched_access()),
opto/memnode.cpp:             "no mismatched stores, except on raw memory: %s %s", NodeClassNames[Opcode()], NodeClassNames[st->Opcode()]);
opto/memnode.cpp:      if (st->in(MemNode::Address)->eqv_uncast(address) &&
opto/memnode.cpp:          st->as_Store()->memory_size() <= this->memory_size()) {
opto/memnode.cpp:        Node* use = st->raw_out(0);
opto/memnode.cpp:          use->set_req_X(MemNode::Memory, st->in(MemNode::Memory), phase->is_IterGVN());
opto/memnode.cpp:          use->set_req(MemNode::Memory, st->in(MemNode::Memory));
opto/memnode.cpp:      st = st->in(MemNode::Memory);
opto/memnode.cpp:  if (!st->is_Store())  return -1;  // can happen to dead code via subsume_node
opto/memnode.cpp:  Node* base = AddPNode::Ideal_base_and_offset(st->in(MemNode::Address),
opto/memnode.cpp:  if (st->req() != MemNode::ValueIn + 1)
opto/memnode.cpp:  Node* ctl = st->in(MemNode::Control);
opto/memnode.cpp:  Node* mem = st->in(MemNode::Memory);
opto/memnode.cpp:  Node* adr = st->in(MemNode::Address);
opto/memnode.cpp:  int size_in_bytes = st->memory_size();
opto/memnode.cpp:  Node* val = st->in(MemNode::ValueIn);
opto/memnode.cpp:          start < st_off + st->as_Store()->memory_size()) {
opto/memnode.cpp:          st->as_Store()->memory_size() != size_in_bytes) {
opto/memnode.cpp:    assert(get_store_offset(st->as_Store(), phase) == start, "sanity");
opto/memnode.cpp:  int size_in_bytes = st->memory_size();
opto/memnode.cpp:    // See StoreNode::Ideal 'st->outcnt() == 1' for the reason to disconnect.
opto/memnode.cpp:  Node* new_st = st->clone();
opto/memnode.cpp:  new_st->set_req(MemNode::Control, in(Control));
opto/memnode.cpp:  new_st->set_req(MemNode::Memory,  prev_mem);
opto/memnode.cpp:  new_st->set_req(MemNode::Address, make_raw_address(start, phase));
opto/memnode.cpp:    if (st->in(MemNode::Memory) != zmem)  continue; //skip (odd store chain)
opto/memnode.cpp:    int st_size = st->as_Store()->memory_size();
opto/memnode.cpp:    const Type* val = phase->type(st->in(MemNode::ValueIn));
opto/memnode.cpp:        st->Opcode() == Op_StoreL) {
opto/memnode.cpp:          st->Opcode() == Op_StoreI) {
opto/memnode.cpp:        if (con != 0 && st != NULL && st->Opcode() == Op_StoreI) {
opto/memnode.cpp:          DEBUG_ONLY(const Type* tcon = phase->type(st->in(MemNode::ValueIn)));
opto/memnode.cpp:    int st_size = st->as_Store()->memory_size();
opto/memnode.cpp:    if (st->in(MemNode::Memory) != zmem)
opto/memnode.cpp:    int st_size = st->as_Store()->memory_size();
opto/memnode.cpp:        (val = phase->type(st->in(MemNode::ValueIn)))->singleton() &&
opto/memnode.cpp:    last_off = st_off + st->as_Store()->memory_size();
opto/memnode.cpp:  st->print(" {");
opto/memnode.cpp:    if (mem == base_mem) { st->print(" -"); continue; }
opto/memnode.cpp:    st->print( " N%d:", mem->_idx );
opto/memnode.cpp:  st->print(" }");
opto/matcher.hpp:                    Post_Visit,  // post-visit node
opto/matcher.hpp:                    Alt_Post_Visit   // alternative post-visit path
opto/matcher.hpp:  // but it will also get called to generate post-allocation spill code.
opto/matcher.hpp:  // List is valid in the post-matching space.
opto/split_if.cpp:// find the post-dominating point.
opto/split_if.cpp:// We must be at the merge point which post-dominates 'new_false' and
opto/split_if.cpp:  while( n != iff_dom ) {       // Found post-dominating point?
opto/split_if.cpp:    phi_post->set_req(0, prior_n );
opto/split_if.cpp:      assert( prior_n->is_Region(), "must be a post-dominating merge point" );
opto/split_if.cpp:      for( uint i = 1; i < phi_post->req(); i++ ) // For all paths
opto/split_if.cpp:        phi_post->init_req( i, spinup( iff_dom, new_false, new_true, prior_n->in(i), def, cache ) );
opto/split_if.cpp:        phi_post->destruct();
opto/split_if.cpp:  while( n != iff_dom ) {       // Found post-dominating point?
opto/split_if.cpp:// be from the post-split-CFG true merge point.  Vice-versa for the false
opto/split_if.cpp:// post-dominating location; we may need to insert a Phi there.
opto/idealGraphPrinter.cpp:      if (last != NULL && last->has_linenumber_table() && last_bci >= 0) {
opto/idealGraphPrinter.cpp:        print_prop("line", last->line_number_from_bci(last_bci));
opto/postaloc.cpp:// Post-Allocation peephole copy removal.  We do this in 1 pass over the
opto/postaloc.cpp:      // Improve reaching-def info.  Occasionally post-alloc's liveness gives
opto/doCall.cpp:// Put a Catch and CatchProj nodes behind a just-created call.
opto/doCall.cpp:      assert(klass->has_subklass() || tinst->klass_is_exact(), "lost exactness");
opto/regmask.hpp:    assert(valid_watermarks(), "post-condition");
opto/regmask.hpp:    assert(valid_watermarks(), "post-condition");
opto/regmask.hpp:  // Find lowest-numbered register from mask, or BAD if mask is empty.
opto/regmask.hpp:  // Get highest-numbered register from mask, or BAD if mask is empty.
opto/regmask.hpp:  // Find the lowest-numbered register set in the mask.  Return the
opto/regmask.hpp:    assert(valid_watermarks(), "post-condition");
opto/gcm.cpp:        // All of n's inputs have been processed, complete post-processing.
opto/gcm.cpp:    // Schedule all nodes in a post-order visit
opto/gcm.cpp:      break;                  // All done with children; post-visit 'self'
opto/gcm.cpp:  double least_freq  = least->_freq;
opto/gcm.cpp:      least->_pre_order, start_latency, least_freq);
opto/gcm.cpp://------------------------------in_loop_nest-----------------------------------
prims/jvm.cpp:                             is_nestmate ? "with dynamic nest-host " : "non-nestmate",
prims/jvm.cpp:                   JNIHandles::make_local(THREAD, host->java_mirror()));
prims/jvm.cpp:  log_trace(class, nestmates)("Calling GetNestMembers for type %s with nest-host %s",
prims/jvm.cpp:                              ck->external_name(), host->external_name());
prims/jvm.cpp:    Array<u2>* members = host->nest_members();
prims/jvm.cpp:    result->obj_at_put(0, host->java_mirror());
prims/jvm.cpp:        Klass* k = host->constants()->klass_at(cp_index, THREAD);
prims/jvm.cpp:            char* target_member_class = host->constants()->klass_name_at(cp_index)->as_C_string();
prims/jvm.cpp:  dest->obj_at_put(0, str());
prims/jvm.cpp:  dest->obj_at_put(1, str());
prims/jvm.cpp:  dest->obj_at_put(2, str());
prims/jvm.cpp:  dest->obj_at_put(0, str());
prims/jvm.cpp:  dest->obj_at_put(1, str());
prims/jvm.cpp:  dest->obj_at_put(0, enc_k->java_mirror());
prims/jvm.cpp:    dest->obj_at_put(1, str());
prims/jvm.cpp:    dest->obj_at_put(2, str());
prims/jvmtiRedefineClasses.cpp:  // Check whether the nest-related attributes have been changed.
prims/jvmtiRedefineClasses.cpp:        int nj;  // outside the loop for post-loop check
prims/jvmtiRedefineClasses.cpp:    st->print_cr(", redefining class %s", _the_class->external_name());
prims/cdsoffsets.cpp:  list->add_end(new CDSOffsets(name, value, NULL))
prims/jvmtiRawMonitor.cpp:      // Return to VM before post-check of interrupt state
prims/wbtestmethods/parserTests.cpp:      arglist = arglist->next();
prims/jvmtiEnvBase.cpp:    if (owned_monitors_list->length() > 0) {
prims/jvmtiEnvBase.cpp:      for (int j = 0; j < owned_monitors_list->length(); j++) {
prims/jvmtiEnvBase.cpp:        jobject jobj = ((jvmtiMonitorStackDepthInfo*)owned_monitors_list->at(j))->monitor;
prims/jvmtiEnvBase.cpp:    owned_monitors_list->append(jmsdi);
prims/jvmtiEnvBase.cpp:        if (wantList->length() < nWant) {
prims/jvmtiEnvBase.cpp:          nWant = wantList->length();
prims/jvmtiEnvBase.cpp:          JavaThread *pending_thread = wantList->at(i);
prims/jvmtiEnvBase.cpp:    for (int j = 0; j < _owned_monitors_list->length(); j++) {
prims/jvmtiEnvBase.cpp:      jobject jobj = ((jvmtiMonitorStackDepthInfo*)_owned_monitors_list->at(j))->monitor;
prims/jvmtiEnvBase.cpp:      _owned_monitors_list->append(jmsdi);
prims/jni.cpp:  check_bounds(start, len, dst->length(), CHECK); \
prims/stackwalk.cpp:    BasicType type = st->type();
prims/stackwalk.cpp:        intptr_t ret = st->get_int(); // read full 64-bit slot
prims/nativeLookup.cpp:      st->put((char) c);
prims/nativeLookup.cpp:           if (c == '_') st->print("_1");
prims/nativeLookup.cpp:      else if (c == '/') st->print("_");
prims/nativeLookup.cpp:      else if (c == ';') st->print("_2");
prims/nativeLookup.cpp:      else if (c == '[') st->print("_3");
prims/nativeLookup.cpp:      else               st->print("_%.5x", c);
prims/methodHandles.cpp:  if (is_method)  st->put(JVM_SIGNATURE_FUNC);
prims/methodHandles.cpp:      st->put(JVM_SIGNATURE_ENDFUNC);
prims/methodHandles.cpp:      st->put(',');
prims/methodHandles.cpp:      st->put(JVM_SIGNATURE_ARRAY);
prims/methodHandles.cpp:        st->put(cp[1]);
prims/methodHandles.cpp:        st->put(JVM_SIGNATURE_CLASS);
prims/methodHandles.cpp:      st->put(cp[0]);
prims/jvmtiExport.cpp:  if (!t_list->includes(java_thread)) {
prims/jvmtiExport.cpp:  if (!t_list->includes(java_thread)) {
prims/jvmtiExport.cpp:      st->print_cr("%s is not available in %s",
prims/jvmtiExport.cpp:      st->print_cr("return code: %d", result);
prims/jvmtiExport.cpp:    st->print_cr("%s was not loaded.", agent);
prims/jvmtiExport.cpp:      st->print_cr("%s", ebuf);
prims/jvmti.xsl:    <xsl:attribute name="style">list-style-type:<xsl:value-of select="@type"/></xsl:attribute>
prims/jvmtiTagMap.cpp:// does the post-callback work of tagging or untagging the object.
prims/jvmtiTagMap.cpp:  // invoked post-callback to tag, untag, or update the tag of an object
prims/jvmtiTagMap.cpp:// callback post-callback to tag, untag, or update the tag of an object
prims/jvmtiTagMap.cpp:  _class_list->push(ik);
prims/jvmtiTagMap.cpp:    for (int i = 0; i < _class_list->length(); i++) {
prims/jvmtiTagMap.cpp:      InstanceKlass* ik = _class_list->at(i);
prims/jvmtiTagMap.cpp:  return (_class_list == NULL) ? 0 : _class_list->length();
prims/jvmtiEnv.cpp:  jint owned_monitor_count = owned_monitors_list->length();
prims/jvmtiEnv.cpp:          ((jvmtiMonitorStackDepthInfo*)owned_monitors_list->at(i))->monitor;
prims/jvmtiEnv.cpp:    deallocate((unsigned char*)owned_monitors_list->at(i));
prims/jvmtiEnv.cpp:  jint owned_monitor_count = owned_monitors_list->length();
prims/jvmtiEnv.cpp:          ((jvmtiMonitorStackDepthInfo*)owned_monitors_list->at(i))->monitor;
prims/jvmtiEnv.cpp:          ((jvmtiMonitorStackDepthInfo*)owned_monitors_list->at(i))->stack_depth;
prims/jvmtiEnv.cpp:    deallocate((unsigned char*)owned_monitors_list->at(i));
prims/jvmtiEnv.cpp:    const int result_length = (interface_list == NULL ? 0 : interface_list->length());
prims/jvmtiEnv.cpp:      InstanceKlass* klass_at = interface_list->at(i_index);
runtime/vframe.cpp:    st->print("\t- %s <" INTPTR_FORMAT "> ", lock_state, p2i(obj()));
runtime/vframe.cpp:      st->print_cr("(a java.lang.Class for %s)", java_lang_Class::as_external_name(obj()));
runtime/vframe.cpp:      st->print_cr("(a %s)", k->external_name());
runtime/vframe.cpp:        st->print_cr("\t- %s <no object reference available>", wait_state);
runtime/vframe.cpp:      st->print_cr("\t- %s <" INTPTR_FORMAT "> (a %s)", "parking to wait for ", p2i(obj), k->external_name());
runtime/vframe.cpp:        st->print_cr("\t- waiting on the Class initialization monitor for %s", k->external_name());
runtime/vframe.cpp:          st->print("\t- eliminated <owner is scalar replaced> (a %s)", k->external_name());
runtime/vframe.cpp:  if (list->is_empty()) return;
runtime/vframe.cpp:  for (int index = (list->length()-1); index >= 0; index--) {
runtime/vframe.cpp:    MonitorInfo* monitor = list->at(index);
runtime/flags/jvmFlag.cpp:  if ((unsigned int)st->position() < req_pos) {
runtime/flags/jvmFlag.cpp:    st->fill_to(req_pos);  // need to fill with blanks to reach req_pos
runtime/flags/jvmFlag.cpp:    st->print(" ");        // enforce blank separation. Previous field too long.
runtime/flags/jvmFlag.cpp:    st->fill_to(col1_pos);
runtime/flags/jvmFlag.cpp:    st->print("%*s", col1_width, _type);  // right-justified, therefore width is required.
runtime/flags/jvmFlag.cpp:    st->print("%s", _name);
runtime/flags/jvmFlag.cpp:    st->print(" =");  // use " =" for proper alignment with multiline ccstr output.
runtime/flags/jvmFlag.cpp:      st->print("%s", get_bool() ? "true" : "false");
runtime/flags/jvmFlag.cpp:      st->print("%d", get_int());
runtime/flags/jvmFlag.cpp:      st->print("%u", get_uint());
runtime/flags/jvmFlag.cpp:      st->print(INTX_FORMAT, get_intx());
runtime/flags/jvmFlag.cpp:      st->print(UINTX_FORMAT, get_uintx());
runtime/flags/jvmFlag.cpp:      st->print(UINT64_FORMAT, get_uint64_t());
runtime/flags/jvmFlag.cpp:      st->print(SIZE_FORMAT, get_size_t());
runtime/flags/jvmFlag.cpp:      st->print("%f", get_double());
runtime/flags/jvmFlag.cpp:          st->print("%.*s", (int)llen, cp);
runtime/flags/jvmFlag.cpp:          st->cr();
runtime/flags/jvmFlag.cpp:          st->print("%s", _name);
runtime/flags/jvmFlag.cpp:          st->print("+=");
runtime/flags/jvmFlag.cpp:        st->print("%s", cp);
runtime/flags/jvmFlag.cpp:      st->print("unhandled  type %s", _type);
runtime/flags/jvmFlag.cpp:      st->cr();
runtime/flags/jvmFlag.cpp:      st->print("%s", _doc);
runtime/flags/jvmFlag.cpp:    st->cr();
runtime/flags/jvmFlag.cpp:    st->fill_to(col1_pos);
runtime/flags/jvmFlag.cpp:    st->print("%*s", col1_width, _type);  // right-justified, therefore width is required.
runtime/flags/jvmFlag.cpp:    st->print("%s", _name);
runtime/flags/jvmFlag.cpp:      st->print("unhandled  type %s", _type);
runtime/flags/jvmFlag.cpp:      st->cr();
runtime/flags/jvmFlag.cpp:      st->print("%s", _doc);
runtime/flags/jvmFlag.cpp:    st->cr();
runtime/flags/jvmFlag.cpp:    st->print("%*s", width, kind);
runtime/flags/jvmFlag.cpp:  st->print("{");
runtime/flags/jvmFlag.cpp:      st->print("default"); break;
runtime/flags/jvmFlag.cpp:      st->print("command line"); break;
runtime/flags/jvmFlag.cpp:      st->print("environment"); break;
runtime/flags/jvmFlag.cpp:      st->print("config file"); break;
runtime/flags/jvmFlag.cpp:      st->print("management"); break;
runtime/flags/jvmFlag.cpp:        st->print("command line, ");
runtime/flags/jvmFlag.cpp:      st->print("ergonomic"); break;
runtime/flags/jvmFlag.cpp:      st->print("attach"); break;
runtime/flags/jvmFlag.cpp:      st->print("internal"); break;
runtime/flags/jvmFlag.cpp:      st->print("jimage"); break;
runtime/flags/jvmFlag.cpp:  st->print("}");
runtime/flags/jvmFlag.cpp:    st->print("-XX:%s%s", get_bool() ? "+" : "-", _name);
runtime/flags/jvmFlag.cpp:    st->print("-XX:%s=%d", _name, get_int());
runtime/flags/jvmFlag.cpp:    st->print("-XX:%s=%u", _name, get_uint());
runtime/flags/jvmFlag.cpp:    st->print("-XX:%s=" INTX_FORMAT, _name, get_intx());
runtime/flags/jvmFlag.cpp:    st->print("-XX:%s=" UINTX_FORMAT, _name, get_uintx());
runtime/flags/jvmFlag.cpp:    st->print("-XX:%s=" UINT64_FORMAT, _name, get_uint64_t());
runtime/flags/jvmFlag.cpp:    st->print("-XX:%s=" SIZE_FORMAT, _name, get_size_t());
runtime/flags/jvmFlag.cpp:    st->print("-XX:%s=%f", _name, get_double());
runtime/flags/jvmFlag.cpp:    st->print("-XX:%s=", _name);
runtime/flags/jvmFlag.cpp:            st->print("%c", *cp);
runtime/flags/jvmFlag.cpp:            st->print(" -XX:%s=", _name);
runtime/flags/jvmFlagRangeList.cpp:    st->print("[ %-25d ... %25d ]", _min, _max);
runtime/flags/jvmFlagRangeList.cpp:    st->print("[ " INTX_FORMAT_W(-25) " ... " INTX_FORMAT_W(25) " ]", _min, _max);
runtime/flags/jvmFlagRangeList.cpp:    st->print("[ %-25u ... %25u ]", _min, _max);
runtime/flags/jvmFlagRangeList.cpp:    st->print("[ " UINTX_FORMAT_W(-25) " ... " UINTX_FORMAT_W(25) " ]", _min, _max);
runtime/flags/jvmFlagRangeList.cpp:    st->print("[ " UINT64_FORMAT_W(-25) " ... " UINT64_FORMAT_W(25) " ]", _min, _max);
runtime/flags/jvmFlagRangeList.cpp:    st->print("[ " SIZE_FORMAT_W(-25) " ... " SIZE_FORMAT_W(25) " ]", _min, _max);
runtime/flags/jvmFlagRangeList.cpp:    st->print("[ %-25.3f ... %25.3f ]", _min, _max);
runtime/flags/jvmFlagRangeList.cpp:      st->print("%s", default_range_str_func());
runtime/flags/jvmFlagRangeList.cpp:      st->print("[                           ...                           ]");
runtime/statSampler.cpp:  for (int index = 0; index < list->length(); index++) {
runtime/statSampler.cpp:    PerfData* item = list->at(index);
runtime/mutex.cpp:  if (least != NULL && least->rank() <= special) {
runtime/mutex.cpp:               name(), rank(), least->name(), least->rank());
runtime/mutex.cpp:  st->print("[" PTR_FORMAT, p2i(this));
runtime/mutex.cpp:  st->print("] %s", _name);
runtime/mutex.cpp:  st->print(" - owner thread: " PTR_FORMAT, p2i(_owner));
runtime/mutex.cpp:  st->print("Mutex: [" PTR_FORMAT "] %s - owner: " PTR_FORMAT,
runtime/mutex.cpp:    st->print("%s", " allow_vm_block");
runtime/mutex.cpp:  st->print(" %s", print_safepoint_check(_safepoint_check_required));
runtime/mutex.cpp:  st->cr();
runtime/stubCodeGenerator.cpp:  st->print("%s", group());
runtime/stubCodeGenerator.cpp:  st->print("::");
runtime/stubCodeGenerator.cpp:  st->print("%s", name());
runtime/stubCodeGenerator.cpp:  st->print(" [" INTPTR_FORMAT ", " INTPTR_FORMAT "] (%d bytes)", p2i(begin()), p2i(end()), size_in_bytes());
runtime/arguments.cpp:  st->print_cr("VM Arguments:");
runtime/arguments.cpp:    st->print("jvm_flags: "); print_jvm_flags_on(st);
runtime/arguments.cpp:    st->cr();
runtime/arguments.cpp:    st->print("jvm_args: "); print_jvm_args_on(st);
runtime/arguments.cpp:    st->cr();
runtime/arguments.cpp:  st->print_cr("java_command: %s", java_command() ? java_command() : "<unknown>");
runtime/arguments.cpp:    st->print_cr("java_class_path (initial): %s", strlen(path) == 0 ? "<not set>" : path );
runtime/arguments.cpp:  st->print_cr("Launcher Type: %s", _sun_java_launcher);
runtime/arguments.cpp:    st->print_raw("Settings File: ");
runtime/arguments.cpp:    st->cr();
runtime/arguments.cpp:  st->print_raw("Command Line: ");
runtime/arguments.cpp:    st->print("%s", java_command());
runtime/arguments.cpp:  st->cr();
runtime/arguments.cpp:      st->print("%s ", _jvm_flags_array[i]);
runtime/arguments.cpp:      st->print("%s ", _jvm_args_array[i]);
runtime/threadSMR.cpp:    current_list->threads_do(&add_cl);
runtime/threadSMR.cpp:  current_list->inc_nested_handle_cnt();
runtime/threadSMR.cpp:    _list->dec_nested_handle_cnt();
runtime/threadSMR.cpp:  const uint index = list->_length;
runtime/threadSMR.cpp:    Copy::disjoint_words((HeapWord*)list->_threads, (HeapWord*)new_list->_threads, head_length);
runtime/threadSMR.cpp:  *(JavaThread**)(new_list->_threads + index) = java_thread;
runtime/threadSMR.cpp:  assert(list->_length > 0, "sanity");
runtime/threadSMR.cpp:  uint i = (uint)list->find_index_of_JavaThread(java_thread);
runtime/threadSMR.cpp:  assert(i < list->_length, "did not find JavaThread on the list");
runtime/threadSMR.cpp:  const uint new_length = list->_length - 1;
runtime/threadSMR.cpp:    Copy::disjoint_words((HeapWord*)list->_threads, (HeapWord*)new_list->_threads, head_length);
runtime/threadSMR.cpp:    Copy::disjoint_words((HeapWord*)list->_threads + index + 1, (HeapWord*)new_list->_threads + index, tail_length);
runtime/threadSMR.cpp:    update_java_thread_list_max(new_list->length());
runtime/threadSMR.cpp:  list->threads_do(tc);
runtime/threadSMR.cpp:    st->print(" _threads_hazard_ptr=" INTPTR_FORMAT, p2i(_list));
runtime/threadSMR.cpp:    st->print(", _nested_threads_hazard_ptr=" INTPTR_FORMAT, p2i(_list));
runtime/threadSMR.cpp:    st->print(" _threads_hazard_ptr=" INTPTR_FORMAT, p2i(thread->_threads_hazard_ptr));
runtime/threadSMR.cpp:    st->print(", _nested_threads_hazard_ptr_cnt=%u", thread->_nested_threads_hazard_ptr_cnt);
runtime/threadSMR.cpp:  st->print_cr("Threads class SMR info:");
runtime/threadSMR.cpp:  st->print_cr("_java_thread_list=" INTPTR_FORMAT ", length=%u, "
runtime/threadSMR.cpp:               _java_thread_list->length());
runtime/threadSMR.cpp:  st->print_cr("}");
runtime/threadSMR.cpp:    st->print_cr("_to_delete_list=" INTPTR_FORMAT ", length=%u, "
runtime/threadSMR.cpp:                 _to_delete_list->length());
runtime/threadSMR.cpp:    st->print_cr("}");
runtime/threadSMR.cpp:    for (ThreadsList *t_list = _to_delete_list->next_list();
runtime/threadSMR.cpp:         t_list != NULL; t_list = t_list->next_list()) {
runtime/threadSMR.cpp:      st->print("next-> " INTPTR_FORMAT ", length=%u, "
runtime/threadSMR.cpp:                "elements={", p2i(t_list), t_list->length());
runtime/threadSMR.cpp:      st->print_cr("}");
runtime/threadSMR.cpp:  st->print_cr("_java_thread_list_alloc_cnt=" UINT64_FORMAT ", "
runtime/threadSMR.cpp:    st->print_cr("_tlh_cnt=%u"
runtime/threadSMR.cpp:    st->print_cr("_deleted_thread_cnt=%u"
runtime/threadSMR.cpp:  st->print_cr("_delete_lock_wait_cnt=%u, _delete_lock_wait_max=%u",
runtime/threadSMR.cpp:  st->print_cr("_to_delete_list_cnt=%u, _to_delete_list_max=%u",
runtime/threadSMR.cpp:    st->print(INTPTR_FORMAT, p2i(jt));
runtime/threadSMR.cpp:    if (cnt < t_list->length() - 1) {
runtime/threadSMR.cpp:        st->print_cr(",");
runtime/threadSMR.cpp:        st->print(", ");
runtime/threadSMR.cpp:      st->cr();
runtime/osThread.cpp:  st->print("nid=0x%x ", thread_id());
runtime/osThread.cpp:    case ALLOCATED:               st->print("allocated ");                 break;
runtime/osThread.cpp:    case INITIALIZED:             st->print("initialized ");               break;
runtime/osThread.cpp:    case RUNNABLE:                st->print("runnable ");                  break;
runtime/osThread.cpp:    case MONITOR_WAIT:            st->print("waiting for monitor entry "); break;
runtime/osThread.cpp:    case CONDVAR_WAIT:            st->print("waiting on condition ");      break;
runtime/osThread.cpp:    case OBJECT_WAIT:             st->print("in Object.wait() ");          break;
runtime/osThread.cpp:    case BREAKPOINTED:            st->print("at breakpoint");               break;
runtime/osThread.cpp:    case SLEEPING:                st->print("sleeping");                    break;
runtime/osThread.cpp:    case ZOMBIE:                  st->print("zombie");                      break;
runtime/osThread.cpp:    default:                      st->print("unknown state %d", _state); break;
runtime/arguments.hpp:      _last->_next = lib;
runtime/os.cpp:  st->print(PTR_FORMAT ":   ", p2i(start));
runtime/os.cpp:        case 1: st->print("%02x", *(u1*)p); break;
runtime/os.cpp:        case 2: st->print("%04x", *(u2*)p); break;
runtime/os.cpp:        case 4: st->print("%08x", *(u4*)p); break;
runtime/os.cpp:        case 8: st->print("%016" FORMAT64_MODIFIER "x", *(u8*)p); break;
runtime/os.cpp:      st->print("%*.*s", 2*unitsize, 2*unitsize, "????????????????");
runtime/os.cpp:       st->cr();
runtime/os.cpp:       st->print(PTR_FORMAT ":   ", p2i(p));
runtime/os.cpp:       st->print(" ");
runtime/os.cpp:  st->cr();
runtime/os.cpp:  st->print_cr("%s %ld days %ld:%02ld hours", startStr, days, hours, minutes);
runtime/os.cpp:  st->print_cr("Instructions: (pc=" PTR_FORMAT ")", p2i(pc));
runtime/os.cpp:    st->print_cr("Environment Variables:");
runtime/os.cpp:        st->print("%s", env_list[i]);
runtime/os.cpp:        st->print("=");
runtime/os.cpp:        st->print_cr("%s", envvar);
runtime/os.cpp:  st->print("CPU:");
runtime/os.cpp:  st->print(" total %d", os::processor_count());
runtime/os.cpp:  // st->print("(active %d)", os::active_processor_count()); but we can
runtime/os.cpp:  st->print(" (initial active %d)", _initial_active_processor_count);
runtime/os.cpp:  st->print(" %s", VM_Version::features_string());
runtime/os.cpp:  st->cr();
runtime/os.cpp:  st->print("Host: ");
runtime/os.cpp:    st->print("%s, ", buf);
runtime/os.cpp:  st->print("%s, ", buf);
runtime/os.cpp:    st->print("%d cores, " SIZE_FORMAT "M, ", processor_count(), mem);
runtime/os.cpp:    st->print("%d cores, " SIZE_FORMAT "G, ", processor_count(), mem);
runtime/os.cpp:  st->print_raw(buf);
runtime/os.cpp:  st->cr();
runtime/os.cpp:    st->print("Time: %s %s", timestring, buf);
runtime/os.cpp:    st->print("Time: %s", timestring);
runtime/os.cpp:  st->print_cr(" elapsed time: %d.%06d seconds (%dd %dh %dm %ds)", eltime, eltimeFraction, eldays, elhours, elmins, elsecs);
runtime/os.cpp:    st->print_cr("0x0 is NULL");
runtime/os.cpp:      st->print_cr(INTPTR_FORMAT " is a global jni handle", p2i(addr));
runtime/os.cpp:      st->print_cr(INTPTR_FORMAT " is a weak global jni handle", p2i(addr));
runtime/os.cpp:      st->print_cr(INTPTR_FORMAT " is a local jni handle", p2i(addr));
runtime/os.cpp:        st->print_cr(INTPTR_FORMAT " is a thread", p2i(addr));
runtime/os.cpp:      st->print_cr(INTPTR_FORMAT " is pointing into the stack for thread: "
runtime/os.cpp:      st->print_cr(INTPTR_FORMAT " is a pointer to class: ", p2i(addr));
runtime/os.cpp:      st->cr();
runtime/os.cpp:      st->print_cr(INTPTR_FORMAT " is pointing into metadata", p2i(addr));
runtime/os.cpp:      st->print_cr(UINT32_FORMAT " is a compressed pointer to class: " INTPTR_FORMAT, narrow_klass, p2i((HeapWord*)k));
runtime/os.cpp:    st->print(INTPTR_FORMAT " points into unknown readable memory:", p2i(addr));
runtime/os.cpp:      st->print(" " PTR_FORMAT " |", *(intptr_t*)addr);
runtime/os.cpp:      st->print(" %02x", *(u1*)p);
runtime/os.cpp:    st->cr();
runtime/os.cpp:  st->print_cr(INTPTR_FORMAT " is an unknown value", p2i(addr));
runtime/synchronizer.cpp:// variants of the enter-exit fast-path operations.  See i486.ad fast_lock(),
runtime/synchronizer.cpp:// interpreter, and both C1 and C2 fast-path inline locking code emission.
runtime/synchronizer.cpp:// The quick_* forms are special fast-path variants used to improve
runtime/synchronizer.cpp:// The fast-path is designed to handle frequently arising cases in an efficient
runtime/synchronizer.cpp:    return mark;       // normal fast-path return
runtime/synchronizer.cpp:      return mark;    // normal fast-path return
runtime/synchronizer.cpp:      self->om_in_use_list->set_next_om(next);
runtime/objectMonitor.cpp:  // in Java, WaitNodes, ObjectMonitors, and Events would become 1st-class
runtime/objectMonitor.cpp:// the fast-path operators have been optimized so the common ::exit()
runtime/objectMonitor.cpp:// stranding are lower, although the worst-case stranding latency
runtime/objectMonitor.cpp:    // (Note that we'd need to make the post-drop spin short, but no
runtime/objectMonitor.cpp:    // shorter than the worst-case round-trip cache-line migration time.
runtime/objectMonitor.cpp:    // post monitor waited event.  Note that this is past-tense, we are done waiting.
runtime/objectMonitor.cpp:    // post monitor waited event. Note that this is past-tense, we are done waiting.
runtime/objectMonitor.cpp:      assert(list->_prev == NULL, "invariant");
runtime/objectMonitor.cpp:      assert(list->TState == ObjectWaiter::TS_ENTER, "invariant");
runtime/objectMonitor.cpp:// in the worst-case we'll spin when we shouldn't or vice-versa.
runtime/objectMonitor.cpp:  st->print("{contentions=0x%08x,waiters=0x%08x"
runtime/objectMonitor.cpp:  st->print_cr("(ObjectMonitor*) " INTPTR_FORMAT " = {", p2i(this));
runtime/objectMonitor.cpp:  st->print_cr("  _header = " INTPTR_FORMAT, header().value());
runtime/objectMonitor.cpp:  st->print_cr("  _object = " INTPTR_FORMAT, p2i(_object));
runtime/objectMonitor.cpp:  st->print("  _allocation_state = ");
runtime/objectMonitor.cpp:    st->print("Free");
runtime/objectMonitor.cpp:    st->print("Old");
runtime/objectMonitor.cpp:    st->print("New");
runtime/objectMonitor.cpp:    st->print("unknown=%d", _allocation_state);
runtime/objectMonitor.cpp:  st->cr();
runtime/objectMonitor.cpp:  st->print_cr("  _pad_buf0 = {");
runtime/objectMonitor.cpp:  st->print_cr("    [0] = '\\0'");
runtime/objectMonitor.cpp:  st->print_cr("    ...");
runtime/objectMonitor.cpp:  st->print_cr("    [%d] = '\\0'", (int)sizeof(_pad_buf0) - 1);
runtime/objectMonitor.cpp:  st->print_cr("  }");
runtime/objectMonitor.cpp:  st->print_cr("  _owner = " INTPTR_FORMAT, p2i(_owner));
runtime/objectMonitor.cpp:  st->print_cr("  _previous_owner_tid = " JLONG_FORMAT, _previous_owner_tid);
runtime/objectMonitor.cpp:  st->print_cr("  _pad_buf1 = {");
runtime/objectMonitor.cpp:  st->print_cr("    [0] = '\\0'");
runtime/objectMonitor.cpp:  st->print_cr("    ...");
runtime/objectMonitor.cpp:  st->print_cr("    [%d] = '\\0'", (int)sizeof(_pad_buf1) - 1);
runtime/objectMonitor.cpp:  st->print_cr("  }");
runtime/objectMonitor.cpp:  st->print_cr("  _next_om = " INTPTR_FORMAT, p2i(next_om()));
runtime/objectMonitor.cpp:  st->print_cr("  _recursions = " INTX_FORMAT, _recursions);
runtime/objectMonitor.cpp:  st->print_cr("  _EntryList = " INTPTR_FORMAT, p2i(_EntryList));
runtime/objectMonitor.cpp:  st->print_cr("  _cxq = " INTPTR_FORMAT, p2i(_cxq));
runtime/objectMonitor.cpp:  st->print_cr("  _succ = " INTPTR_FORMAT, p2i(_succ));
runtime/objectMonitor.cpp:  st->print_cr("  _Responsible = " INTPTR_FORMAT, p2i(_Responsible));
runtime/objectMonitor.cpp:  st->print_cr("  _Spinner = %d", _Spinner);
runtime/objectMonitor.cpp:  st->print_cr("  _SpinDuration = %d", _SpinDuration);
runtime/objectMonitor.cpp:  st->print_cr("  _contentions = %d", contentions());
runtime/objectMonitor.cpp:  st->print_cr("  _WaitSet = " INTPTR_FORMAT, p2i(_WaitSet));
runtime/objectMonitor.cpp:  st->print_cr("  _waiters = %d", _waiters);
runtime/objectMonitor.cpp:  st->print_cr("  _WaitSetLock = %d", _WaitSetLock);
runtime/objectMonitor.cpp:  st->print_cr("}");
runtime/basicLock.cpp:  st->print("monitor");
runtime/basicLock.cpp:  // inflated fast-path operations in fast_lock and fast_unlock to avoid
runtime/basicLock.cpp:  // is small (given the support for inflated fast-path locking in the fast_lock, etc)
runtime/basicLock.cpp:  dest->set_displaced_header(displaced_header());
runtime/threadSMR.hpp:    return _list->thread_at(_index);
runtime/threadSMR.hpp:    return _list->length();
runtime/threadSMR.hpp:    return _list->thread_at(_index);
runtime/vframe_hp.cpp:  int length = scv_list->length();
runtime/vframe_hp.cpp:    result->add(create_stack_value(scv_list->at(i)));
runtime/vframe_hp.cpp:    for (int i = 0; i < list->length(); i++) {
runtime/vframe_hp.cpp:      if (list->at(i)->matches(this)) {
runtime/vframe_hp.cpp:        list->at(i)->update_locals(result);
runtime/vframe_hp.cpp:  int length = scv_list->length();
runtime/vframe_hp.cpp:    result->add(create_stack_value(scv_list->at(i)));
runtime/vframe_hp.cpp:    for (int i = 0; i < list->length(); i++) {
runtime/vframe_hp.cpp:      if (list->at(i)->matches(this)) {
runtime/vframe_hp.cpp:        list->at(i)->update_stack(result);
runtime/vframe_hp.cpp:    for (int i = 0; i < list->length(); i++) {
runtime/vframe_hp.cpp:      if (list->at(i)->matches(this)) {
runtime/vframe_hp.cpp:        list->at(i)->update_monitors(result);
runtime/thread.cpp:      st->print("os_prio=%d ", os_prio);
runtime/thread.cpp:    st->print("cpu=%.2fms ",
runtime/thread.cpp:    st->print("elapsed=%.2fs ",
runtime/thread.cpp:      st->print("allocated=" SIZE_FORMAT "%s ",
runtime/thread.cpp:      st->print("defined_classes=" INT64_FORMAT " ", _statistical_info.getDefineClassCount());
runtime/thread.cpp:    st->print("tid=" INTPTR_FORMAT " ", p2i(this));
runtime/thread.cpp:  st->print(" ");
runtime/thread.cpp:  if (is_VM_thread())                 { st->print("VMThread"); }
runtime/thread.cpp:  else if (is_GC_task_thread())       { st->print("GCTaskThread"); }
runtime/thread.cpp:  else if (is_Watcher_thread())       { st->print("WatcherThread"); }
runtime/thread.cpp:  else if (is_ConcurrentGC_thread())  { st->print("ConcurrentGCThread"); }
runtime/thread.cpp:  else                                { st->print("Thread"); }
runtime/thread.cpp:    st->print(" \"%s\"", name());
runtime/thread.cpp:  st->print(" [stack: " PTR_FORMAT "," PTR_FORMAT "]",
runtime/thread.cpp:    st->print(" [id=%d]", osthread()->thread_id());
runtime/thread.cpp:    st->print(" \"%s\" ", name());
runtime/thread.cpp:  st->print(INTPTR_FORMAT, p2i(this));   // print address
runtime/thread.cpp:    st->print(" (no locks) ");
runtime/thread.cpp:    st->print_cr(" Locks owned:");
runtime/thread.cpp:  st->print("\"%s\" ", name());
runtime/thread.cpp:  st->cr();
runtime/thread.cpp:  st->print("\"%s\" ", name());
runtime/thread.cpp:  st->cr();
runtime/thread.cpp:    for (int i = 0; i < list->length(); i++) {
runtime/thread.cpp:      list->at(i)->oops_do(f);
runtime/thread.cpp:  st->print_cr("   JavaThread state: %s", _get_thread_state_name(_thread_state));
runtime/thread.cpp:  st->print_raw("\"");
runtime/thread.cpp:  st->print_raw(get_thread_name());
runtime/thread.cpp:  st->print_raw("\" ");
runtime/thread.cpp:    st->print("#" INT64_FORMAT " ", (int64_t)java_lang_Thread::thread_id(thread_oop));
runtime/thread.cpp:    if (java_lang_Thread::is_daemon(thread_oop))  st->print("daemon ");
runtime/thread.cpp:    st->print("prio=%d ", java_lang_Thread::priority(thread_oop));
runtime/thread.cpp:  st->print_cr("[" INTPTR_FORMAT "]", (intptr_t)last_Java_sp() & ~right_n_bits(12));
runtime/thread.cpp:    st->print_cr("   java.lang.Thread.State: %s", java_lang_Thread::thread_status_name(thread_oop));
runtime/thread.cpp:      st->print("   Compiling: ");
runtime/thread.cpp:      st->print("   No compile task");
runtime/thread.cpp:    st->cr();
runtime/thread.cpp:  st->print("%s", get_thread_name_string(buf, buflen));
runtime/thread.cpp:  st->print("JavaThread \"%s\"", get_thread_name_string(buf, buflen));
runtime/thread.cpp:    if (java_lang_Thread::is_daemon(thread_obj)) st->print(" daemon");
runtime/thread.cpp:  st->print(" [");
runtime/thread.cpp:  st->print("%s", _get_thread_state_name(_thread_state));
runtime/thread.cpp:    st->print(", id=%d", osthread()->thread_id());
runtime/thread.cpp:  st->print(", stack(" PTR_FORMAT "," PTR_FORMAT ")",
runtime/thread.cpp:  st->print("]");
runtime/thread.cpp:      _st->cr();
runtime/thread.cpp:  st->print_raw_cr(os::local_time_string(buf, sizeof(buf)));
runtime/thread.cpp:  st->print_cr("Full thread dump %s (%s %s):",
runtime/thread.cpp:  st->cr();
runtime/thread.cpp:  st->cr();
runtime/thread.cpp:    st->cr();
runtime/thread.cpp:  st->flush();
runtime/thread.cpp:    st->print("%s", is_current ? "=>" : "  ");
runtime/thread.cpp:    st->print(PTR_FORMAT, p2i(this_thread));
runtime/thread.cpp:    st->print(" ");
runtime/thread.cpp:    st->cr();
runtime/thread.cpp:  st->cr();
runtime/thread.cpp:  st->print_cr("Java Threads: ( => current thread )");
runtime/thread.cpp:  st->cr();
runtime/thread.cpp:  st->print_cr("Other Threads:");
runtime/thread.cpp:    st->cr();
runtime/thread.cpp:    st->print("=>" PTR_FORMAT " (exited) ", p2i(current));
runtime/thread.cpp:    st->cr();
runtime/thread.cpp:  st->cr();
runtime/thread.cpp:  st->print_cr("Threads with active compile tasks:");
runtime/thread.cpp:        st->print("  ");
runtime/thread.cpp:// We should make this a 1st-class type, integrated into the lock
runtime/thread.cpp:    return;   // normal fast-path return
runtime/thread.cpp:    assert(List->OnList == intptr_t(Lock), "invariant");
runtime/thread.cpp:    ParkEvent * const nxt = List->ListNext;
runtime/thread.cpp:    List->OnList = 0;
runtime/thread.cpp:    List->unpark();
runtime/sharedRuntime.hpp:  // Post-slow-path-allocation, pre-initializing-stores step for
runtime/biasedLocking.hpp:// unbiased markWord. The fast-path locking code checks to see whether
runtime/mutexLocker.cpp:  st->print("VM Mutex/Monitor currently owned by a thread: ");
runtime/mutexLocker.cpp:          st->print_cr(" ([mutex/lock_event])");
runtime/mutexLocker.cpp:       st->cr();
runtime/mutexLocker.cpp:  if (none) st->print_cr("None");
runtime/stackValue.cpp:      st->print("%d (int) %f (float) %x (hex)",  *(int *)&_integer_value, *(float *)&_integer_value,  *(int *)&_integer_value);
runtime/stackValue.cpp:        st->print("NULL");
runtime/stackValue.cpp:      st->print(" <" INTPTR_FORMAT ">", p2i(_handle_value()));
runtime/stackValue.cpp:     st->print("conflict");
runtime/jniHandles.cpp:  st->print_cr("JNI global refs: " SIZE_FORMAT ", weak refs: " SIZE_FORMAT,
runtime/jniHandles.cpp:  st->cr();
runtime/jniHandles.cpp:  st->flush();
runtime/jniHandles.cpp:      _block_free_list = _block_free_list->_next;
runtime/jniHandles.cpp:  if (_last->_top < block_size_in_oops) {
runtime/jniHandles.cpp:    oop* handle = (oop*)&(_last->_handles)[_last->_top++];
runtime/jniHandles.cpp:  if (_last->_next != NULL) {
runtime/jniHandles.cpp:    _last = _last->_next;
runtime/jniHandles.cpp:    _last->_next = JNIHandleBlock::allocate_block(thread, alloc_failmode);
runtime/jniHandles.cpp:    if (_last->_next == NULL) {
runtime/jniHandles.cpp:    _last = _last->_next;
runtime/fieldDescriptor.cpp:  st->print(" ");
runtime/fieldDescriptor.cpp:  st->print(" @%d ", offset());
runtime/fieldDescriptor.cpp:    st->print("(initval ");
runtime/fieldDescriptor.cpp:      st->print("int %d)", int_initial_value());
runtime/fieldDescriptor.cpp:      st->print_jlong(long_initial_value());
runtime/fieldDescriptor.cpp:      st->print("float %f)", float_initial_value());
runtime/fieldDescriptor.cpp:      st->print("double %lf)", double_initial_value());
runtime/fieldDescriptor.cpp:      st->print(" %d", obj->byte_field(offset()));
runtime/fieldDescriptor.cpp:        st->print(" %c %d", isprint(c) ? c : ' ', c);
runtime/fieldDescriptor.cpp:      st->print(" %lf", obj->double_field(offset()));
runtime/fieldDescriptor.cpp:      st->print(" %f", obj->float_field(offset()));
runtime/fieldDescriptor.cpp:      st->print(" %d", obj->int_field(offset()));
runtime/fieldDescriptor.cpp:      st->print(" ");
runtime/fieldDescriptor.cpp:      st->print_jlong(obj->long_field(offset()));
runtime/fieldDescriptor.cpp:      st->print(" %d", obj->short_field(offset()));
runtime/fieldDescriptor.cpp:      st->print(" %s", obj->bool_field(offset()) ? "true" : "false");
runtime/fieldDescriptor.cpp:      st->print(" ");
runtime/fieldDescriptor.cpp:        st->print("NULL");
runtime/fieldDescriptor.cpp:      st->print(" ");
runtime/fieldDescriptor.cpp:        st->print("NULL");
runtime/fieldDescriptor.cpp:    st->print(" (%x)", obj->int_field(offset()));
runtime/fieldDescriptor.cpp:    st->print(" (%x %x)", obj->int_field(offset()), obj->int_field(offset()+sizeof(jint)));
runtime/fieldDescriptor.cpp:    st->print(" (%x)", as_int);
runtime/safepoint.cpp:  st->print_cr("Thread: " INTPTR_FORMAT
runtime/safepoint.cpp:  st->print("VM Operation                 "
runtime/safepoint.cpp:  st->print_cr(" page_trap_count");
runtime/thread.hpp:  // elided card-marks for performance along the fast-path.
runtime/thread.hpp:  // Fast-locking support
runtime/vmOperations.cpp:  st->print("VM_Operation (" PTR_FORMAT "): ", p2i(this));
runtime/vmOperations.cpp:  st->print("%s", name());
runtime/vmOperations.cpp:  st->print(", mode: %s", evaluate_at_safepoint() ? "safepoint" : "no safepoint");
runtime/vmOperations.cpp:    st->print(", requested by thread " PTR_FORMAT, p2i(calling_thread()));
runtime/relocator.cpp:  address dst_addr = (address)dst->adr_at(0);
runtime/sharedRuntime.cpp:      st->print("Adapter for signature: ");
runtime/sharedRuntime.cpp:  st->print("AHE@" INTPTR_FORMAT ": %s", p2i(this), fingerprint()->as_string());
runtime/sharedRuntime.cpp:    st->print(" i2c: " INTPTR_FORMAT, p2i(get_i2c_entry()));
runtime/sharedRuntime.cpp:    st->print(" c2i: " INTPTR_FORMAT, p2i(get_c2i_entry()));
runtime/sharedRuntime.cpp:    st->print(" c2iUV: " INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));
runtime/sharedRuntime.cpp:    st->print(" c2iNCI: " INTPTR_FORMAT, p2i(get_c2i_no_clinit_check_entry()));
runtime/sharedRuntime.cpp:  st->cr();
runtime/globals.hpp:          "Use Just-In-Time compilation")                                   \
runtime/vframeArray.cpp:    if (list->is_empty()) {
runtime/vframeArray.cpp:      _monitors = new MonitorChunk(list->length());
runtime/vframeArray.cpp:      for (index = 0; index < list->length(); index++) {
runtime/vframeArray.cpp:        MonitorInfo* monitor = list->at(index);
runtime/vframeArray.cpp:          dest->set_obj(NULL);
runtime/vframeArray.cpp:          dest->set_obj(monitor->owner());
runtime/vframeArray.cpp:          monitor->lock()->move_to(monitor->owner(), dest->lock());
runtime/vframeArray.cpp:    // we put them back into the just-unpacked interpreter frame.
runtime/vframeArray.cpp:  st->print_cr(" - sp: " INTPTR_FORMAT, p2i(sp()));
runtime/vframeArray.cpp:  st->print(" - thread: ");
runtime/vframeArray.cpp:  st->print_cr(" - frame size: %d", frame_size());
runtime/vframeArray.cpp:  st->print_cr(" - interpreter_frame -> sp: " INTPTR_FORMAT, p2i(iframe()->sp()));
runtime/vframeArray.cpp:  st->print_cr("vframeArray [%d] ", frames());
runtime/unhandledOops.cpp:  for (int k = 0; k < list->_oop_list->length(); k++) {
runtime/unhandledOops.cpp:    UnhandledOopEntry entry = list->_oop_list->at(k);
runtime/unhandledOops.cpp:  _oop_list->push(entry);
runtime/unhandledOops.cpp:  int i = _oop_list->find_from_end(op, match_oop_entry);
runtime/unhandledOops.cpp:  UnhandledOopEntry entry = _oop_list->at(i);
runtime/unhandledOops.cpp:  _oop_list->at_put(i, entry);
runtime/unhandledOops.cpp:  int i = _oop_list->find_from_end(op, match_oop_entry);
runtime/unhandledOops.cpp:  _oop_list->remove_at(i);
runtime/unhandledOops.cpp:  for (int k = 0; k < _oop_list->length(); k++) {
runtime/unhandledOops.cpp:    UnhandledOopEntry entry = _oop_list->at(k);
runtime/deoptimization.cpp:      if (list->at(i)->id() == array->original().id()) {
runtime/deoptimization.cpp:        jvmtiDeferredLocalVariableSet* dlv = list->at(i);
runtime/deoptimization.cpp:        list->remove_at(i);
runtime/deoptimization.cpp:    } while ( i < list->length() );
runtime/deoptimization.cpp:    if (list->length() == 0) {
runtime/deoptimization.cpp:    // Verify that the just-unpacked frames match the interpreter's
runtime/frame.cpp:  st->print_cr("Register map");
runtime/frame.cpp:      st->print(" [" INTPTR_FORMAT "] = ", p2i(src));
runtime/frame.cpp:        st->print_cr("<misaligned>");
runtime/frame.cpp:        st->print_cr(INTPTR_FORMAT, *src);
runtime/frame.cpp:  st->print("%s frame (sp=" INTPTR_FORMAT " unextended sp=" INTPTR_FORMAT, print_name(), p2i(sp()), p2i(unextended_sp()));
runtime/frame.cpp:    st->print(", fp=" INTPTR_FORMAT ", real_fp=" INTPTR_FORMAT ", pc=" INTPTR_FORMAT,
runtime/frame.cpp:    st->print_cr(")");
runtime/frame.cpp:    st->print("(");
runtime/frame.cpp:    st->print("~Stub::%s", desc->name());
runtime/frame.cpp:    st->print_cr(")");
runtime/frame.cpp:    st->print("(");
runtime/frame.cpp:      st->print("~");
runtime/frame.cpp:      st->print("~interpreter");
runtime/frame.cpp:  st->print_cr(")");
runtime/frame.cpp:    st->print("     ");
runtime/frame.cpp:    st->cr();
runtime/frame.cpp:    st->print(" - local  [" INTPTR_FORMAT "]", x);
runtime/frame.cpp:    st->fill_to(23);
runtime/frame.cpp:    st->print_cr("; #%d", i);
runtime/frame.cpp:    st->print(" - stack  [" INTPTR_FORMAT "]", x);
runtime/frame.cpp:    st->fill_to(23);
runtime/frame.cpp:    st->print_cr("; #%d", i);
runtime/frame.cpp:    st->print(" - obj    [");
runtime/frame.cpp:    st->print_cr("]");
runtime/frame.cpp:    st->print(" - lock   [");
runtime/frame.cpp:    st->print_cr("]");
runtime/frame.cpp:  st->print_cr(" - monitor[" INTPTR_FORMAT "]", p2i(interpreter_frame_monitor_begin()));
runtime/frame.cpp:  st->print(" - bcp    [" INTPTR_FORMAT "]", p2i(interpreter_frame_bcp()));
runtime/frame.cpp:  st->fill_to(23);
runtime/frame.cpp:  st->print_cr("; @%d", interpreter_frame_bci());
runtime/frame.cpp:  st->print_cr(" - locals [" INTPTR_FORMAT "]", p2i(interpreter_frame_local_at(0)));
runtime/frame.cpp:  st->print(" - method [" INTPTR_FORMAT "]", p2i(interpreter_frame_method()));
runtime/frame.cpp:  st->fill_to(23);
runtime/frame.cpp:  st->print("; ");
runtime/frame.cpp:  st->cr();
runtime/frame.cpp:  st->print(in_vm ? "V" : "C");
runtime/frame.cpp:    st->print("  [%s+0x%x]", p1, offset);
runtime/frame.cpp:    st->print("  " PTR_FORMAT, p2i(pc));
runtime/frame.cpp:    st->print("  %s+0x%x", buf, offset);
runtime/frame.cpp:        st->print("j  %s", buf);
runtime/frame.cpp:        st->print("+%d", this->interpreter_frame_bci());
runtime/frame.cpp:          st->print(" %s", buf);
runtime/frame.cpp:            st->print("@%s", buf);
runtime/frame.cpp:        st->print("j  " PTR_FORMAT, p2i(pc()));
runtime/frame.cpp:        st->print("v  ~StubRoutines::%s", desc->name());
runtime/frame.cpp:        st->print("v  ~StubRoutines::" PTR_FORMAT, p2i(pc()));
runtime/frame.cpp:      st->print("v  ~BufferBlob::%s", ((BufferBlob *)_cb)->name());
runtime/frame.cpp:          st->print("A %d ", cm->compile_id());
runtime/frame.cpp:          st->print("J %d%s", nm->compile_id(), (nm->is_osr_method() ? "%" : ""));
runtime/frame.cpp:          st->print(" %s", nm->compiler_name());
runtime/frame.cpp:        st->print(" %s", buf);
runtime/frame.cpp:          st->print(" %s", buf);
runtime/frame.cpp:            st->print("@%s", buf);
runtime/frame.cpp:        st->print(" (%d bytes) @ " PTR_FORMAT " [" PTR_FORMAT "+" INTPTR_FORMAT "]",
runtime/frame.cpp:            st->print(" (%s)", jvmciName);
runtime/frame.cpp:        st->print("J  " PTR_FORMAT, p2i(pc()));
runtime/frame.cpp:      st->print("v  ~RuntimeStub::%s", ((RuntimeStub *)_cb)->name());
runtime/frame.cpp:      st->print("v  ~DeoptimizationBlob");
runtime/frame.cpp:      st->print("v  ~ExceptionBlob");
runtime/frame.cpp:      st->print("v  ~SafepointBlob");
runtime/frame.cpp:      st->print("v  ~AdapterBlob");
runtime/frame.cpp:      st->print("v  ~VtableBlob");
runtime/frame.cpp:      st->print("v  ~MethodHandlesAdapterBlob");
runtime/frame.cpp:      st->print("v  ~UncommonTrapBlob");
runtime/frame.cpp:      st->print("v  blob " PTR_FORMAT, p2i(pc()));
runtime/abstract_vm_version.cpp:  st->print_cr("Virtualization information:");
runtime/abstract_vm_version.cpp:        st->print("%s", line);
runtime/reflection.cpp:      // Nestmate access checks may require resolution and validation of the nest-host.
services/threadService.cpp:  // Initialize the depth-first-number for each JavaThread.
services/threadService.cpp:              last->set_next(cycle);
services/threadService.cpp:          last->set_next(cycle);
services/threadService.cpp:    _last->set_next(ts);
services/threadService.cpp:    int length = list->length();
services/threadService.cpp:        MonitorInfo* monitor = list->at(i);
services/threadService.cpp:    st->print_cr("\t- locked <" INTPTR_FORMAT "> (a %s)", p2i(o), o->klass()->external_name());
services/threadService.cpp:    _last->set_next(tcl);
services/threadService.cpp:  st->print_cr("   Locked ownable synchronizers:");
services/threadService.cpp:    st->print_cr("\t- None");
services/threadService.cpp:    st->cr();
services/threadService.cpp:    st->print_cr("\t- <" INTPTR_FORMAT "> (a %s)", p2i(obj), obj->klass()->external_name());
services/threadService.cpp:  st->cr();
services/threadService.cpp:  st->cr();
services/threadService.cpp:  st->print_cr("Found one Java-level deadlock:");
services/threadService.cpp:  st->print("=============================");
services/threadService.cpp:    st->cr();
services/threadService.cpp:    st->print_cr("\"%s\":", currentThread->get_thread_name());
services/threadService.cpp:      st->print("  waiting to lock JVM TI raw monitor " INTPTR_FORMAT, p2i(waitingToLockRawMonitor));
services/threadService.cpp:          st->print_cr("%s \"%s\"", owner_desc, currentThread->get_thread_name());
services/threadService.cpp:          st->print_cr(",\n  which has now been released");
services/threadService.cpp:        st->print_cr("%s non-Java thread=" PTR_FORMAT, owner_desc, p2i(owner));
services/threadService.cpp:      st->print("  waiting to lock monitor " INTPTR_FORMAT, p2i(waitingToLockMonitor));
services/threadService.cpp:      st->print(" (object " INTPTR_FORMAT ", a %s)", p2i(obj),
services/threadService.cpp:        st->print_cr("%s UNKNOWN_owner_addr=" PTR_FORMAT, owner_desc,
services/threadService.cpp:      st->print("  waiting for ownable synchronizer " INTPTR_FORMAT ", (a %s)",
services/threadService.cpp:    st->print_cr("%s \"%s\"", owner_desc, currentThread->get_thread_name());
services/threadService.cpp:  st->cr();
services/threadService.cpp:  st->print_cr("Java stack information for the threads listed above:");
services/threadService.cpp:  st->print_cr("===================================================");
services/threadService.cpp:    st->print_cr("\"%s\":", currentThread->get_thread_name());
services/diagnosticCommand.cpp:    cmd_list->sort(compare_strings);
services/diagnosticCommand.cpp:    for (int i = 0; i < cmd_list->length(); i++) {
services/diagnosticCommand.cpp:      DCmdFactory* factory = DCmdFactory::factory(source, cmd_list->at(i),
services/diagnosticCommand.cpp:                                                  strlen(cmd_list->at(i)));
services/diagnosticCommand.cpp:    cmd_list->sort(compare_strings);
services/diagnosticCommand.cpp:    for (int i = 0; i < cmd_list->length(); i++) {
services/diagnosticCommand.cpp:      DCmdFactory* factory = DCmdFactory::factory(source, cmd_list->at(i),
services/diagnosticCommand.cpp:                                                  strlen(cmd_list->at(i)));
services/heapDumperCompression.cpp:  while (!list->is_empty()) {
services/heapDumperCompression.cpp:    free_work(list->remove_first());
services/threadStackTracker.cpp:          exist->allocate(ts->size());
services/gcNotifier.cpp:    last_request->next = request;
services/gcNotifier.cpp:    first_request = first_request->next;
services/gcNotifier.cpp:    Handle objGcInfo = createGcInfo(request->gcManager, request->gcStatInfo, CHECK);
services/gcNotifier.cpp:    Handle objName = java_lang_String::create_from_str(request->gcManager->name(), CHECK);
services/gcNotifier.cpp:    Handle objAction = java_lang_String::create_from_str(request->gcAction, CHECK);
services/gcNotifier.cpp:    Handle objCause = java_lang_String::create_from_str(request->gcCause, CHECK);
services/gcNotifier.cpp:    instanceOop gc_mbean = request->gcManager->get_memory_manager_instance(THREAD);
services/gcNotifier.cpp:    args.push_long(request->timestamp);
services/memoryManager.cpp:    dest->set_index(_last_gc_stat->gc_index());
services/memoryManager.cpp:    dest->set_start_time(_last_gc_stat->start_time());
services/memoryManager.cpp:    dest->set_end_time(_last_gc_stat->end_time());
services/memoryManager.cpp:    assert(dest->usage_array_size() == _last_gc_stat->usage_array_size(),
services/memoryManager.cpp:    size_t len = dest->usage_array_size() * sizeof(MemoryUsage);
services/memoryManager.cpp:    memcpy(dest->before_gc_usage_array(), _last_gc_stat->before_gc_usage_array(), len);
services/memoryManager.cpp:    memcpy(dest->after_gc_usage_array(), _last_gc_stat->after_gc_usage_array(), len);
services/management.cpp:    stacktrace_h = st->allocate_fill_stack_trace_element_array(CHECK);
services/management.cpp:          dcmd_list->length(), CHECK_NULL);
services/management.cpp:  for (int i = 0; i < dcmd_list->length(); i++) {
services/management.cpp:    oop cmd_name = java_lang_String::create_oop_from_str(dcmd_list->at(i), CHECK_NULL);
services/management.cpp:    int pos = info_list->find((void*)cmd_name,DCmdInfo::by_name);
services/management.cpp:    DCmdInfo* info = info_list->at(pos);
services/memoryService.cpp:  _pools_list->appendAll(&gc_mem_pools);
services/memoryService.cpp:    _managers_list->append(gc_manager);
services/memoryService.cpp:  _pools_list->append(code_heap_pool);
services/memoryService.cpp:    _managers_list->append(_code_cache_manager);
services/memoryService.cpp:  _pools_list->append(_metaspace_pool);
services/memoryService.cpp:    _pools_list->append(_compressed_class_pool);
services/memoryService.cpp:  _managers_list->append(mgr);
services/memoryService.cpp:  for (int i = 0; i < _managers_list->length(); i++) {
services/memoryService.cpp:    MemoryManager* mgr = _managers_list->at(i);
services/memoryService.cpp:  for (int i = 0; i < _pools_list->length(); i++) {
services/memoryService.cpp:    MemoryPool* pool = _pools_list->at(i);
services/memoryService.cpp:  for (int i = 0; i < _pools_list->length(); i++) {
services/memoryService.cpp:    MemoryPool* pool = _pools_list->at(i);
services/memoryService.cpp:    for (int i = 0; i < _pools_list->length(); i++) {
services/memoryService.cpp:      MemoryPool* pool = _pools_list->at(i);
services/memoryService.hpp:    return _pools_list->length();
services/memoryService.hpp:    return _managers_list->length();
services/memoryService.hpp:    return _pools_list->at(index);
services/memoryService.hpp:    return _managers_list->at(index);
utilities/bitMap.cpp:  st->print_cr("%s[" PTR_FORMAT ", " PTR_FORMAT ")",
utilities/virtualizationSupport.cpp:    st->print_cr("vSphere host information:");
utilities/virtualizationSupport.cpp:    st->print_cr("%s", host_information);
utilities/virtualizationSupport.cpp:    st->print_cr("vSphere resource information collected at VM startup:");
utilities/virtualizationSupport.cpp:    st->print_cr("%s", extended_resource_info_at_startup);
utilities/virtualizationSupport.cpp:      st->print_cr("vSphere resource information available now:");
utilities/virtualizationSupport.cpp:      st->print_cr("%s", result_info);
utilities/events.hpp:// This facility is extremly useful for post-mortem debugging. The eventlog
utilities/accessFlags.cpp:  if (is_public      ()) st->print("public "      );
utilities/accessFlags.cpp:  if (is_private     ()) st->print("private "     );
utilities/accessFlags.cpp:  if (is_protected   ()) st->print("protected "   );
utilities/accessFlags.cpp:  if (is_static      ()) st->print("static "      );
utilities/accessFlags.cpp:  if (is_final       ()) st->print("final "       );
utilities/accessFlags.cpp:  if (is_synchronized()) st->print("synchronized ");
utilities/accessFlags.cpp:  if (is_volatile    ()) st->print("volatile "    );
utilities/accessFlags.cpp:  if (is_transient   ()) st->print("transient "   );
utilities/accessFlags.cpp:  if (is_native      ()) st->print("native "      );
utilities/accessFlags.cpp:  if (is_interface   ()) st->print("interface "   );
utilities/accessFlags.cpp:  if (is_abstract    ()) st->print("abstract "    );
utilities/accessFlags.cpp:  if (is_strict      ()) st->print("strict "      );
utilities/accessFlags.cpp:  if (is_synthetic   ()) st->print("synthetic "   );
utilities/accessFlags.cpp:  if (is_old         ()) st->print("{old} "       );
utilities/accessFlags.cpp:  if (is_obsolete    ()) st->print("{obsolete} "  );
utilities/accessFlags.cpp:  if (on_stack       ()) st->print("{on_stack} "  );
utilities/constantTag.cpp:  st->print("%s", internal_name());
utilities/ostream.cpp:      // code looping, while not affecting cases of just-very-large-but-its-normal
utilities/ostream.cpp:      memcpy(&server.sin_addr, host->h_addr_list[0], host->h_length);
utilities/json.cpp:    _st->print("%s on line %u byte %u: ", JSON::strerror(e), line, column + 1);
utilities/json.cpp:    _st->vprint(format, args);
utilities/json.cpp:    _st->cr();
utilities/json.cpp:      _st->print("  Got ");
utilities/json.cpp:      _st->print_cr("EOS.");
utilities/json.cpp:      _st->print("  At ");
utilities/json.cpp:      _st->print("'");
utilities/json.cpp:        _st->print("%c", c);
utilities/json.cpp:      _st->print_cr("'.");
utilities/json.cpp:    _st->print_cr("%s", line_start);
utilities/tableStatistics.cpp:  st->print_cr("%s statistics:", table_name);
utilities/tableStatistics.cpp:  st->print_cr("Number of buckets       : %9" PRIuPTR " = %9" PRIuPTR
utilities/tableStatistics.cpp:  st->print_cr("Number of entries       : %9" PRIuPTR " = %9" PRIuPTR
utilities/tableStatistics.cpp:    st->print_cr("Number of literals      : %9" PRIuPTR " = %9" PRIuPTR
utilities/tableStatistics.cpp:  st->print_cr("Total footprint         : %9s = %9" PRIuPTR " bytes", "", _total_footprint);
utilities/tableStatistics.cpp:  st->print_cr("Average bucket size     : %9.3f", _average_bucket_size);
utilities/tableStatistics.cpp:  st->print_cr("Variance of bucket size : %9.3f", _variance_of_bucket_size);
utilities/tableStatistics.cpp:  st->print_cr("Std. dev. of bucket size: %9.3f", _stddev_of_bucket_size);
utilities/tableStatistics.cpp:  st->print_cr("Maximum bucket size     : %9" PRIuPTR, _maximum_bucket_size);
utilities/concurrentHashTable.inline.hpp:    st->print_cr("statistics unavailable at this moment");
utilities/hashtable.cpp:    _free_list = _free_list->next();
utilities/histogram.cpp:  st->print("%10d   ",((HistogramElement*)this)->count());
utilities/histogram.cpp:  st->print_cr("%s",((HistogramElement*)this)->name());
utilities/histogram.cpp:  st->print_cr("%s",title());
utilities/histogram.cpp:  st->print_cr("--------------------------------------------------");
utilities/histogram.cpp:  st->print("%10d   ", total);
utilities/histogram.cpp:  st->print_cr("Total");
utilities/exceptions.cpp:    st->print_cr("OutOfMemoryError %s=%d", err, count);
utilities/exceptions.cpp:    st->print_cr("StackOverflowErrors=%d", _stack_overflow_errors);
utilities/exceptions.cpp:    st->print_cr("LinkageErrors=%d", _linkage_errors);
utilities/vmError.cpp:    st->print("Java frames:");
utilities/vmError.cpp:    st->cr();
utilities/vmError.cpp:      st->cr();
utilities/vmError.cpp:    st->print_cr("Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)");
utilities/vmError.cpp:      st->cr();
utilities/vmError.cpp:    st->print_cr("Native frames: (J=compiled Java code, A=aot compiled Java code, j=interpreted, Vv=VM code, C=native code)");
utilities/vmError.cpp:          st->print("  (%s:%d)", buf, line_no);
utilities/vmError.cpp:      st->cr();
utilities/vmError.cpp:      st->print_cr("...<more frames>...");
utilities/vmError.cpp:    st->cr();
utilities/vmError.cpp:  st->print_cr("# Possible reasons:");
utilities/vmError.cpp:  st->print_cr("#   The system is out of physical RAM or swap space");
utilities/vmError.cpp:    st->print_cr("#   The process is running with CompressedOops enabled, and the Java Heap may be blocking the growth of the native heap");
utilities/vmError.cpp:    st->print_cr("#   In 32 bit mode, the process size limit was hit");
utilities/vmError.cpp:  st->print_cr("# Possible solutions:");
utilities/vmError.cpp:  st->print_cr("#   Reduce memory load on the system");
utilities/vmError.cpp:  st->print_cr("#   Increase physical memory or swap space");
utilities/vmError.cpp:  st->print_cr("#   Check if swap backing store is full");
utilities/vmError.cpp:    st->print_cr("#   Use 64 bit Java on a 64 bit OS");
utilities/vmError.cpp:  st->print_cr("#   Decrease Java heap size (-Xmx/-Xms)");
utilities/vmError.cpp:  st->print_cr("#   Decrease number of Java threads");
utilities/vmError.cpp:  st->print_cr("#   Decrease Java thread stack sizes (-Xss)");
utilities/vmError.cpp:  st->print_cr("#   Set larger code cache with -XX:ReservedCodeCacheSize=");
utilities/vmError.cpp:        st->print_cr("#   JVM is running with Unscaled Compressed Oops mode in which the Java heap is");
utilities/vmError.cpp:        st->print_cr("#     placed in the first 4GB address space. The Java Heap base address is the");
utilities/vmError.cpp:        st->print_cr("#     maximum limit for the native heap growth. Please use -XX:HeapBaseMinAddress");
utilities/vmError.cpp:        st->print_cr("#     to set the Java Heap base and to place the Java Heap above 4GB virtual address.");
utilities/vmError.cpp:        st->print_cr("#   JVM is running with Zero Based Compressed Oops mode in which the Java heap is");
utilities/vmError.cpp:        st->print_cr("#     placed in the first 32GB address space. The Java Heap base address is the");
utilities/vmError.cpp:        st->print_cr("#     maximum limit for the native heap growth. Please use -XX:HeapBaseMinAddress");
utilities/vmError.cpp:        st->print_cr("#     to set the Java Heap base and to place the Java Heap above 32GB virtual address.");
utilities/vmError.cpp:  st->print_cr("# This output file may be truncated or incomplete.");
utilities/vmError.cpp:   st->print_cr("#");
utilities/vmError.cpp:   st->print_cr("# JRE version: %s%s%s (%s) (%sbuild %s)", runtime_name,
utilities/vmError.cpp:   st->print_cr("# Java VM: %s%s%s (%s%s, %s%s%s%s%s, %s, %s)",
utilities/vmError.cpp:    st->print_cr("#");
utilities/vmError.cpp:      st->print_cr("# A fatal error has been detected by the Java Runtime Environment:");
utilities/vmError.cpp:      st->print_cr("# There is insufficient memory for the Java "
utilities/vmError.cpp:      st->print_cr("Will crash now (TestCrashInErrorHandler=" UINTX_FORMAT ")...",
utilities/vmError.cpp:      st->print_cr("Will crash now (TestCrashInErrorHandler=" UINTX_FORMAT ")...",
utilities/vmError.cpp:      st->print_cr("Will test SafeFetch...");
utilities/vmError.cpp:          st->print_cr("SafeFetch OK."); // Correctly deflected and returned default pattern
utilities/vmError.cpp:          st->print_cr("??");
utilities/vmError.cpp:        st->print_cr("not possible; skipped.");
utilities/vmError.cpp:           st->print("# Native memory allocation ");
utilities/vmError.cpp:           st->print((_id == (int)OOM_MALLOC_ERROR) ? "(malloc) failed to allocate " :
utilities/vmError.cpp:           st->print("%s", buf);
utilities/vmError.cpp:           st->print(" bytes");
utilities/vmError.cpp:             st->print(" for ");
utilities/vmError.cpp:             st->print("%s", _detail_msg);
utilities/vmError.cpp:           st->cr();
utilities/vmError.cpp:             st->print("# ");
utilities/vmError.cpp:             st->print_cr("%s", _detail_msg);
utilities/vmError.cpp:     st->print_cr("#");
utilities/vmError.cpp:     st->print("#  ");
utilities/vmError.cpp:       st->print("%s", buf);
utilities/vmError.cpp:       st->print(" (0x%x)", _id);                // signal number
utilities/vmError.cpp:       st->print(" at pc=" PTR_FORMAT, p2i(_pc));
utilities/vmError.cpp:         st->print(" (sent by kill)");
utilities/vmError.cpp:         st->print("Internal Error");
utilities/vmError.cpp:         st->print("Out of Memory Error");
utilities/vmError.cpp:         st->print(" (%s:%d)", file, _lineno);
utilities/vmError.cpp:         st->print(" (0x%x)", _id);
utilities/vmError.cpp:     st->print(", pid=%d", os::current_process_id());
utilities/vmError.cpp:     st->print(", tid=" UINTX_FORMAT, os::current_thread_id());
utilities/vmError.cpp:     st->cr();
utilities/vmError.cpp:         st->print_cr("#  %s: %s", _message ? _message : "Error", _detail_msg);
utilities/vmError.cpp:         st->print_cr("#  Error: %s", _message);
utilities/vmError.cpp:       st->print_cr("# Problematic frame:");
utilities/vmError.cpp:       st->print("# ");
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->print_cr("#");
utilities/vmError.cpp:    st->print("# ");
utilities/vmError.cpp:        st->print("Core dump will be written. Default location: %s", coredump_message);
utilities/vmError.cpp:        st->print("No core dump will be written. %s", coredump_message);
utilities/vmError.cpp:      st->print("CreateCoredumpOnCrash turned off, no core file dumped");
utilities/vmError.cpp:    st->cr();
utilities/vmError.cpp:    st->print_cr("#");
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->print_cr("---------------  S U M M A R Y ------------");
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->print_cr("---------------  T H R E A D  ---------------");
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:         st->print("Current thread (" PTR_FORMAT "):  ", p2i(_thread));
utilities/vmError.cpp:         st->cr();
utilities/vmError.cpp:         st->print_cr("Current thread is native thread");
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:           st->cr();
utilities/vmError.cpp:           st->print_cr("Current CompileTask:");
utilities/vmError.cpp:           st->cr();
utilities/vmError.cpp:       st->print("Stack: ");
utilities/vmError.cpp:       st->print("[" PTR_FORMAT "," PTR_FORMAT "]", p2i(stack_bottom), p2i(stack_top));
utilities/vmError.cpp:         st->print(",  sp=" PTR_FORMAT, p2i(fr.sp()));
utilities/vmError.cpp:         st->print(",  free space=" SIZE_FORMAT "k", free_stack_size);
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:         st->print_cr("JavaThread " PTR_FORMAT " (nid = %d) was being processed", p2i(jt), jt->osthread()->thread_id());
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:         st->print_cr("Stack slot to memory mapping:");
utilities/vmError.cpp:           st->print("stack at sp + %d slots: ", i);
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:             st->cr();
utilities/vmError.cpp:          st->cr();
utilities/vmError.cpp:          st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->print_cr("---------------  P R O C E S S  ---------------");
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->print("VM state: ");
utilities/vmError.cpp:       if (SafepointSynchronize::is_synchronizing()) st->print("synchronizing");
utilities/vmError.cpp:       else if (SafepointSynchronize::is_at_safepoint()) st->print("at safepoint");
utilities/vmError.cpp:       else st->print("not at safepoint");
utilities/vmError.cpp:         st->print(" (not fully initialized)");
utilities/vmError.cpp:         st->print(" (shutting down)");
utilities/vmError.cpp:         st->print(" (normal execution)");
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->print_cr("OutOfMemory and StackOverflow Exception counts:");
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:         st->cr();
utilities/vmError.cpp:         st->print_cr("Polling page: " INTPTR_FORMAT, p2i(SafepointMechanism::get_polling_page()));
utilities/vmError.cpp:         st->cr();
utilities/vmError.cpp:       st->print_cr("Metaspace:");
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:      st->cr();
utilities/vmError.cpp:       st->print_cr("Unsupported internal testing APIs have been used.");
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:      st->print_cr("Logging:");
utilities/vmError.cpp:      st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->print_cr("---------------  S Y S T E M  ---------------");
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->print_cr("vm_info: %s", VM_Version::internal_vm_info_string());
utilities/vmError.cpp:       st->cr();
utilities/vmError.cpp:       st->print_cr("END.");
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:  st->print_cr("---------------  S U M M A R Y ------------");
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:  st->print_cr("---------------  P R O C E S S  ---------------");
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:    st->print_cr("OutOfMemory and StackOverflow Exception counts:");
utilities/vmError.cpp:    st->cr();
utilities/vmError.cpp:    st->cr();
utilities/vmError.cpp:    st->cr();
utilities/vmError.cpp:    st->print_cr("Polling page: " INTPTR_FORMAT, p2i(SafepointMechanism::get_polling_page()));
utilities/vmError.cpp:    st->cr();
utilities/vmError.cpp:    st->print_cr("Metaspace:");
utilities/vmError.cpp:    st->cr();
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:    st->print_cr("Unsupported internal testing APIs have been used.");
utilities/vmError.cpp:    st->cr();
utilities/vmError.cpp:  st->print_cr("Logging:");
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:  st->print_cr("---------------  S Y S T E M  ---------------");
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:  st->print_cr("vm_info: %s", VM_Version::internal_vm_info_string());
utilities/vmError.cpp:  st->cr();
utilities/vmError.cpp:  st->print_cr("END.");
utilities/vmError.cpp:      st->cr();
utilities/vmError.cpp:        st->print_raw("[timeout occurred during error reporting in step \"");
utilities/vmError.cpp:        st->print_raw(_current_step_info);
utilities/vmError.cpp:        st->print_cr("\"] after " INT64_FORMAT " s.",
utilities/vmError.cpp:        st->print_cr("------ Timeout during error reporting after " INT64_FORMAT " s. ------",
utilities/vmError.cpp:        st->flush();
utilities/vmError.cpp:        st->print_raw_cr(buffer);
utilities/vmError.cpp:        st->cr();
utilities/linkedlist.hpp:    assert(list->storage_type() == this->storage_type(), "Different storage type");
utilities/linkedlist.hpp:      this->set_head(list->head());
utilities/linkedlist.hpp:      node->set_next(list->head());
utilities/linkedlist.hpp:    list->set_head(NULL);
utilities/linkedlist.hpp:    LinkedListNode<E>* node = list->head();
utilities/linkedlist.hpp:    assert(list->storage_type() == this->storage_type(), "Different storage type");
utilities/linkedlist.hpp:    while ((node = list->unlink_head()) != NULL) {
utilities/linkedlist.hpp:    assert(list->is_empty(), "All entries are moved");
